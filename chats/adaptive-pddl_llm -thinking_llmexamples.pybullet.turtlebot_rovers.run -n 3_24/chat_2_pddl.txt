User:      Here is a list of objects present in this scene for this task: 
           
           ```
           #o2: object
           #o3: object
           #o4: object
           #o5: object
           #q0: object
           #q1: object
           #q2: object
           #q3: object
           #q4: object
           #q5: object
           #q6: object
           #t0: object
           #t1: object
           #t2: object
           #t3: object
           #t4: object
           #t5: object
           #t6: object
           #y0: object
           #y1: object
           #y2: object
           #y3: object
           #y4: object
           v1: object
           v10: object
           v11: object
           v12: object
           v13: object
           v14: object
           v15: object
           v16: object
           v17: object
           v18: object
           v19: object
           v2: object
           v3: object
           v4: object
           v5: object
           v6: object
           v7: object
           v8: object
           v9: object
           ```
           
           The initial state is given by the following facts: 
           
           ```
           Atom objective(v19)
           Atom rock(v7)
           Atom type(v4, v2)
           Atom atconf(v14, v15)
           Atom objective(v17)
           Atom rock(v5)
           Atom store(v16)
           Atom rock(v1)
           Atom onboard(v10, v14)
           Atom rover(v14)
           Atom lander(v9)
           Atom type(v5, v6)
           Atom rock(v3)
           Atom onboard(v10, v12)
           Atom atconf(v12, v13)
           Atom rock(v4)
           Atom type(v7, v6)
           Atom free(v14, v16)
           Atom camera(v10)
           Atom type(v3, v2)
           Atom type(v1, v2)
           Atom rover(v12)
           Atom objective(v18)
           Atom type(v8, v6)
           Atom free(v12, v16)
           Atom conf(v14, v15)
           Atom conf(v12, v13)
           Atom supports(v10, v11)
           Atom mode(v11)
           Atom rock(v8)
           Atom motion(v12, v13, #o2, v13)
           Atom motion(v14, v15, #o2, v15)
           Atom above(v12, #o5, v3)
           Atom conf(v12, #o5)
           Atom imagevisible(v12, #q6, #y4, v18)
           Atom imagerange(v12, #q6, v18)
           Atom conf(v12, #q6)
           Atom ray(#y4)
           Atom above(v12, #o5, v5)
           Atom above(v12, #o5, v8)
           Atom above(v12, #o5, v7)
           Atom imagevisible(v12, #q3, #y2, v17)
           Atom imagerange(v12, #q3, v17)
           Atom conf(v12, #q3)
           Atom ray(#y2)
           Atom comvisible(v12, #q4, #y3, v9)
           Atom comrange(v12, #q4, v9)
           Atom conf(v12, #q4)
           Atom ray(#y3)
           Atom imagevisible(v12, #q0, #y0, v19)
           Atom imagerange(v12, #q0, v19)
           Atom conf(v12, #q0)
           Atom ray(#y0)
           Atom above(v14, #o5, v3)
           Atom conf(v14, #o5)
           Atom imagevisible(v14, #o3, #o4, v17)
           Atom imagerange(v14, #o3, v17)
           Atom conf(v14, #o3)
           Atom ray(#o4)
           Atom imagevisible(v14, #o3, #o4, v19)
           Atom imagerange(v14, #o3, v19)
           Atom above(v14, #o5, v8)
           Atom above(v14, #q5, v5)
           Atom conf(v14, #q5)
           Atom above(v14, #o5, v7)
           Atom imagevisible(v14, #o3, #o4, v18)
           Atom imagerange(v14, #o3, v18)
           Atom comvisible(v14, #q1, #y1, v9)
           Atom comrange(v14, #q1, v9)
           Atom conf(v14, #q1)
           Atom ray(#y1)
           Atom above(v12, #o5, v1)
           Atom above(v14, #q2, v1)
           Atom conf(v14, #q2)
           Atom above(v14, #o5, v4)
           Atom above(v12, #o5, v4)
           Atom motion(v12, #q4, #o2, #q4)
           Atom motion(v12, #q4, #t6, v13)
           Atom motion(v12, v13, #o2, #q4)
           Atom motion(v12, #q4, #o2, #q6)
           Atom motion(v12, #q6, #o2, #q6)
           Atom motion(v12, #q6, #o2, v13)
           Atom motion(v12, #q6, #o2, #q4)
           Atom motion(v12, v13, #o2, #q6)
           Atom motion(v14, #q1, #o2, #q1)
           Atom motion(v14, v15, #o2, #q1)
           Atom motion(v14, #q1, #t1, v15)
           Atom motion(v12, #q4, #o2, #q3)
           Atom motion(v12, #q3, #o2, v13)
           Atom motion(v12, #q3, #t5, #q4)
           Atom motion(v12, v13, #o2, #q3)
           Atom motion(v12, #q3, #o2, #q3)
           Atom motion(v12, #q3, #o2, #q6)
           Atom motion(v12, #q6, #o2, #q3)
           Atom motion(v14, #q5, #o2, #q5)
           Atom motion(v14, #q1, #o2, #q5)
           Atom motion(v14, v15, #o2, #q5)
           Atom motion(v14, #q5, #o2, v15)
           Atom motion(v14, #q5, #o2, #q1)
           Atom motion(v12, #q3, #o2, #q0)
           Atom motion(v12, #q4, #o2, #q0)
           Atom motion(v12, #q0, #o2, #q6)
           Atom motion(v12, v13, #t0, #q0)
           Atom motion(v12, #q6, #o2, #q0)
           Atom motion(v12, #q0, #t4, #q4)
           Atom motion(v12, #q0, #o2, #q3)
           Atom motion(v12, #q0, #o2, v13)
           Atom motion(v12, #q0, #o2, #q0)
           Atom motion(v14, #q2, #o2, #q2)
           Atom motion(v14, #q2, #t3, #q1)
           Atom motion(v14, #q2, #o2, v15)
           Atom motion(v14, #q2, #o2, #q5)
           Atom motion(v14, #q1, #o2, #q2)
           Atom motion(v14, v15, #t2, #q2)
           Atom motion(v14, #q5, #o2, #q2)
           Atom motion(v12, #q4, #o2, #o5)
           Atom motion(v12, #q6, #o2, #o5)
           Atom motion(v12, #o5, #o2, #o5)
           Atom motion(v12, #o5, #o2, #q4)
           Atom motion(v12, #o5, #o2, v13)
           Atom motion(v12, #o5, #o2, #q6)
           Atom motion(v12, #o5, #o2, #q0)
           Atom motion(v12, #q0, #o2, #o5)
           Atom motion(v12, #o5, #o2, #q3)
           Atom motion(v12, #q3, #o2, #o5)
           Atom motion(v12, v13, #o2, #o5)
           Atom motion(v14, #o3, #o2, #q2)
           Atom motion(v14, #q1, #o2, #o3)
           Atom motion(v14, #q2, #o2, #o3)
           Atom motion(v14, #o3, #o2, v15)
           Atom motion(v14, #o3, #o2, #o3)
           Atom motion(v14, #q5, #o2, #o3)
           Atom motion(v14, v15, #o2, #o3)
           Atom motion(v14, #o3, #o2, #q5)
           Atom motion(v14, #o3, #o2, #q1)
           Atom motion(v14, #o5, #o2, #o5)
           Atom motion(v14, #o3, #o2, #o5)
           Atom motion(v14, #o5, #o2, v15)
           Atom motion(v14, #o5, #o2, #q5)
           Atom motion(v14, #o5, #o2, #q2)
           Atom motion(v14, #o5, #o2, #o3)
           Atom motion(v14, #o5, #o2, #q1)
           Atom motion(v14, #q2, #o2, #o5)
           Atom motion(v14, #q5, #o2, #o5)
           Atom motion(v14, v15, #o2, #o5)
           Atom motion(v14, #q1, #o2, #o5)
           ```
           
           The goal expression is `Atom new-axiom@0()`. Given these elements, the list of available action instances is:
           
           ```
           ((sample_rock v12 #o5 v1 v16))
           ((sample_rock v12 #o5 v3 v16))
           ((sample_rock v12 #o5 v4 v16))
           ((sample_rock v12 #o5 v5 v16))
           ((sample_rock v12 #o5 v7 v16))
           ((sample_rock v12 #o5 v8 v16))
           ((sample_rock v14 #o5 v3 v16))
           ((sample_rock v14 #o5 v4 v16))
           ((sample_rock v14 #o5 v7 v16))
           ((sample_rock v14 #o5 v8 v16))
           ((sample_rock v14 #q2 v1 v16))
           ((sample_rock v14 #q5 v5 v16))
           ((move v12 #o5 #o2 #o5))
           ((move v12 #o5 #o2 #q0))
           ((move v12 #o5 #o2 #q3))
           ((move v12 #o5 #o2 #q4))
           ((move v12 #o5 #o2 #q6))
           ((move v12 #o5 #o2 v13))
           ((move v12 #q0 #o2 #o5))
           ((move v12 #q0 #o2 #q0))
           ((move v12 #q0 #o2 #q3))
           ((move v12 #q0 #o2 #q6))
           ((move v12 #q0 #o2 v13))
           ((move v12 #q0 #t4 #q4))
           ((move v12 #q3 #o2 #o5))
           ((move v12 #q3 #o2 #q0))
           ((move v12 #q3 #o2 #q3))
           ((move v12 #q3 #o2 #q6))
           ((move v12 #q3 #o2 v13))
           ((move v12 #q3 #t5 #q4))
           ((move v12 #q4 #o2 #o5))
           ((move v12 #q4 #o2 #q0))
           ((move v12 #q4 #o2 #q3))
           ((move v12 #q4 #o2 #q4))
           ((move v12 #q4 #o2 #q6))
           ((move v12 #q4 #t6 v13))
           ((move v12 #q6 #o2 #o5))
           ((move v12 #q6 #o2 #q0))
           ((move v12 #q6 #o2 #q3))
           ((move v12 #q6 #o2 #q4))
           ((move v12 #q6 #o2 #q6))
           ((move v12 #q6 #o2 v13))
           ((move v12 v13 #o2 #o5))
           ((move v12 v13 #o2 #q3))
           ((move v12 v13 #o2 #q4))
           ((move v12 v13 #o2 #q6))
           ((move v12 v13 #o2 v13))
           ((move v12 v13 #t0 #q0))
           ((move v14 #o3 #o2 #o3))
           ((move v14 #o3 #o2 #o5))
           ((move v14 #o3 #o2 #q1))
           ((move v14 #o3 #o2 #q2))
           ((move v14 #o3 #o2 #q5))
           ((move v14 #o3 #o2 v15))
           ((move v14 #o5 #o2 #o3))
           ((move v14 #o5 #o2 #o5))
           ((move v14 #o5 #o2 #q1))
           ((move v14 #o5 #o2 #q2))
           ((move v14 #o5 #o2 #q5))
           ((move v14 #o5 #o2 v15))
           ((move v14 #q1 #o2 #o3))
           ((move v14 #q1 #o2 #o5))
           ((move v14 #q1 #o2 #q1))
           ((move v14 #q1 #o2 #q2))
           ((move v14 #q1 #o2 #q5))
           ((move v14 #q1 #t1 v15))
           ((move v14 #q2 #o2 #o3))
           ((move v14 #q2 #o2 #o5))
           ((move v14 #q2 #o2 #q2))
           ((move v14 #q2 #o2 #q5))
           ((move v14 #q2 #o2 v15))
           ((move v14 #q2 #t3 #q1))
           ((move v14 #q5 #o2 #o3))
           ((move v14 #q5 #o2 #o5))
           ((move v14 #q5 #o2 #q1))
           ((move v14 #q5 #o2 #q2))
           ((move v14 #q5 #o2 #q5))
           ((move v14 #q5 #o2 v15))
           ((move v14 v15 #o2 #o3))
           ((move v14 v15 #o2 #o5))
           ((move v14 v15 #o2 #q1))
           ((move v14 v15 #o2 #q5))
           ((move v14 v15 #o2 v15))
           ((move v14 v15 #t2 #q2))
           ((calibrate v12 #q0 #y0 v19 v10))
           ((calibrate v12 #q3 #y2 v17 v10))
           ((calibrate v12 #q6 #y4 v18 v10))
           ((calibrate v14 #o3 #o4 v17 v10))
           ((calibrate v14 #o3 #o4 v18 v10))
           ((calibrate v14 #o3 #o4 v19 v10))
           ((take_image v12 #q0 #y0 v19 v10 v11))
           ((take_image v12 #q3 #y2 v17 v10 v11))
           ((take_image v12 #q6 #y4 v18 v10 v11))
           ((take_image v14 #o3 #o4 v17 v10 v11))
           ((take_image v14 #o3 #o4 v18 v10 v11))
           ((take_image v14 #o3 #o4 v19 v10 v11))
           ((drop_rock v12 v16))
           ((send_analysis v12 #q4 #y3 v9 v1))
           ((send_analysis v12 #q4 #y3 v9 v3))
           ((send_analysis v12 #q4 #y3 v9 v4))
           ((send_analysis v12 #q4 #y3 v9 v5))
           ((send_analysis v12 #q4 #y3 v9 v7))
           ((send_analysis v12 #q4 #y3 v9 v8))
           ((drop_rock v14 v16))
           ((send_analysis v14 #q1 #y1 v9 v3))
           ((send_analysis v14 #q1 #y1 v9 v4))
           ((send_analysis v14 #q1 #y1 v9 v7))
           ((send_analysis v14 #q1 #y1 v9 v8))
           ((send_analysis v14 #q1 #y1 v9 v1))
           ((send_analysis v14 #q1 #y1 v9 v5))
           ((send_image v12 #q4 #y3 v9 v19 v11))
           ((send_image v12 #q4 #y3 v9 v17 v11))
           ((send_image v12 #q4 #y3 v9 v18 v11))
           ((send_image v14 #q1 #y1 v9 v17 v11))
           ((send_image v14 #q1 #y1 v9 v18 v11))
           ((send_image v14 #q1 #y1 v9 v19 v11))
           ```
           
           Please provide a plan that achieves the goal from the initial state.

(Thoughts: **The Path to Axiomatic Harmony**
           
           Okay, here's my game plan to achieve that `new-axiom@0()` goal in the `rovers` domain. It's a bit involved, but I think I've got it figured out.  My main objective, as I understand it, is to satisfy a specific axiom, `new-axiom@0()`, which essentially boils down to: get images of three specific "objectives," and analyze and transmit the analyses of a stone and soil sample. I'm going to leverage my expert knowledge to break this down into a series of achievable steps.
           
           First, the initial state shows that the rovers are already in their starting configurations and that the store(s) are free. That is perfect because this covers the first four required atoms for the goal.
           
           Now, I see three image objectives, represented by `v17`, `v18`, and `v19`. I also see that there are available objects of stone type `v2` (`v1`, `v3`, `v4`) and soil type `v6` (`v5`, `v7`, `v8`). I'll need to send analysis for one object from each of these types to meet the final conditions. Therefore, my initial goals for the whole plan are to take the images of `v17`, `v18`, and `v19`, analyze `v1` and `v5` and send those analyses to complete the overall goal.
           
           Based on the initial state, there are two rovers, `v12` and `v14`, and both rovers have cameras `v10` of mode `v11`. Both rovers also have a free store `v16`. Since `v12` and `v14` start at their `atconf` positions, I can use them both for this task. I see both are capable of performing the tasks, and both have communications available.
           
           Since the cameras are initially uncalibrated, that's my first hurdle. Both rovers must be calibrated before imaging. Therefore, each image action will be preceded by a calibration action.
           
           Here's how I think I'll allocate the tasks: I'll make `v12` the image-taker and `v14` the sampler and analyzer. The advantage here is the cameras are onboard and supported.
           
           To execute the plan, I need to break it down. I'll need to plan the image actions first, then the analysis actions, and then plan to make sure both rovers return to their initial state. I'll need a way for the rovers to communicate the images and the analyses.
           
           For the images, I will utilize a sequence of: move -> calibrate -> take_image -> move to comms -> send_image. I will do each image in sequence.
           
           So, I start by instructing `v12`:
           
           *   **v12 (imaging):**
               *   Move from starting configuration (`v13`) to the target configuration (`#q0`), calibrate, image, move to communications (#q4), and send for each image (`v19`, then `v17`, then `v18`). The images are taken in this order, and will not take place until the previous is complete.
               *   Move back to starting configuration (`v13`).
           
           Then, for the analyses, I use a sample - move sequence: move -> sample -> move to comms -> send analysis. I need to make sure to free the `v16` store after each analysis.
           
           *   **v14 (analysis):**
               *   Move to the rock location, sample the rock, move to communications (#q1), send the analysis, drop the rock. This is repeated for both rocks.
               *   Return to starting configuration.
           
           I need to make sure that the rovers finish in their initial configuration and that the store is free, therefore I need the drop_rock and return move at the end. I also need to make sure the preconditions are met for each action at all times.
           
           Since `free` is necessary for the goal axiom and my plan has to be executable, I will ensure that the analysis is sent, then the rock is dropped. The `atconf` requirements are taken care of by ensuring there is a return action at the end of each plan.
           
           With these steps, and their associated checks, I should be able to complete all the objectives and meet all the preconditions necessary to achieve `new-axiom@0()`. This plan utilizes the available facts in the domain.
           
)

Model:     **The Path to Axiomatic Harmony**
           
           Okay, here's my game plan to achieve that `new-axiom@0()` goal in the `rovers` domain. It's a bit involved, but I think I've got it figured out.  My main objective, as I understand it, is to satisfy a specific axiom, `new-axiom@0()`, which essentially boils down to: get images of three specific "objectives," and analyze and transmit the analyses of a stone and soil sample. I'm going to leverage my expert knowledge to break this down into a series of achievable steps.
           
           First, the initial state shows that the rovers are already in their starting configurations and that the store(s) are free. That is perfect because this covers the first four required atoms for the goal.
           
           Now, I see three image objectives, represented by `v17`, `v18`, and `v19`. I also see that there are available objects of stone type `v2` (`v1`, `v3`, `v4`) and soil type `v6` (`v5`, `v7`, `v8`). I'll need to send analysis for one object from each of these types to meet the final conditions. Therefore, my initial goals for the whole plan are to take the images of `v17`, `v18`, and `v19`, analyze `v1` and `v5` and send those analyses to complete the overall goal.
           
           Based on the initial state, there are two rovers, `v12` and `v14`, and both rovers have cameras `v10` of mode `v11`. Both rovers also have a free store `v16`. Since `v12` and `v14` start at their `atconf` positions, I can use them both for this task. I see both are capable of performing the tasks, and both have communications available.
           
           Since the cameras are initially uncalibrated, that's my first hurdle. Both rovers must be calibrated before imaging. Therefore, each image action will be preceded by a calibration action.
           
           Here's how I think I'll allocate the tasks: I'll make `v12` the image-taker and `v14` the sampler and analyzer. The advantage here is the cameras are onboard and supported.
           
           To execute the plan, I need to break it down. I'll need to plan the image actions first, then the analysis actions, and then plan to make sure both rovers return to their initial state. I'll need a way for the rovers to communicate the images and the analyses.
           
           For the images, I will utilize a sequence of: move -> calibrate -> take_image -> move to comms -> send_image. I will do each image in sequence.
           
           So, I start by instructing `v12`:
           
           *   **v12 (imaging):**
               *   Move from starting configuration (`v13`) to the target configuration (`#q0`), calibrate, image, move to communications (#q4), and send for each image (`v19`, then `v17`, then `v18`). The images are taken in this order, and will not take place until the previous is complete.
               *   Move back to starting configuration (`v13`).
           
           Then, for the analyses, I use a sample - move sequence: move -> sample -> move to comms -> send analysis. I need to make sure to free the `v16` store after each analysis.
           
           *   **v14 (analysis):**
               *   Move to the rock location, sample the rock, move to communications (#q1), send the analysis, drop the rock. This is repeated for both rocks.
               *   Return to starting configuration.
           
           I need to make sure that the rovers finish in their initial configuration and that the store is free, therefore I need the drop_rock and return move at the end. I also need to make sure the preconditions are met for each action at all times.
           
           Since `free` is necessary for the goal axiom and my plan has to be executable, I will ensure that the analysis is sent, then the rock is dropped. The `atconf` requirements are taken care of by ensuring there is a return action at the end of each plan.
           
           With these steps, and their associated checks, I should be able to complete all the objectives and meet all the preconditions necessary to achieve `new-axiom@0()`. This plan utilizes the available facts in the domain.
           

