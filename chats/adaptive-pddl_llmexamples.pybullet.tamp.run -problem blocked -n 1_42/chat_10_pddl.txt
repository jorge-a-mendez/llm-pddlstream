User:      Here is a list of objects present in this scene for this task: 
           
           ```
           #o0: object
           #o1: object
           #o2: object
           #o3: object
           #o4: object
           #q2: object
           #q3: object
           #q4: object
           #t10: object
           #t5: object
           #t6: object
           #t7: object
           #t8: object
           v10: object
           v11: object
           v12: object
           v13: object
           v14: object
           v15: object
           v16: object
           v17: object
           v18: object
           v19: object
           v20: object
           v21: object
           v22: object
           v23: object
           v24: object
           v25: object
           v26: object
           v27: object
           v28: object
           v29: object
           v3: object
           v30: object
           v31: object
           v32: object
           v33: object
           v34: object
           v35: object
           v4: object
           v5: object
           v6: object
           v7: object
           v8: object
           v9: object
           ```
           
           The initial state is given by the following facts: 
           
           ```
           Atom aconf(v4, v5)
           Atom pose(v8, v9)
           Atom supported(v8, v9, v11)
           Atom ~test-cfree-traj-pose-negative(v30, v15, v16)
           Atom supported(v15, v16, v11)
           Atom stackable(v15, v10)
           Atom graspable(v8)
           Atom canmove()
           Atom arm(v6)
           Atom stackable(v8, v18)
           Atom bconf(v3)
           Atom arm(v4)
           Atom controllable(v4)
           Atom stackable(v8, v10)
           Atom type(v12, v17)
           Atom ataconf(v4, v5)
           Atom atpose(v12, v13)
           Atom graspable(v12)
           Atom pose(v15, v16)
           Atom graspable(v15)
           Atom stackable(v12, v10)
           Atom handempty(v4)
           Atom atpose(v8, v9)
           Atom type(v8, v17)
           Atom ~test-cfree-approach-pose-negative(v8, v9, v22, v15, v16)
           Atom aconf(v6, v7)
           Atom pose(v12, v13)
           Atom atbconf(v3)
           Atom supported(v12, v13, v14)
           Atom atpose(v15, v16)
           Atom stackable(v12, v18)
           Atom ataconf(v6, v7)
           Atom handempty(v6)
           Atom pose(v12, #o2)
           Atom supported(v12, #o2, v18)
           Atom supported(v12, #o2, v10)
           Atom grasp(v15, #o1)
           Atom btraj(#o0)
           Atom basemotion(v3, #o0, v3)
           Atom grasp(v12, #o1)
           Atom pose(v8, v35)
           Atom supported(v8, v35, v18)
           Atom pose(v8, v28)
           Atom supported(v8, v28, v18)
           Atom pose(v8, v19)
           Atom supported(v8, v19, v18)
           Atom pose(v8, #o2)
           Atom supported(v8, #o2, v10)
           Atom grasp(v8, v20)
           Atom grasp(v8, v22)
           Atom grasp(v8, v23)
           Atom grasp(v8, v21)
           Atom pose(v15, #o2)
           Atom supported(v15, #o2, v10)
           Atom bconf(#q4)
           Atom atraj(#t8)
           Atom kin(v4, v8, v28, v22, #q4, #t8)
           Atom bconf(#q2)
           Atom atraj(#t5)
           Atom kin(v4, v8, v9, v22, #q2, #t5)
           Atom bconf(#q3)
           Atom atraj(#t7)
           Atom kin(v4, v8, v19, v22, #q3, #t7)
           Atom bconf(v33)
           Atom atraj(v34)
           Atom kin(v4, v8, v28, v21, v33, v34)
           Atom bconf(v31)
           Atom atraj(v32)
           Atom kin(v4, v8, v28, v23, v31, v32)
           Atom bconf(v26)
           Atom atraj(v27)
           Atom kin(v4, v8, v19, v23, v26, v27)
           Atom basemotion(v26, #o0, v3)
           Atom basemotion(v26, #o0, v26)
           Atom basemotion(v3, #o0, v26)
           Atom bconf(v29)
           Atom atraj(v30)
           Atom kin(v4, v8, v28, v20, v29, v30)
           Atom bconf(v24)
           Atom atraj(v25)
           Atom kin(v4, v8, v19, v20, v24, v25)
           Atom basemotion(v24, #o0, v3)
           Atom basemotion(v3, #o0, v24)
           Atom basemotion(v24, #o0, v24)
           Atom basemotion(v26, #o0, v24)
           Atom basemotion(v24, #o0, v26)
           Atom basemotion(#q3, #o0, #q3)
           Atom basemotion(v26, #o0, #q3)
           Atom basemotion(#q3, #o0, v3)
           Atom basemotion(#q3, #o0, v24)
           Atom basemotion(#q3, #o0, v26)
           Atom basemotion(v3, #o0, #q3)
           Atom basemotion(v24, #o0, #q3)
           Atom basemotion(#q2, #o0, v3)
           Atom basemotion(#q2, #o0, v24)
           Atom basemotion(#q2, #o0, v26)
           Atom btraj(#t10)
           Atom basemotion(#q2, #t10, #q3)
           Atom btraj(#t6)
           Atom basemotion(v3, #t6, #q2)
           Atom basemotion(#q2, #o0, #q2)
           Atom basemotion(v24, #o0, #q2)
           Atom basemotion(v26, #o0, #q2)
           Atom basemotion(#q3, #o0, #q2)
           Atom bconf(#o3)
           Atom atraj(#o4)
           Atom kin(v4, v8, #o2, v21, #o3, #o4)
           Atom kin(v4, v8, #o2, v20, #o3, #o4)
           Atom kin(v4, v8, #o2, v23, #o3, #o4)
           Atom kin(v4, v8, #o2, v22, #o3, #o4)
           Atom kin(v4, v15, v16, #o1, #o3, #o4)
           Atom kin(v4, v15, #o2, #o1, #o3, #o4)
           Atom kin(v4, v12, #o2, #o1, #o3, #o4)
           Atom kin(v4, v12, v13, #o1, #o3, #o4)
           Atom basemotion(#o3, #o0, v3)
           Atom basemotion(#o3, #o0, v24)
           Atom basemotion(#q3, #o0, #o3)
           Atom basemotion(#o3, #o0, #q2)
           Atom basemotion(#o3, #o0, v26)
           Atom basemotion(#o3, #o0, #q3)
           Atom basemotion(v3, #o0, #o3)
           Atom basemotion(#q2, #o0, #o3)
           Atom basemotion(v24, #o0, #o3)
           Atom basemotion(v26, #o0, #o3)
           Atom basemotion(#o3, #o0, #o3)
           ```
           
           The goal expression is `Atom new-axiom@0()`. Given these elements, the list of available action instances is:
           
           ```
           ((move_base #o3 #o3 #o0))
           ((move_base #o3 #q2 #o0))
           ((move_base #o3 #q3 #o0))
           ((move_base #o3 v24 #o0))
           ((move_base #o3 v26 #o0))
           ((move_base #o3 v3 #o0))
           ((move_base #q2 #o3 #o0))
           ((move_base #q2 #q2 #o0))
           ((move_base #q2 v24 #o0))
           ((move_base #q2 v26 #o0))
           ((move_base #q2 v3 #o0))
           ((move_base #q2 #q3 #t10))
           ((move_base #q3 #o3 #o0))
           ((move_base #q3 #q2 #o0))
           ((move_base #q3 #q3 #o0))
           ((move_base #q3 v24 #o0))
           ((move_base #q3 v26 #o0))
           ((move_base #q3 v3 #o0))
           ((move_base v24 #o3 #o0))
           ((move_base v24 #q2 #o0))
           ((move_base v24 #q3 #o0))
           ((move_base v24 v24 #o0))
           ((move_base v24 v26 #o0))
           ((move_base v24 v3 #o0))
           ((move_base v26 #o3 #o0))
           ((move_base v26 #q2 #o0))
           ((move_base v26 #q3 #o0))
           ((move_base v26 v24 #o0))
           ((move_base v26 v26 #o0))
           ((move_base v26 v3 #o0))
           ((move_base v3 #o3 #o0))
           ((move_base v3 #q3 #o0))
           ((move_base v3 v24 #o0))
           ((move_base v3 v26 #o0))
           ((move_base v3 v3 #o0))
           ((move_base v3 #q2 #t6))
           ((pick v4 v12 #o2 #o1 #o3 #o4))
           ((place v4 v12 #o2 #o1 #o3 #o4))
           ((pick v4 v12 v13 #o1 #o3 #o4))
           ((place v4 v12 v13 #o1 #o3 #o4))
           ((pick v4 v15 #o2 #o1 #o3 #o4))
           ((place v4 v15 #o2 #o1 #o3 #o4))
           ((pick v4 v15 v16 #o1 #o3 #o4))
           ((place v4 v15 v16 #o1 #o3 #o4))
           ((pick v4 v8 #o2 v20 #o3 #o4))
           ((place v4 v8 #o2 v20 #o3 #o4))
           ((pick v4 v8 #o2 v21 #o3 #o4))
           ((place v4 v8 #o2 v21 #o3 #o4))
           ((pick v4 v8 #o2 v22 #o3 #o4))
           ((place v4 v8 #o2 v22 #o3 #o4))
           ((pick v4 v8 #o2 v23 #o3 #o4))
           ((place v4 v8 #o2 v23 #o3 #o4))
           ((pick v4 v8 v19 v20 v24 v25))
           ((place v4 v8 v19 v20 v24 v25))
           ((pick v4 v8 v19 v22 #q3 #t7))
           ((place v4 v8 v19 v22 #q3 #t7))
           ((pick v4 v8 v19 v23 v26 v27))
           ((place v4 v8 v19 v23 v26 v27))
           ((pick v4 v8 v9 v22 #q2 #t5))
           ((place v4 v8 v9 v22 #q2 #t5))
           ```
           
           Please provide a plan that achieves the goal from the initial state.

Model:     The goal is `(on ?green v18)`. The object `v8` is `green`, so we need to achieve `on(v8, v18)`. Currently, `v8` is at `v9` and supported by `v11`. We need to pick up `v8` from `v9` and place it on `v18`.
           
           There are several poses for `v8` supported by `v18`: `v35`, `v28`, `v19`, and `#o2`. I'll pick `v28` as the target pose to place `v8` on `v18`.
           
           The current state has `v8` at `atpose(v8, v9)` and `handempty(v4)`.
           To achieve `on(v8, v18)`, we need to place `v8` at a pose that is supported by `v18`.
           From the initial state, we know that `supported(v8, v35, v18)`, `supported(v8, v28, v18)`, `supported(v8, v19, v18)`, and `supported(v8, #o2, v10)`. Let's choose `v28` as the pose on `v18`.
           
           First, we need to pick `v8` from `v9`. We have the action `(pick v4 v8 v9 v22 #q2 #t5)`. This requires the robot to be at `atbconf(#q2)`. Currently, the robot is at `atbconf(v3)`. So, we need to move the base from `v3` to `#q2`. We have `(move_base v3 #q2 #t6)`.
           
           After picking `v8`, `v4` will be holding `v8`. Then, we need to place `v8` at `v28` with grasp `v22` (matching the pick grasp). The `kin` predicate `kin(v4, v8, v28, v22, #q4, #t8)` tells us we need to be at `atbconf(#q4)`. So, we need to move the base from `#q2` to `#q4`. We have `(move_base #q2 #q3 #t10)` but no direct path from `#q2` to `#q4`. We can use `(move_base #q2 v3 #o0)` then `(move_base v3 #q4 #o0)` but `v3` to `#q4` is not allowed. Instead, we can try to move to `#q3` using `(move_base #q2 #q3 #t10)` then from `#q3` to `#q4` (not allowed). It seems `v3` is the only base config we can reliably go from or to. Let's look for a valid kin to place v8 on v18 that shares a base configuration with one we can reach.
           
           Let's re-evaluate the target pose for `v8` and the available kin facts.
           We want to achieve `on(v8, v18)`. This means we need to place `v8` at a pose `?p` such that `supported(v8, ?p, v18)` is true.
           Valid `(pose v8 ?p)` such that `(supported v8 ?p v18)` are `v35`, `v28`, and `v19`.
           
           Let's consider available `kin` actions for `v8`:
           - `kin(v4, v8, v28, v22, #q4, #t8)`: place at `v28` requires `atbconf(#q4)`.
           - `kin(v4, v8, v19, v22, #q3, #t7)`: place at `v19` requires `atbconf(#q3)`.
           - `kin(v4, v8, v28, v21, v33, v34)`: place at `v28` requires `atbconf(v33)`.
           - `kin(v4, v8, v28, v23, v31, v32)`: place at `v28` requires `atbconf(v31)`.
           - `kin(v4, v8, v28, v20, v29, v30)`: place at `v28` requires `atbconf(v29)`.
           - `kin(v4, v8, v19, v23, v26, v27)`: place at `v19` requires `atbconf(v26)`.
           - `kin(v4, v8, v19, v20, v24, v25)`: place at `v19` requires `atbconf(v24)`.
           - `kin(v4, v8, #o2, v21, #o3, #o4)`: place at `#o2` supported by `v10`. This is not on `v18`.
           
           Let's pick from `v9` with grasp `v22`, which leads to `atbconf(#q2)`.
           `pick v4 v8 v9 v22 #q2 #t5`
           Preconditions:
               `kin(v4, v8, v9, v22, #q2, #t5)` (True)
               `atpose(v8, v9)` (True)
               `handempty(v4)` (True)
               `atbconf(#q2)` (False, currently `v3`)
               `~unsafeapproach(v8, v9, v22)` (True)
               `~unsafeatraj(#t5)` (True)
           
           So, first `(move_base v3 #q2 #t6)` to get to `atbconf(#q2)`.
           Then `(pick v4 v8 v9 v22 #q2 #t5)`. Now `holding(v4, v8)`.
           
           After picking, we need to place. Let's look for a place action that uses `grasp v22` (to avoid regrabbing) and places `v8` on `v18`.
           - `place v4 v8 v28 v22 #q4 #t8` (Requires `atbconf(#q4)`).
           
           So, the plan would be:
           1. `(move_base v3 #q2 #t6)`
           2. `(pick v4 v8 v9 v22 #q2 #t5)`
           3. Now we are at `atbconf(#q2)` and need to go to `atbconf(#q4)`. Looking at `basemotion` facts, we don't have a direct `(#q2, #q4)` or `(#q4, #q2)`.
           However, we have `basemotion(#q2, #q3, #t10)`. And from `#q3` we have `basemotion(#q3, v3, #o0)`. And then from `v3` we can move to `#q4`? No.
           There's `basemotion(#q3, #o0, #q3)`, `basemotion(#q3, #o0, v24)`, `basemotion(#q3, #o0, v26)`, `basemotion(#q3, #o0, v3)`, `basemotion(#q3, #o0, #q2)`.
           And from `v3` we have `basemotion(v3, #o0, #q3)` (which means we could reach #q3 again) but no way to #q4.
           
           This means we cannot reach `#q4` from `#q2`. Let's reconsider.
           
           The available `kin` actions to place `v8` that result in `on(v8, v18)` are limited by the base configurations they require.
           Let's look at what base configurations we can actually reach from `v3` (initial `atbconf`).
           We can reach:
           - `#q2` via `(move_base v3 #q2 #t6)`
           - `v24` via `(move_base v3 v24 #o0)`
           - `v26` via `(move_base v3 v26 #o0)`
           - `#q3` via `(move_base v3 #q3 #o0)`
           - `v3` via `(move_base v3 v3 #o0)`
           
           Now, let's look for `kin` for placing `v8` on `v18` that use one of these reachable base configurations:
           - `kin(v4, v8, v19, v22, #q3, #t7)`: uses `#q3`. We can reach `#q3` from `v3`.
           - `kin(v4, v8, v19, v23, v26, v27)`: uses `v26`. We can reach `v26` from `v3`.
           - `kin(v4, v8, v19, v20, v24, v25)`: uses `v24`. We can reach `v24` from `v3`.
           
           Let's try placing `v8` at `v19` (which is supported by `v18`) using `grasp v22`. This requires `atbconf(#q3)`.
           So, the revised plan:
           1. Move to `#q2` to pick `v8` from `v9` using `grasp v22`.
              `(move_base v3 #q2 #t6)`
           2. Pick `v8`.
              `(pick v4 v8 v9 v22 #q2 #t5)`
           3. Move to `#q3` to place `v8` at `v19`.
              We are at `#q2`. Can we go from `#q2` to `#q3`? Yes, `(move_base #q2 #q3 #t10)`.
              `(move_base #q2 #q3 #t10)`
           4. Place `v8`.
              `(place v4 v8 v19 v22 #q3 #t7)`
           
           Let's check preconditions for each step:
           1. `(move_base v3 #q2 #t6)`:
              `basemotion(v3, #t6, #q2)` (True)
              `atbconf(v3)` (True)
              `canmove()` (True)
              Effects: `atbconf(#q2)`, `~atbconf(v3)`, `~canmove()`
              This looks valid.
           
           2. `(pick v4 v8 v9 v22 #q2 #t5)`:
              `kin(v4, v8, v9, v22, #q2, #t5)` (True)
              `atpose(v8, v9)` (True)
              `handempty(v4)` (True)
              `atbconf(#q2)` (True, from previous action)
              `~unsafeapproach(v8, v9, v22)` (True)
              `~unsafeatraj(#t5)` (True)
              Effects: `atgrasp(v4, v8, v22)`, `canmove()`, `~atpose(v8, v9)`, `~handempty(v4)`
              This looks valid.
           
           3. `(move_base #q2 #q3 #t10)`:
              `basemotion(#q2, #t10, #q3)` (True)
              `atbconf(#q2)` (True, from previous action)
              `canmove()` (True, from previous action)
              Effects: `atbconf(#q3)`, `~atbconf(#q2)`, `~canmove()`
              This looks valid.
           
           4. `(place v4 v8 v19 v22 #q3 #t7)`:
              `kin(v4, v8, v19, v22, #q3, #t7)` (True)
              `atgrasp(v4, v8, v22)` (True, from pick action)
              `atbconf(#q3)` (True, from previous action)
              `~unsafepose(v8, v19)` (Need to check this. Assuming true as no contradicting facts are given for v19)
              `~unsafeapproach(v8, v19, v22)` (Need to check this. Assuming true)
              `~unsafeatraj(#t7)` (Need to check this. Assuming true as no contradicting facts are given)
              Effects: `atpose(v8, v19)`, `handempty(v4)`, `canmove()`, `~atgrasp(v4, v8, v22)`
              This looks valid.
           
           After these actions, `atpose(v8, v19)` will be true. Since `supported(v8, v19, v18)` is true, the axiom `on(v8, v18)` will be true, which satisfies the goal `new-axiom@0()` (since `new-axiom@0()` implies `on(?green, v18)` and `type(?green, v17)` and `v8` is `green` and `type(v8, v17)`).
           
           --Plan--:
           (move_base v3 #q2 #t6)
           (pick v4 v8 v9 v22 #q2 #t5)
           (move_base #q2 #q3 #t10)
           (place v4 v8 v19 v22 #q3 #t7)

