User:      Here is a list of objects present in this scene for this task: 
           
           ```
           #o0: object
           #o1: object
           #o2: object
           #o3: object
           #o4: object
           #o5: object
           v1: object
           v10: object
           v11: object
           v12: object
           v13: object
           v14: object
           v15: object
           v16: object
           v17: object
           v18: object
           v19: object
           v2: object
           v20: object
           v3: object
           v4: object
           v5: object
           v6: object
           v7: object
           v8: object
           v9: object
           ```
           
           The initial state is given by the following facts: 
           
           ```
           Atom atconf(v14, v15)
           Atom objective(v17)
           Atom conf(v12, v13)
           Atom objective(v19)
           Atom rock(v5)
           Atom type(v8, v6)
           Atom type(v3, v2)
           Atom store(v16)
           Atom supports(v10, v11)
           Atom type(v5, v6)
           Atom rock(v1)
           Atom type(v4, v2)
           Atom onboard(v10, v14)
           Atom camera(v10)
           Atom rock(v3)
           Atom free(v12, v16)
           Atom free(v14, v16)
           Atom type(v1, v2)
           Atom mode(v11)
           Atom objective(v18)
           Atom lander(v9)
           Atom conf(v14, v15)
           Atom rock(v8)
           Atom rover(v12)
           Atom atconf(v12, v13)
           Atom onboard(v10, v12)
           Atom rock(v7)
           Atom rover(v14)
           Atom type(v7, v6)
           Atom objective(v20)
           Atom rock(v4)
           Atom above(v14, #o5, v4)
           Atom conf(v14, #o5)
           Atom imagevisible(v14, #o3, #o4, v20)
           Atom imagerange(v14, #o3, v20)
           Atom conf(v14, #o3)
           Atom ray(#o4)
           Atom imagevisible(v14, #o3, #o4, v17)
           Atom imagerange(v14, #o3, v17)
           Atom above(v14, #o5, v7)
           Atom imagevisible(v12, #o3, #o4, v20)
           Atom imagerange(v12, #o3, v20)
           Atom conf(v12, #o3)
           Atom imagevisible(v12, #o3, #o4, v17)
           Atom imagerange(v12, #o3, v17)
           Atom above(v12, #o5, v7)
           Atom conf(v12, #o5)
           Atom above(v12, #o5, v4)
           Atom above(v12, #o5, v5)
           Atom above(v14, #o5, v5)
           Atom above(v12, #o5, v1)
           Atom above(v14, #o5, v1)
           Atom above(v12, #o5, v8)
           Atom above(v14, #o5, v8)
           Atom imagevisible(v14, #o3, #o4, v19)
           Atom imagerange(v14, #o3, v19)
           Atom imagevisible(v12, #o3, #o4, v19)
           Atom imagerange(v12, #o3, v19)
           Atom motion(v14, v15, #o2, v15)
           Atom comvisible(v14, #o0, #o1, v9)
           Atom comrange(v14, #o0, v9)
           Atom conf(v14, #o0)
           Atom ray(#o1)
           Atom comvisible(v12, #o0, #o1, v9)
           Atom comrange(v12, #o0, v9)
           Atom conf(v12, #o0)
           Atom imagevisible(v14, #o3, #o4, v18)
           Atom imagerange(v14, #o3, v18)
           Atom imagevisible(v12, #o3, #o4, v18)
           Atom imagerange(v12, #o3, v18)
           Atom motion(v12, v13, #o2, v13)
           Atom above(v14, #o5, v3)
           Atom above(v12, #o5, v3)
           Atom motion(v14, #o0, #o2, v15)
           Atom motion(v14, #o0, #o2, #o0)
           Atom motion(v14, v15, #o2, #o0)
           Atom motion(v14, #o3, #o2, #o0)
           Atom motion(v14, #o0, #o2, #o3)
           Atom motion(v14, #o3, #o2, v15)
           Atom motion(v14, v15, #o2, #o3)
           Atom motion(v14, #o3, #o2, #o3)
           Atom motion(v14, #o5, #o2, #o5)
           Atom motion(v14, v15, #o2, #o5)
           Atom motion(v14, #o5, #o2, #o3)
           Atom motion(v14, #o3, #o2, #o5)
           Atom motion(v14, #o5, #o2, v15)
           Atom motion(v14, #o5, #o2, #o0)
           Atom motion(v14, #o0, #o2, #o5)
           Atom motion(v12, #o3, #o2, v13)
           Atom motion(v12, v13, #o2, #o3)
           Atom motion(v12, #o3, #o2, #o3)
           Atom motion(v12, #o5, #o2, #o3)
           Atom motion(v12, v13, #o2, #o5)
           Atom motion(v12, #o5, #o2, #o5)
           Atom motion(v12, #o3, #o2, #o5)
           Atom motion(v12, #o5, #o2, v13)
           Atom motion(v12, #o3, #o2, #o0)
           Atom motion(v12, #o0, #o2, #o5)
           Atom motion(v12, v13, #o2, #o0)
           Atom motion(v12, #o0, #o2, #o3)
           Atom motion(v12, #o0, #o2, v13)
           Atom motion(v12, #o0, #o2, #o0)
           Atom motion(v12, #o5, #o2, #o0)
           ```
           
           The goal expression is `Atom new-axiom@0()`. Given these elements, the list of available action instances is:
           
           ```
           ((sample_rock v12 #o5 v1 v16))
           ((sample_rock v12 #o5 v3 v16))
           ((sample_rock v12 #o5 v4 v16))
           ((sample_rock v12 #o5 v5 v16))
           ((sample_rock v12 #o5 v7 v16))
           ((sample_rock v12 #o5 v8 v16))
           ((sample_rock v14 #o5 v1 v16))
           ((sample_rock v14 #o5 v3 v16))
           ((sample_rock v14 #o5 v4 v16))
           ((sample_rock v14 #o5 v5 v16))
           ((sample_rock v14 #o5 v7 v16))
           ((sample_rock v14 #o5 v8 v16))
           ((move v12 #o0 #o2 #o0))
           ((move v12 #o0 #o2 #o3))
           ((move v12 #o0 #o2 #o5))
           ((move v12 #o0 #o2 v13))
           ((move v12 #o3 #o2 #o0))
           ((move v12 #o3 #o2 #o3))
           ((move v12 #o3 #o2 #o5))
           ((move v12 #o3 #o2 v13))
           ((move v12 #o5 #o2 #o0))
           ((move v12 #o5 #o2 #o3))
           ((move v12 #o5 #o2 #o5))
           ((move v12 #o5 #o2 v13))
           ((move v12 v13 #o2 #o0))
           ((move v12 v13 #o2 #o3))
           ((move v12 v13 #o2 #o5))
           ((move v12 v13 #o2 v13))
           ((move v14 #o0 #o2 #o0))
           ((move v14 #o0 #o2 #o3))
           ((move v14 #o0 #o2 #o5))
           ((move v14 #o0 #o2 v15))
           ((move v14 #o3 #o2 #o0))
           ((move v14 #o3 #o2 #o3))
           ((move v14 #o3 #o2 #o5))
           ((move v14 #o3 #o2 v15))
           ((move v14 #o5 #o2 #o0))
           ((move v14 #o5 #o2 #o3))
           ((move v14 #o5 #o2 #o5))
           ((move v14 #o5 #o2 v15))
           ((move v14 v15 #o2 #o0))
           ((move v14 v15 #o2 #o3))
           ((move v14 v15 #o2 #o5))
           ((move v14 v15 #o2 v15))
           ((calibrate v12 #o3 #o4 v17 v10))
           ((calibrate v12 #o3 #o4 v18 v10))
           ((calibrate v12 #o3 #o4 v19 v10))
           ((calibrate v12 #o3 #o4 v20 v10))
           ((calibrate v14 #o3 #o4 v17 v10))
           ((calibrate v14 #o3 #o4 v18 v10))
           ((calibrate v14 #o3 #o4 v19 v10))
           ((calibrate v14 #o3 #o4 v20 v10))
           ((take_image v12 #o3 #o4 v17 v10 v11))
           ((take_image v12 #o3 #o4 v18 v10 v11))
           ((take_image v12 #o3 #o4 v19 v10 v11))
           ((take_image v12 #o3 #o4 v20 v10 v11))
           ((take_image v14 #o3 #o4 v17 v10 v11))
           ((take_image v14 #o3 #o4 v18 v10 v11))
           ((take_image v14 #o3 #o4 v19 v10 v11))
           ((take_image v14 #o3 #o4 v20 v10 v11))
           ((drop_rock v12 v16))
           ((send_analysis v12 #o0 #o1 v9 v1))
           ((send_analysis v12 #o0 #o1 v9 v3))
           ((send_analysis v12 #o0 #o1 v9 v4))
           ((send_analysis v12 #o0 #o1 v9 v5))
           ((send_analysis v12 #o0 #o1 v9 v7))
           ((send_analysis v12 #o0 #o1 v9 v8))
           ((drop_rock v14 v16))
           ((send_analysis v14 #o0 #o1 v9 v1))
           ((send_analysis v14 #o0 #o1 v9 v3))
           ((send_analysis v14 #o0 #o1 v9 v4))
           ((send_analysis v14 #o0 #o1 v9 v5))
           ((send_analysis v14 #o0 #o1 v9 v7))
           ((send_analysis v14 #o0 #o1 v9 v8))
           ((send_image v12 #o0 #o1 v9 v17 v11))
           ((send_image v12 #o0 #o1 v9 v18 v11))
           ((send_image v12 #o0 #o1 v9 v19 v11))
           ((send_image v12 #o0 #o1 v9 v20 v11))
           ((send_image v14 #o0 #o1 v9 v17 v11))
           ((send_image v14 #o0 #o1 v9 v18 v11))
           ((send_image v14 #o0 #o1 v9 v19 v11))
           ((send_image v14 #o0 #o1 v9 v20 v11))
           ```
           
           Please provide a plan that achieves the goal from the initial state.

Model:     The scene contains two rovers (v12 and v14), a lander (v9), a camera (v10), and a storage unit (v16). There are multiple rocks (v1, v3, v4, v5, v7, v8) and objectives (v17, v18, v19, v20). The camera v10 supports the mode v11. Both rovers are at their respective initial configurations (v12 at v13, v14 at v15) and both have free storage (v16). There are various image visibility and communication visibility facts, along with possible motions.
           
           The goal `new-axiom@0()` requires several conditions to be met, including:
           - `atconf(v12, v13)` and `atconf(v14, v15)` (these are already true).
           - `free(v12, v16)` and `free(v14, v16)` (these are already true).
           - `receivedimage(v17, v11)`, `receivedimage(v18, v11)`, `receivedimage(v19, v11)`, `receivedimage(v20, v11)`: This means all four objectives (v17, v18, v19, v20) must have their images taken and sent using mode v11.
           - `type(?stone, v2)` and `receivedanalysis(?stone)`: At least one rock of type v2 (which are v1, v3, v4) must be analyzed and sent.
           - `type(?soil, v6)` and `receivedanalysis(?soil)`: At least one rock of type v6 (which are v5, v7, v8) must be analyzed and sent.
           
           Since both rovers have a camera and access to storage, we can use either to satisfy the analysis goals. Rover v14 is already at a configuration `#o5` where it is above several rocks, making it convenient to sample. Similarly, both rovers are at configurations where they can take images and communicate.
           
           Let's break down the plan:
           1.  **Analyze rocks**:
               *   Sample a rock of type v2 (e.g., v4) using rover v14.
               *   Send the analysis of v4.
               *   Sample a rock of type v6 (e.g., v5) using rover v14.
               *   Send the analysis of v5.
               *   Since only one storage unit is given and it becomes full after one sample, the rover needs to drop the sampled rock if it needs to sample another one, or if another rover is available, that rover can be used. In this case, rover v14 samples v4, sends analysis, then needs to drop v4 to be able to sample v5.
           
           2.  **Take and send images for all objectives**:
               *   Calibrate the camera for rover v14.
               *   Take images of v17, v18, v19, v20 using rover v14.
               *   Send images of v17, v18, v19, v20 using rover v14.
           
           We can optimize by using rover v14 for both tasks as it's at a suitable location (`#o5` for sampling and `#o3` for imaging, and `#o0` for communication). Since rover v14 is at v15 initially, we need to move it to `#o5` for sampling, then `#o3` for imaging, and then `#o0` for communication and sending analysis. However, it seems that there is an existing `above` predicate at `#o5`, `imagevisible` at `#o3`, and `comvisible` at `#o0` for rover v14. The move actions show movement between v15, #o0, #o3, #o5. It's more efficient to move to #o5 for sampling, then #o3 for imaging, and then #o0 for sending both images and analysis.
           
           Let's assume the initial position of v14, v15 is a valid position for moving to other configurations. The initial state has `atconf(v14, v15)`.
           
           To achieve `receivedanalysis(?stone)` for type v2 and v6:
           - Rover v14 is `atconf(v14, v15)`.
           - Move v14 to `#o5` to be above rocks.
           - `sample_rock v14 #o5 v4 v16` (type v2 stone). Now `full(v14, v16)` and `analyzed(v14, v4)`.
           - Move v14 to `#o0` to communicate.
           - `send_analysis v14 #o0 #o1 v9 v4`. Now `receivedanalysis(v4)`.
           - Move v14 back to `#o5`.
           - `drop_rock v14 v16`. Now `free(v14, v16)`.
           - `sample_rock v14 #o5 v5 v16` (type v6 soil). Now `full(v14, v16)` and `analyzed(v14, v5)`.
           - Move v14 back to `#o0`.
           - `send_analysis v14 #o0 #o1 v9 v5`. Now `receivedanalysis(v5)`.
           - `drop_rock v14 v16`. (Optional if no further sampling, but good practice if goal requires `free` state, which it implicitly does for the axiom).
           
           To achieve `receivedimage` for all objectives:
           - Calibrate the camera on rover v14.
           - `calibrate v14 #o3 #o4 v17 v10`.
           - Then take images for v17, v18, v19, v20 and send them.
               - `take_image v14 #o3 #o4 v17 v10 v11`
               - `send_image v14 #o0 #o1 v9 v17 v11`
               - `calibrate v14 #o3 #o4 v18 v10` (camera needs recalibration after each image)
               - `take_image v14 #o3 #o4 v18 v10 v11`
               - `send_image v14 #o0 #o1 v9 v18 v11`
               - `calibrate v14 #o3 #o4 v19 v10`
               - `take_image v14 #o3 #o4 v19 v10 v11`
               - `send_image v14 #o0 #o1 v9 v19 v11`
               - `calibrate v14 #o3 #o4 v20 v10`
               - `take_image v14 #o3 #o4 v20 v10 v11`
               - `send_image v14 #o0 #o1 v9 v20 v11`
           
           Let's arrange these steps in sequence, ensuring current `atconf` matches the required configuration for each action. We can prioritize the objective images as they are 4 items.
           
           Current configuration of v14 is v15.
           
           --Plan--:
           (move v14 v15 #o2 #o3)
           (calibrate v14 #o3 #o4 v17 v10)
           (take_image v14 #o3 #o4 v17 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v17 v11)
           (move v14 #o0 #o2 #o3)
           (calibrate v14 #o3 #o4 v18 v10)
           (take_image v14 #o3 #o4 v18 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v18 v11)
           (move v14 #o0 #o2 #o3)
           (calibrate v14 #o3 #o4 v19 v10)
           (take_image v14 #o3 #o4 v19 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v19 v11)
           (move v14 #o0 #o2 #o3)
           (calibrate v14 #o3 #o4 v20 v10)
           (take_image v14 #o3 #o4 v20 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v20 v11)
           (move v14 #o0 #o2 #o5)
           (sample_rock v14 #o5 v4 v16)
           (move v14 #o5 #o2 #o0)
           (send_analysis v14 #o0 #o1 v9 v4)
           (move v14 #o0 #o2 #o5)
           (drop_rock v14 v16)
           (sample_rock v14 #o5 v5 v16)
           (move v14 #o5 #o2 #o0)
           (send_analysis v14 #o0 #o1 v9 v5)
           (drop_rock v14 v16)

User:      The plan you provided is not valid because: `Fact is not satisfied: Atom new-axiom@0()`. Recall that the action preconditions and the goal *must* be satisfied.
           
           Please provide a plan that achieves the goal from the initial state ensuring that action preconditions are satisfied and adhering to the response format.

Model:     The previous plan failed because the goal `new-axiom@0()` was not satisfied. This means some of the conditions for the axiom were not met. Let's re-evaluate the goal and ensure all components are addressed.
           
           The axiom `new-axiom@0()` requires:
           1.  `atconf(v12, v13)` and `atconf(v14, v15)`: These are true in the initial state and are maintained by moving the rovers between valid configurations.
           2.  `free(v12, v16)` and `free(v14, v16)`: These are true in the initial state. My previous plan involved filling `v14`'s store and then dropping, which would leave `v14, v16` free. `v12, v16` remained free. So these conditions should be met.
           3.  `receivedimage(v17, v11)`, `receivedimage(v18, v11)`, `receivedimage(v19, v11)`, `receivedimage(v20, v11)`: All four objectives must have their images taken and sent.
           4.  `type(?stone, v2)` and `receivedanalysis(?stone)`: At least one rock of type `v2` (stone, which are v1, v3, v4) must be analyzed and sent.
           5.  `type(?soil, v6)` and `receivedanalysis(?soil)`: At least one rock of type `v6` (soil, which are v5, v7, v8) must be analyzed and sent.
           
           The issue could be in how the `calibrate` action and `take_image` actions interact, or perhaps an implicit blocking condition I missed for `send_image` and `send_analysis`. However, the problem statement says `NegatedAtom blocked(?y)` is a precondition, and I'm not seeing any `blocked` atoms in the initial state. So, the rays (`#o4` for image, `#o1` for com) are assumed to be free.
           
           Let's carefully re-plan, ensuring each step's preconditions are met and all aspects of the goal axiom are covered. I will use rover v14 for all operations, as it simplifies tracking the `atconf` state.
           
           **Plan Strategy:**
           1.  Move v14 to a communication configuration (`#o0`). This configuration is also `comvisible`.
           2.  Move v14 to an image-taking configuration (`#o3`).
           3.  Calibrate, take image, and then move to communication configuration to send. Repeat for all 4 objectives.
           4.  Move v14 to a sampling configuration (`#o5`).
           5.  Sample a rock of type `v2`.
           6.  Move v14 to a communication configuration (`#o0`) to send analysis.
           7.  Drop the sampled rock.
           8.  Move v14 to a sampling configuration (`#o5`).
           9.  Sample a rock of type `v6`.
           10. Move v14 to a communication configuration (`#o0`) to send analysis.
           11. Drop the sampled rock.
           
           This sequence ensures all `receivedimage` and `receivedanalysis` predicates are satisfied, and that the `free` predicate for `v16` is restored after each sample to allow the next sample.
           
           **Refined Plan Construction:**
           
           *   **Initial State:** `atconf(v14, v15)`
           *   **Imaging objectives (v17, v18, v19, v20):**
               *   Move v14 to `#o3` to take images.
               *   Calibrate, take image for v17.
               *   Move v14 to `#o0` to send image for v17.
               *   Move v14 to `#o3`.
               *   Calibrate, take image for v18.
               *   Move v14 to `#o0` to send image for v18.
               *   ...and so on for v19 and v20.
           *   **Analyzing rocks (v4 - type v2, v5 - type v6):**
               *   Move v14 to `#o5` to sample.
               *   Sample v4.
               *   Move v14 to `#o0` to send analysis for v4.
               *   Drop v4 to free up the store.
               *   Move v14 to `#o5`.
               *   Sample v5.
               *   Move v14 to `#o0` to send analysis for v5.
               *   Drop v5 to free up the store.
           
           This systematic approach should satisfy all conditions.
           
           --Plan--:
           (move v14 v15 #o2 #o3)
           (calibrate v14 #o3 #o4 v17 v10)
           (take_image v14 #o3 #o4 v17 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v17 v11)
           (move v14 #o0 #o2 #o3)
           (calibrate v14 #o3 #o4 v18 v10)
           (take_image v14 #o3 #o4 v18 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v18 v11)
           (move v14 #o0 #o2 #o3)
           (calibrate v14 #o3 #o4 v19 v10)
           (take_image v14 #o3 #o4 v19 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v19 v11)
           (move v14 #o0 #o2 #o3)
           (calibrate v14 #o3 #o4 v20 v10)
           (take_image v14 #o3 #o4 v20 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v20 v11)
           (move v14 #o0 #o2 #o5)
           (sample_rock v14 #o5 v4 v16)
           (move v14 #o5 #o2 #o0)
           (send_analysis v14 #o0 #o1 v9 v4)
           (drop_rock v14 v16)
           (move v14 #o0 #o2 #o5)
           (sample_rock v14 #o5 v5 v16)
           (move v14 #o5 #o2 #o0)
           (send_analysis v14 #o0 #o1 v9 v5)
           (drop_rock v14 v16)

User:      The plan you provided is not valid because: `Fact is not satisfied: Atom new-axiom@0()`. Recall that the action preconditions and the goal *must* be satisfied.
           
           Please provide a plan that achieves the goal from the initial state ensuring that action preconditions are satisfied and adhering to the response format.

Model:     The previous plan failed again, indicating that `new-axiom@0()` is still not satisfied. Let's re-examine the goal conditions very carefully and the effects of each action, particularly the `calibrate` and `send` actions.
           
           The goal `new-axiom@0()` requires:
           1.  `atconf(v12, v13)` and `atconf(v14, v15)`: `v12` remains at `v13`. `v14` moves around but should end up at `v15`. However, the axiom itself only requires `atconf` to be true at any point, it doesn't specify a final state. Given that `motion` actions allow returning to original configs (e.g., `(move v14 v15 #o2 v15)`), we can ensure this if needed, but it seems these `atconf` are just checks that the rovers exist and are at a known configuration. The current plan leaves `v14` at `#o0` which is not `v15`. This might be the issue for `atconf(v14, v15)`.
           2.  `free(v12, v16)` and `free(v14, v16)`: `v12`'s store `v16` is always free. `v14`'s store `v16` becomes `full` after `sample_rock` and then `free` after `drop_rock`. The plan ensures it's `free` at the end by dropping the last sample.
           3.  `receivedimage(v17, v11)`, `receivedimage(v18, v11)`, `receivedimage(v19, v11)`, `receivedimage(v20, v11)`: This requires successful image taking and sending for all four objectives.
               *   `calibrate` makes `calibrated(?c, ?v)` true.
               *   `take_image` consumes `calibrated(?c, ?v)` by making it false (`NegatedAtom calibrated(?c, ?v)`). So, the camera needs to be calibrated *before each* `take_image` action. My plan correctly includes this.
               *   `send_image` requires `haveimage(?v, ?o, ?m)`. `take_image` provides this.
           4.  `type(?stone, v2)` and `receivedanalysis(?stone)`: Achieved by `sample_rock` and `send_analysis` for a rock of type `v2`.
           5.  `type(?soil, v6)` and `receivedanalysis(?soil)`: Achieved by `sample_rock` and `send_analysis` for a rock of type `v6`.
           
           The most likely culprit for the failure is the `atconf(v14, v15)` predicate not holding true at the end of the plan when the axiom is checked. The axiom explicitly lists `atconf(v14, v15)` as a conjunct. My previous plan ended with `v14` at `#o0`. I need to add a final move to get `v14` back to `v15`.
           
           Let's modify the plan to ensure `v14` returns to `v15` at the end.
           
           --Plan--:
           (move v14 v15 #o2 #o3)
           (calibrate v14 #o3 #o4 v17 v10)
           (take_image v14 #o3 #o4 v17 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v17 v11)
           (move v14 #o0 #o2 #o3)
           (calibrate v14 #o3 #o4 v18 v10)
           (take_image v14 #o3 #o4 v18 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v18 v11)
           (move v14 #o0 #o2 #o3)
           (calibrate v14 #o3 #o4 v19 v10)
           (take_image v14 #o3 #o4 v19 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v19 v11)
           (move v14 #o0 #o2 #o3)
           (calibrate v14 #o3 #o4 v20 v10)
           (take_image v14 #o3 #o4 v20 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v20 v11)
           (move v14 #o0 #o2 #o5)
           (sample_rock v14 #o5 v4 v16)
           (move v14 #o5 #o2 #o0)
           (send_analysis v14 #o0 #o1 v9 v4)
           (drop_rock v14 v16)
           (move v14 #o0 #o2 #o5)
           (sample_rock v14 #o5 v5 v16)
           (move v14 #o5 #o2 #o0)
           (send_analysis v14 #o0 #o1 v9 v5)
           (drop_rock v14 v16)
           (move v14 #o0 #o2 v15)

