User:      Here is a list of objects present in this scene for this task: 
           
           ```
           #o0: object
           #o1: object
           #o2: object
           #o3: object
           #o4: object
           v10: object
           v11: object
           v12: object
           v13: object
           v14: object
           v15: object
           v16: object
           v17: object
           v18: object
           v3: object
           v4: object
           v5: object
           v6: object
           v7: object
           v8: object
           v9: object
           ```
           
           The initial state is given by the following facts: 
           
           ```
           Atom stackable(v12, v10)
           Atom aconf(v6, v7)
           Atom bconf(v3)
           Atom atpose(v12, v13)
           Atom supported(v15, v16, v11)
           Atom arm(v6)
           Atom stackable(v15, v10)
           Atom atpose(v15, v16)
           Atom pose(v12, v13)
           Atom stackable(v8, v10)
           Atom supported(v8, v9, v11)
           Atom stackable(v8, v18)
           Atom graspable(v8)
           Atom ataconf(v6, v7)
           Atom graspable(v12)
           Atom arm(v4)
           Atom handempty(v4)
           Atom type(v12, v17)
           Atom stackable(v12, v18)
           Atom atbconf(v3)
           Atom handempty(v6)
           Atom graspable(v15)
           Atom canmove()
           Atom type(v8, v17)
           Atom supported(v12, v13, v14)
           Atom ataconf(v4, v5)
           Atom controllable(v4)
           Atom pose(v8, v9)
           Atom atpose(v8, v9)
           Atom aconf(v4, v5)
           Atom pose(v15, v16)
           Atom grasp(v8, #o1)
           Atom pose(v8, #o2)
           Atom supported(v8, #o2, v18)
           Atom grasp(v15, #o1)
           Atom pose(v12, #o2)
           Atom supported(v12, #o2, v18)
           Atom supported(v8, #o2, v10)
           Atom supported(v12, #o2, v10)
           Atom grasp(v12, #o1)
           Atom btraj(#o0)
           Atom basemotion(v3, #o0, v3)
           Atom pose(v15, #o2)
           Atom supported(v15, #o2, v10)
           Atom bconf(#o3)
           Atom atraj(#o4)
           Atom kin(v4, v8, v9, #o1, #o3, #o4)
           Atom kin(v4, v8, #o2, #o1, #o3, #o4)
           Atom kin(v4, v15, v16, #o1, #o3, #o4)
           Atom kin(v4, v15, #o2, #o1, #o3, #o4)
           Atom kin(v4, v12, #o2, #o1, #o3, #o4)
           Atom kin(v4, v12, v13, #o1, #o3, #o4)
           ```
           
           The goal expression is `Atom new-axiom@0()`. Given these elements, the list of available action instances is:
           
           ```
           ((move_base v3 v3 #o0))
           ```
           
           Please provide a plan that achieves the goal from the initial state.

Model:     The scene contains several objects, `v12`, `v15`, and `v8`, which are `stackable` and `graspable`. They also have specific `pose`s and are `supported` on different surfaces. The robot has two arms, `v4` and `v6`, both of which are `handempty`. The robot is currently at base configuration `v3` and arm configurations `v5` (for `v4`) and `v7` (for `v6`). The goal `new-axiom@0()` can be satisfied if `on(?green, v18)` and `type(?green, v17)` are true. In our specific context, the object `?green` will correspond to either `v8` or `v12` as they are of `type v17`. The axiom `on(?o, ?r)` is derived from `supported(?o, ?p, ?r)` and `atpose(?o, ?p)`.
           
           Looking at the initial state, we have `type(v8, v17)` and `type(v12, v17)`.
           For `v8`, we have `atpose(v8, v9)` and `supported(v8, v9, v11)`. We also have `supported(v8, #o2, v18)`. If `atpose(v8, #o2)` is true, then `on(v8, v18)` would be true.
           For `v12`, we have `atpose(v12, v13)` and `supported(v12, v13, v14)`. We also have `supported(v12, #o2, v18)`. If `atpose(v12, #o2)` is true, then `on(v12, v18)` would be true.
           
           The goal is to have an object of `type v17` `on v18`.
           Currently, `v8` is `on v11` (since `atpose(v8, v9)` and `supported(v8, v9, v11)`).
           Currently, `v12` is `on v14` (since `atpose(v12, v13)` and `supported(v12, v13, v14)`).
           
           To achieve `on(?green, v18)`, we need to pick up either `v8` or `v12` and place it on `v18` at a pose `#o2` where it is `supported`. We have `kin` facts for placing `v8` and `v12` at `#o2` using arm `v4`.
           
           Let's try to achieve `on(v8, v18)`.
           1. Pick `v8` from `v9` using arm `v4`. We have `kin(v4, v8, v9, #o1, #o3, #o4)`.
           2. Place `v8` at `#o2` (which is on `v18`) using arm `v4`. We have `kin(v4, v8, #o2, #o1, #o3, #o4)` and `supported(v8, #o2, v18)`.
           
           The only available action instance is `(move_base v3 v3 #o0)`. This action doesn't change the state in a way that helps achieve the goal. It only moves the base from `v3` to `v3`. It looks like the necessary `pick` and `place` actions are not available in the given `available action instances` list. Although the initial state provides `kin` predicates that *could* enable pick and place actions, no concrete instances of `pick` or `place` actions are provided in the list of allowed actions. Therefore, it is impossible to move `v8` or `v12` to `v18` to satisfy the goal.
           
           The goal is unreachable because no `pick` or `place` actions are available to move the objects to the desired location `v18`.

