User:      Here is a list of objects present in this scene for this task: 
           
           ```
           #o0: object
           #o1: object
           #o2: object
           #o3: object
           #o4: object
           @sink: object
           @stove: object
           v10: object
           v11: object
           v12: object
           v13: object
           v14: object
           v15: object
           v16: object
           v17: object
           v18: object
           v19: object
           v20: object
           v21: object
           v22: object
           v23: object
           v3: object
           v4: object
           v5: object
           v6: object
           v7: object
           v8: object
           v9: object
           ```
           
           The initial state is given by the following facts: 
           
           ```
           Atom canmove()
           Atom bconf(v3)
           Atom atbconf(v3)
           Atom arm(v4)
           Atom aconf(v4, v5)
           Atom handempty(v4)
           Atom ataconf(v4, v5)
           Atom controllable(v4)
           Atom arm(v6)
           Atom aconf(v6, v7)
           Atom handempty(v6)
           Atom ataconf(v6, v7)
           Atom graspable(v8)
           Atom pose(v8, v9)
           Atom atpose(v8, v9)
           Atom stackable(v8, v10)
           Atom supported(v8, v9, v11)
           Atom graspable(v12)
           Atom pose(v12, v13)
           Atom atpose(v12, v13)
           Atom stackable(v12, v10)
           Atom supported(v12, v13, v14)
           Atom graspable(v15)
           Atom pose(v15, v16)
           Atom atpose(v15, v16)
           Atom stackable(v15, v10)
           Atom supported(v15, v16, v11)
           Atom type(v8, v17)
           Atom type(v12, v17)
           Atom stackable(v12, v18)
           Atom stackable(v8, v18)
           Atom btraj(#o0)
           Atom basemotion(v3, #o0, v3)
           Atom pose(v8, #o2)
           Atom supported(v8, #o2, v18)
           Atom pose(v12, #o2)
           Atom supported(v12, #o2, v18)
           Atom pose(v15, #o2)
           Atom supported(v15, #o2, v10)
           Atom grasp(v15, #o1)
           Atom supported(v12, #o2, v10)
           Atom grasp(v12, #o1)
           Atom supported(v8, #o2, v10)
           Atom grasp(v8, #o1)
           Atom bconf(#o3)
           Atom atraj(#o4)
           Atom kin(v4, v8, v9, #o1, #o3, #o4)
           Atom kin(v4, v8, #o2, #o1, #o3, #o4)
           Atom kin(v4, v12, v13, #o1, #o3, #o4)
           Atom kin(v4, v12, #o2, #o1, #o3, #o4)
           Atom kin(v4, v15, v16, #o1, #o3, #o4)
           Atom kin(v4, v15, #o2, #o1, #o3, #o4)
           Atom basemotion(#o3, #o0, v3)
           Atom basemotion(v3, #o0, #o3)
           Atom basemotion(#o3, #o0, #o3)
           ```
           
           The goal expression is `Atom new-axiom@0()`. Given these elements, the list of available action instances is:
           
           ```
           ((move_base #o3 #o3 #o0))
           ((move_base #o3 v3 #o0))
           ((move_base v3 #o3 #o0))
           ((move_base v3 v3 #o0))
           ((pick v4 v12 #o2 #o1 #o3 #o4))
           ((place v4 v12 #o2 #o1 #o3 #o4))
           ((pick v4 v12 v13 #o1 #o3 #o4))
           ((place v4 v12 v13 #o1 #o3 #o4))
           ((pick v4 v15 #o2 #o1 #o3 #o4))
           ((place v4 v15 #o2 #o1 #o3 #o4))
           ((pick v4 v15 v16 #o1 #o3 #o4))
           ((place v4 v15 v16 #o1 #o3 #o4))
           ((pick v4 v8 #o2 #o1 #o3 #o4))
           ((place v4 v8 #o2 #o1 #o3 #o4))
           ((pick v4 v8 v9 #o1 #o3 #o4))
           ((place v4 v8 v9 #o1 #o3 #o4))
           ```
           
           Please provide a plan that achieves the goal from the initial state.

Model:     The scene describes several graspable and stackable objects (v8, v12, v15) and two arms (v4, v6). The objects are currently at various poses (v9, v13, v16) and supported by different regions (v11, v14, v10). There's a sink and a stove implied by the `type` predicate and the axiom definitions, but not explicitly named in the objects list (they appear as `v10` for stove and `v18` for sink based on the axioms).
           
           The goal is `new-axiom@0()`, which is an axiom that evaluates to true if `on(?green, v18)` and `type(?green, v17)` are true.
           From the initial state, we know `type(v8, v17)`, `type(v12, v17)`.
           The goal states `type(?green, v17)`, which means we need to find an object of type `v17` and place it on `v18`. Objects `v8` and `v12` are of type `v17`. `v18` is the sink, as seen from the axiom.
           So, to satisfy the goal, we need to place either `v8` or `v12` onto `v18`.
           Let's choose `v8`. Currently, `v8` is at `v9` and supported by `v11`. We need to place it on `v18` at pose `#o2`.
           
           The steps will be:
           1. Pick `v8` from its current pose `v9` using arm `v4`.
           2. Place `v8` onto pose `#o2` on `v18` using arm `v4`.
           
           Let's check the available actions:
           - `(pick v4 v8 v9 #o1 #o3 #o4)`: This action is available and matches our first step.
             - Preconditions:
               - `kin(v4, v8, v9, #o1, #o3, #o4)`: True (given).
               - `atpose(v8, v9)`: True (given).
               - `handempty(v4)`: True (given).
               - `atbconf(#o3)`: Needs to be achieved. Currently `atbconf(v3)`.
               - `~unsafeapproach(v8, v9, #o1)`: Assumed to be false as it's not present in the initial state and no information to infer it.
               - `~unsafeatraj(#o4)`: Assumed to be false.
           - `(place v4 v8 #o2 #o1 #o3 #o4)`: This action is available and matches our second step.
             - Preconditions:
               - `kin(v4, v8, #o2, #o1, #o3, #o4)`: True (given).
               - `atgrasp(v4, v8, #o1)`: Will be true after pick.
               - `atbconf(#o3)`: Needs to be achieved.
               - `~unsafepose(v8, #o2)`: Assumed to be false.
               - `~unsafeapproach(v8, #o2, #o1)`: Assumed to be false.
               - `~unsafeatraj(#o4)`: Assumed to be false.
           
           Both `pick` and `place` actions require `atbconf(#o3)`. We are currently at `atbconf(v3)`. We have the action `(move_base v3 #o3 #o0)`. This should be the first action.
           - `(move_base v3 #o3 #o0)`:
             - Preconditions:
               - `basemotion(v3, #o0, #o3)`: True (given).
               - `atbconf(v3)`: True (given).
               - `canmove()`: True (given).
             - Effects: `atbconf(#o3)`, `~atbconf(v3)`, `~canmove()`.
           
           The plan order will be:
           1. `move_base v3 #o3 #o0` (to set `atbconf(#o3)`)
           2. `pick v4 v8 v9 #o1 #o3 #o4`
           3. `place v4 v8 #o2 #o1 #o3 #o4`
           
           Let's trace the state changes:
           Initial State: `atbconf(v3)`, `canmove()`, `handempty(v4)`, `atpose(v8, v9)`.
           
           1. `(move_base v3 #o3 #o0)`:
              - Preconditions are met.
              - Effects: `atbconf(#o3)`, `~atbconf(v3)`, `~canmove()`.
              - State after: `atbconf(#o3)`, `handempty(v4)`, `atpose(v8, v9)`. `canmove()` is false.
           
           2. `(pick v4 v8 v9 #o1 #o3 #o4)`:
              - Preconditions:
                - `kin(v4, v8, v9, #o1, #o3, #o4)` (given)
                - `atpose(v8, v9)` (true from initial state, not negated by `move_base`)
                - `handempty(v4)` (true from initial state, not negated by `move_base`)
                - `atbconf(#o3)` (true from `move_base`)
                - No unsafe conditions (assumed).
              - Effects: `atgrasp(v4, v8, #o1)`, `canmove()`, `~atpose(v8, v9)`, `~handempty(v4)`.
              - State after: `atbconf(#o3)`, `atgrasp(v4, v8, #o1)`, `canmove()`. `atpose(v8, v9)` and `handempty(v4)` are false.
           
           3. `(place v4 v8 #o2 #o1 #o3 #o4)`:
              - Preconditions:
                - `kin(v4, v8, #o2, #o1, #o3, #o4)` (given)
                - `atgrasp(v4, v8, #o1)` (true from `pick`)
                - `atbconf(#o3)` (true from `move_base`)
                - No unsafe conditions (assumed).
              - Effects: `atpose(v8, #o2)`, `handempty(v4)`, `canmove()`, `~atgrasp(v4, v8, #o1)`.
              - State after: `atbconf(#o3)`, `atpose(v8, #o2)`, `handempty(v4)`, `canmove()`. `atgrasp(v4, v8, #o1)` is false.
           
           After these actions, we have `atpose(v8, #o2)`. Since `supported(v8, #o2, v18)` is given, this implies `on(v8, v18)`. We also know `type(v8, v17)`. These two facts satisfy the goal `new-axiom@0()`.
           
           --Plan--:
           (move_base v3 #o3 #o0)
           (pick v4 v8 v9 #o1 #o3 #o4)
           (place v4 v8 #o2 #o1 #o3 #o4)

