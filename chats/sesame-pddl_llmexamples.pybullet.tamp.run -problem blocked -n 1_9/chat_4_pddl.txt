User:      Here is a list of objects present in this scene for this task: 
           
           ```
           #g1: object
           #o0: object
           #o1: object
           #o2: object
           #o3: object
           #o4: object
           #p1: object
           #q2: object
           #q3: object
           #t4: object
           #t5: object
           #t6: object
           @sink: object
           @stove: object
           v10: object
           v11: object
           v12: object
           v13: object
           v14: object
           v15: object
           v16: object
           v17: object
           v18: object
           v19: object
           v20: object
           v21: object
           v22: object
           v23: object
           v3: object
           v4: object
           v5: object
           v6: object
           v7: object
           v8: object
           v9: object
           ```
           
           The initial state is given by the following facts: 
           
           ```
           Atom canmove()
           Atom bconf(v3)
           Atom atbconf(v3)
           Atom arm(v4)
           Atom aconf(v4, v5)
           Atom handempty(v4)
           Atom ataconf(v4, v5)
           Atom controllable(v4)
           Atom arm(v6)
           Atom aconf(v6, v7)
           Atom handempty(v6)
           Atom ataconf(v6, v7)
           Atom graspable(v8)
           Atom pose(v8, v9)
           Atom atpose(v8, v9)
           Atom stackable(v8, v10)
           Atom supported(v8, v9, v11)
           Atom graspable(v12)
           Atom pose(v12, v13)
           Atom atpose(v12, v13)
           Atom stackable(v12, v10)
           Atom supported(v12, v13, v14)
           Atom graspable(v15)
           Atom pose(v15, v16)
           Atom atpose(v15, v16)
           Atom stackable(v15, v10)
           Atom supported(v15, v16, v11)
           Atom type(v8, v17)
           Atom type(v12, v17)
           Atom stackable(v12, v18)
           Atom stackable(v8, v18)
           Atom btraj(#o0)
           Atom basemotion(v3, #o0, v3)
           Atom pose(v8, #p1)
           Atom supported(v8, #p1, v18)
           Atom pose(v12, #o2)
           Atom supported(v12, #o2, v18)
           Atom pose(v15, #o2)
           Atom supported(v15, #o2, v10)
           Atom grasp(v15, #o1)
           Atom supported(v12, #o2, v10)
           Atom grasp(v12, #o1)
           Atom pose(v8, #o2)
           Atom supported(v8, #o2, v10)
           Atom grasp(v8, #g1)
           Atom bconf(#q2)
           Atom atraj(#t4)
           Atom kin(v4, v8, v9, #g1, #q2, #t4)
           Atom bconf(#q3)
           Atom atraj(#t6)
           Atom kin(v4, v8, #p1, #g1, #q3, #t6)
           Atom basemotion(#q2, #o0, v3)
           Atom basemotion(#q2, #o0, #q2)
           Atom btraj(#t5)
           Atom basemotion(v3, #t5, #q2)
           Atom basemotion(#q3, #o0, #q2)
           Atom basemotion(#q3, #o0, v3)
           Atom basemotion(#q2, #o0, #q3)
           Atom basemotion(v3, #o0, #q3)
           Atom basemotion(#q3, #o0, #q3)
           Atom bconf(#o3)
           Atom atraj(#o4)
           Atom kin(v4, v8, #o2, #g1, #o3, #o4)
           Atom kin(v4, v15, v16, #o1, #o3, #o4)
           Atom kin(v4, v12, v13, #o1, #o3, #o4)
           Atom kin(v4, v12, #o2, #o1, #o3, #o4)
           Atom kin(v4, v15, #o2, #o1, #o3, #o4)
           Atom basemotion(#o3, #o0, #q2)
           Atom basemotion(#o3, #o0, v3)
           Atom basemotion(#o3, #o0, #o3)
           Atom basemotion(#q2, #o0, #o3)
           Atom basemotion(v3, #o0, #o3)
           Atom basemotion(#q3, #o0, #o3)
           Atom basemotion(#o3, #o0, #q3)
           ```
           
           The goal expression is `Atom new-axiom@0()`. Given these elements, the list of available action instances is:
           
           ```
           ((move_base #o3 #o3 #o0))
           ((move_base #o3 #q2 #o0))
           ((move_base #o3 #q3 #o0))
           ((move_base #o3 v3 #o0))
           ((move_base #q2 #o3 #o0))
           ((move_base #q2 #q2 #o0))
           ((move_base #q2 #q3 #o0))
           ((move_base #q2 v3 #o0))
           ((move_base #q3 #o3 #o0))
           ((move_base #q3 #q2 #o0))
           ((move_base #q3 #q3 #o0))
           ((move_base #q3 v3 #o0))
           ((move_base v3 #o3 #o0))
           ((move_base v3 #q3 #o0))
           ((move_base v3 v3 #o0))
           ((move_base v3 #q2 #t5))
           ((pick v4 v12 #o2 #o1 #o3 #o4))
           ((place v4 v12 #o2 #o1 #o3 #o4))
           ((pick v4 v12 v13 #o1 #o3 #o4))
           ((place v4 v12 v13 #o1 #o3 #o4))
           ((pick v4 v15 #o2 #o1 #o3 #o4))
           ((place v4 v15 #o2 #o1 #o3 #o4))
           ((pick v4 v15 v16 #o1 #o3 #o4))
           ((place v4 v15 v16 #o1 #o3 #o4))
           ((pick v4 v8 #o2 #g1 #o3 #o4))
           ((place v4 v8 #o2 #g1 #o3 #o4))
           ((pick v4 v8 #p1 #g1 #q3 #t6))
           ((place v4 v8 #p1 #g1 #q3 #t6))
           ((pick v4 v8 v9 #g1 #q2 #t4))
           ((place v4 v8 v9 #g1 #q2 #t4))
           ```
           
           Please provide a plan that achieves the goal from the initial state.
           
           The system attempted the following plan in the past, but it failed:
           
           ```
           Action(name='move_base', args=('v3', '#q0', '#t1'))
           Action(name='pick', args=('v4', 'v8', 'v9', '#g0', '#q0', '#t0'))
           Action(name='move_base', args=('#q0', '#q1', '#t3'))
           Action(name='place', args=('v4', 'v8', '#p0', '#g0', '#q1', '#t2'))
           ```
           
           This was because the following function call did not succeed: `test-cfree-traj-pose:('#t0', 'v15', 'v16')->()`, which impeded executing the action pick('v4', 'v8', 'v9', '#g0', '#q0', '#t0').
           This means that some details about the scene geometry made it impossible to execute the sequence of actions.

Model:     The goal is `new-axiom@0()`, which states that there exists an object `?culprit` such that it is graspable and is not equal to `?o`, where `?o` is an object that is on `v18` and has type `v17`. The initial state has `v8` which is of type `v17`. `v8` is on `v11` and also supported by `v18`. Therefore, if `v8` is `?o` then the goal can be satisfied by finding a `?culprit` that is graspable and not `v8`. Objects `v12` and `v15` are both graspable and are not `v8`, so the goal is achievable.
           
           The previous plan failed because picking `v8` from `v9` with trajectory `#t0` collided with `v15` at `v16`. This indicates that `v15` at `v16` is obstructing the pick motion. To achieve the goal without collision, we can either move the obstructing object, or pick a different object, or pick `v8` from a different pose.
           
           Let's re-evaluate the initial state and available actions:
           - We have objects `v8`, `v12`, `v15` which are `graspable`.
           - `v8` is at `v9` and supported by `v11`. It can also be placed at `#p1` on `v18` or `#o2` on `v10`.
           - `v12` is at `v13` and supported by `v14`. It can also be placed at `#o2` on `v18` or `#o2` on `v10`.
           - `v15` is at `v16` and supported by `v11`. It can also be placed at `#o2` on `v10`.
           - The robot's arm `v4` is `handempty` and at `v7`.
           
           The goal `new-axiom@0()` can be satisfied by `v12` or `v15` if `v8` is `?o` (meaning `v8` is on `v18` and type `v17`). `v8` is already of type `v17`. If we can place `v8` on `v18`, then `v12` or `v15` can be the culprit.
           
           Let's try to achieve `on(v8, v18)`.
           `v8` is currently at `v9`. We need to pick it and place it on `v18` at `#p1`.
           The previous failure was when picking `v8` from `v9` using `pick v4 v8 v9 #g1 #q2 #t4`. The collision happened with `v15` at `v16`. This implies that `v15` at `v16` is an obstacle for the specific trajectory `#t4`.
           
           Let's try picking `v8` from a different pose, or picking `v12` or `v15` instead if that satisfies some intermediate condition to move `v8`. The goal only requires an object to be on `v18` and another different graspable object to exist. The previous attempt was trying to move `v8` onto `v18` (implicitly). Let's see if we can move `v12` to `v18` instead. `v12` is at `v13`, and can be placed at `#o2` on `v18`. This seems to be a valid path to satisfy the `on(?o, v18)` part of the axiom.
           
           1. `pick v4 v12 v13 #o1 #o3 #o4`: Pick `v12` from `v13`. This action has `kin(v4, v12, v13, #o1, #o3, #o4)`.
              - Requires `atbconf(#o3)`. We are at `v3`. So, we need to `move_base v3 #o3 #o0`.
              - Preconditions for pick: `atpose(v12, v13)`, `handempty(v4)`, `atbconf(#o3)`. All are satisfied after moving.
           2. `place v4 v12 #o2 #o1 #o3 #o4`: Place `v12` onto `v18` (via `#o2`). This action requires `kin(v4, v12, #o2, #o1, #o3, #o4)` which is provided.
              - Preconditions for place: `atgrasp(v4, v12, #o1)`, `atbconf(#o3)`. Both satisfied.
           
           After these two actions, `atpose(v12, #o2)` will be true. Since `supported(v12, #o2, v18)` is true, it means `on(v12, v18)` will be true. `type(v12, v17)` is also true. So, `new-axiom@1()` is true. Now we just need a graspable `?culprit` that is not `v12`. `v8` is graspable and not `v12`. So the goal `new-axiom@0()` is satisfied.
           
           --Plan--:
           (move_base v3 #o3 #o0)
           (pick v4 v12 v13 #o1 #o3 #o4)
           (place v4 v12 #o2 #o1 #o3 #o4)

