User:      Here is a list of objects present in this scene for this task: 
           
           ```
           #g4: object
           #g5: object
           #g6: object
           #g7: object
           #o0: object
           #o2: object
           #o3: object
           #o4: object
           #q12: object
           #q13: object
           #q14: object
           #q15: object
           #q16: object
           #q17: object
           #q18: object
           #q19: object
           #q20: object
           #q21: object
           #t33: object
           #t34: object
           #t35: object
           #t36: object
           #t37: object
           #t38: object
           #t39: object
           #t40: object
           #t41: object
           #t42: object
           #t43: object
           #t44: object
           #t45: object
           #t46: object
           #t47: object
           #t48: object
           #t49: object
           #t50: object
           #t51: object
           #t52: object
           #t53: object
           #t54: object
           #t55: object
           #t56: object
           #t57: object
           #t58: object
           #t59: object
           @sink: object
           @stove: object
           p16: object
           p17: object
           p18: object
           p19: object
           p20: object
           p21: object
           p22: object
           p23: object
           v10: object
           v11: object
           v12: object
           v13: object
           v14: object
           v15: object
           v16: object
           v17: object
           v18: object
           v19: object
           v20: object
           v21: object
           v22: object
           v23: object
           v3: object
           v36: object
           v37: object
           v38: object
           v39: object
           v4: object
           v40: object
           v41: object
           v42: object
           v43: object
           v5: object
           v6: object
           v7: object
           v8: object
           v9: object
           ```
           
           Some of the objects represent continuous values that have already been computed. In particular:
           Object v3 is a base configuration with (x, y, theta) = (-1.0, 0.0, 0.0).
           Object p19 is a pose with position (0.08, 0.0, 0.782) and quaternion (0.0, 0.0, 0.0, 1.0).
           Object v19 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-1.342, -0.481), (-0.408, 0.618)).
           Object v11 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-0.3, -0.6), (0.3, 0.6)).
           Object v12 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((0.013, 0.242), (0.099, 0.327)).
           Object v13 is a pose with position (0.056, 0.285, 0.781) and quaternion (0.0, 0.0, -0.612, 0.791).
           Object p23 is a pose with position (0.08, 0.0, 0.782) and quaternion (0.0, 0.0, 0.0, 1.0).
           Object p22 is a pose with position (0.05, 0.0, 0.782) and quaternion (0.0, 0.0, 0.0, 1.0).
           Object p21 is a pose with position (-0.05, 0.0, 0.782) and quaternion (0.0, 0.0, 0.0, 1.0).
           Object p20 is a pose with position (0.0, 0.0, 0.782) and quaternion (0.0, 0.0, 0.0, 1.0).
           Object v14 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((0.015, -0.035), (0.085, 0.035)).
           Object v15 is a pose with position (-0.147, 0.517, 0.781) and quaternion (0.0, 0.0, 0.991, -0.137).
           Object p17 is a pose with position (-0.05, 0.0, 0.782) and quaternion (0.0, 0.0, 0.0, 1.0).
           Object v5 is an arm configuration with joint values (0.677, -0.343, 1.2, -1.467, 1.242, -1.954, 2.223).
           Object v16 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((0.045, -0.035), (0.115, 0.035)).
           Object v17 is a pose with position (0.092, -0.312, 0.781) and quaternion (0.0, 0.0, 0.274, 0.962).
           Object v7 is an arm configuration with joint values (-2.135, 1.296, -3.75, -0.15, -10000.0, -0.1, -10000.0).
           Object p18 is a pose with position (0.05, 0.0, 0.782) and quaternion (0.0, 0.0, 0.0, 1.0).
           Object v18 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-0.135, -0.135), (0.135, 0.135)).
           Object v8 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-0.035, -0.035), (0.035, 0.035)).
           Object p16 is a pose with position (0.0, 0.0, 0.782) and quaternion (0.0, 0.0, 0.0, 1.0).
           Object v9 is a pose with position (0.21, -0.404, 0.781) and quaternion (0.0, 0.0, -0.115, 0.993).
           
           You *must* use these values to select actions that are more likely to be executable (e.g., objects that are not obstructed by others) and that will have the least cost (e.g., objects that are closer to the robot or to the target region).
           
           The initial state is given by the following facts: 
           
           ```
           Atom canmove()
           Atom bconf(v3)
           Atom atbconf(v3)
           Atom arm(v4)
           Atom aconf(v4, v5)
           Atom handempty(v4)
           Atom ataconf(v4, v5)
           Atom controllable(v4)
           Atom arm(v6)
           Atom aconf(v6, v7)
           Atom handempty(v6)
           Atom ataconf(v6, v7)
           Atom graspable(v8)
           Atom pose(v8, v9)
           Atom atpose(v8, v9)
           Atom stackable(v8, v10)
           Atom supported(v8, v9, v11)
           Atom graspable(v12)
           Atom pose(v12, v13)
           Atom atpose(v12, v13)
           Atom stackable(v12, v10)
           Atom supported(v12, v13, v11)
           Atom graspable(v14)
           Atom pose(v14, v15)
           Atom atpose(v14, v15)
           Atom stackable(v14, v10)
           Atom supported(v14, v15, v11)
           Atom graspable(v16)
           Atom pose(v16, v17)
           Atom atpose(v16, v17)
           Atom stackable(v16, v10)
           Atom supported(v16, v17, v11)
           Atom stackable(v8, v18)
           Atom stackable(v12, v18)
           Atom stackable(v14, v18)
           Atom stackable(v16, v18)
           Atom pose(v14, p18)
           Atom supported(v14, p18, v10)
           Atom pose(v16, p19)
           Atom supported(v16, p19, v18)
           Atom supported(v14, p18, v18)
           Atom pose(v12, p17)
           Atom supported(v12, p17, v18)
           Atom pose(v8, p16)
           Atom supported(v8, p16, v18)
           Atom supported(v12, p17, v10)
           Atom supported(v16, p19, v10)
           Atom supported(v8, p16, v10)
           Atom kin(v36, v41, p17, v38, v39, v40)
           Atom kin(v36, v43, p19, v38, v39, v40)
           Atom kin(v36, v37, p16, v38, v39, v40)
           Atom kin(v36, v42, p18, v38, v39, v40)
           Atom pose(v12, p21)
           Atom supported(v12, p21, v10)
           Atom pose(v8, p20)
           Atom supported(v8, p20, v10)
           Atom pose(v14, p22)
           Atom supported(v14, p22, v18)
           Atom supported(v8, p20, v18)
           Atom supported(v14, p22, v10)
           Atom supported(v12, p21, v18)
           Atom pose(v16, p23)
           Atom supported(v16, p23, v18)
           Atom supported(v16, p23, v10)
           Atom kin(v36, v37, p20, v38, v39, v40)
           Atom kin(v36, v41, p21, v38, v39, v40)
           Atom kin(v36, v42, p22, v38, v39, v40)
           Atom kin(v36, v43, p23, v38, v39, v40)
           Atom btraj(#o0)
           Atom basemotion(v3, #o0, v3)
           Atom grasp(v16, #g6)
           Atom pose(v14, #o2)
           Atom supported(v14, #o2, v10)
           Atom pose(v16, #o2)
           Atom supported(v16, #o2, v18)
           Atom supported(v14, #o2, v18)
           Atom pose(v12, #o2)
           Atom supported(v12, #o2, v18)
           Atom pose(v8, #o2)
           Atom supported(v8, #o2, v18)
           Atom grasp(v14, #g7)
           Atom supported(v12, #o2, v10)
           Atom supported(v16, #o2, v10)
           Atom grasp(v12, #g4)
           Atom supported(v8, #o2, v10)
           Atom grasp(v8, #g5)
           Atom bconf(#q16)
           Atom atraj(#t41)
           Atom kin(v4, v16, v17, #g6, #q16, #t41)
           Atom bconf(#q20)
           Atom atraj(#t53)
           Atom kin(v4, v16, p23, #g6, #q20, #t53)
           Atom bconf(#q14)
           Atom atraj(#t35)
           Atom kin(v4, v16, p19, #g6, #q14, #t35)
           Atom bconf(#q19)
           Atom atraj(#t44)
           Atom kin(v4, v14, p18, #g7, #q19, #t44)
           Atom bconf(#q15)
           Atom atraj(#t36)
           Atom kin(v4, v14, v15, #g7, #q15, #t36)
           Atom bconf(#q21)
           Atom atraj(#t55)
           Atom kin(v4, v14, p22, #g7, #q21, #t55)
           Atom bconf(#o3)
           Atom atraj(#o4)
           Atom kin(v4, v12, p21, #g4, #o3, #o4)
           Atom bconf(#q12)
           Atom atraj(#t33)
           Atom kin(v4, v12, v13, #g4, #q12, #t33)
           Atom bconf(#q18)
           Atom atraj(#t43)
           Atom kin(v4, v12, p17, #g4, #q18, #t43)
           Atom bconf(#q17)
           Atom atraj(#t42)
           Atom kin(v4, v8, v9, #g5, #q17, #t42)
           Atom kin(v4, v8, p20, #g5, #o3, #o4)
           Atom bconf(#q13)
           Atom atraj(#t34)
           Atom kin(v4, v8, p16, #g5, #q13, #t34)
           Atom basemotion(#q14, #o0, v3)
           Atom btraj(#t39)
           Atom basemotion(v3, #t39, #q14)
           Atom basemotion(#q14, #o0, #q14)
           Atom basemotion(#q15, #o0, v3)
           Atom btraj(#t40)
           Atom basemotion(v3, #t40, #q15)
           Atom basemotion(#q15, #o0, #q15)
           Atom basemotion(#q14, #o0, #q15)
           Atom basemotion(#q15, #o0, #q14)
           Atom basemotion(#q19, #o0, v3)
           Atom basemotion(v3, #o0, #q19)
           Atom basemotion(#q19, #o0, #q19)
           Atom btraj(#t49)
           Atom basemotion(#q15, #t49, #q19)
           Atom basemotion(#q19, #o0, #q15)
           Atom basemotion(#q14, #o0, #q19)
           Atom basemotion(#q19, #o0, #q14)
           Atom basemotion(#q13, #o0, v3)
           Atom btraj(#t38)
           Atom basemotion(v3, #t38, #q13)
           Atom basemotion(#q13, #o0, #q13)
           Atom basemotion(#q19, #o0, #q13)
           Atom basemotion(#q13, #o0, #q19)
           Atom basemotion(#q15, #o0, #q13)
           Atom basemotion(#q13, #o0, #q15)
           Atom basemotion(#q14, #o0, #q13)
           Atom basemotion(#q13, #o0, #q14)
           Atom basemotion(#q20, #o0, v3)
           Atom basemotion(#q20, #o0, #q15)
           Atom basemotion(#q20, #o0, #q13)
           Atom basemotion(#q20, #o0, #q19)
           Atom basemotion(v3, #o0, #q20)
           Atom basemotion(#q20, #o0, #q20)
           Atom btraj(#t56)
           Atom basemotion(#q15, #t56, #q20)
           Atom basemotion(#q13, #o0, #q20)
           Atom basemotion(#q19, #o0, #q20)
           Atom basemotion(#q14, #o0, #q20)
           Atom basemotion(#q20, #o0, #q14)
           Atom basemotion(#q17, #o0, v3)
           Atom btraj(#t51)
           Atom basemotion(v3, #t51, #q17)
           Atom basemotion(#q17, #o0, #q17)
           Atom basemotion(#q13, #o0, #q17)
           Atom btraj(#t48)
           Atom basemotion(#q17, #t48, #q13)
           Atom basemotion(#q19, #o0, #q17)
           Atom basemotion(#q17, #o0, #q19)
           Atom basemotion(#q15, #o0, #q17)
           Atom basemotion(#q17, #o0, #q15)
           Atom basemotion(#q20, #o0, #q17)
           Atom basemotion(#q17, #o0, #q20)
           Atom basemotion(#q14, #o0, #q17)
           Atom basemotion(#q17, #o0, #q14)
           Atom basemotion(#q18, #o0, v3)
           Atom basemotion(#q18, #o0, #q17)
           Atom basemotion(#q18, #o0, #q13)
           Atom basemotion(v3, #o0, #q18)
           Atom basemotion(#q17, #o0, #q18)
           Atom basemotion(#q18, #o0, #q18)
           Atom basemotion(#q13, #o0, #q18)
           Atom basemotion(#q19, #o0, #q18)
           Atom basemotion(#q18, #o0, #q19)
           Atom basemotion(#q15, #o0, #q18)
           Atom btraj(#t45)
           Atom basemotion(#q18, #t45, #q15)
           Atom basemotion(#q20, #o0, #q18)
           Atom basemotion(#q18, #o0, #q20)
           Atom basemotion(#q14, #o0, #q18)
           Atom basemotion(#q18, #o0, #q14)
           Atom basemotion(#q16, #o0, v3)
           Atom basemotion(#q16, #o0, #q17)
           Atom basemotion(#q16, #o0, #q18)
           Atom basemotion(#q16, #o0, #q15)
           Atom basemotion(#q16, #o0, #q13)
           Atom basemotion(#q16, #o0, #q19)
           Atom basemotion(v3, #o0, #q16)
           Atom basemotion(#q17, #o0, #q16)
           Atom basemotion(#q16, #o0, #q16)
           Atom basemotion(#q18, #o0, #q16)
           Atom basemotion(#q15, #o0, #q16)
           Atom basemotion(#q13, #o0, #q16)
           Atom btraj(#t46)
           Atom basemotion(#q19, #t46, #q16)
           Atom btraj(#t54)
           Atom basemotion(#q20, #t54, #q16)
           Atom btraj(#t58)
           Atom basemotion(#q16, #t58, #q20)
           Atom basemotion(#q14, #o0, #q16)
           Atom btraj(#t52)
           Atom basemotion(#q16, #t52, #q14)
           Atom basemotion(#q12, #o0, v3)
           Atom basemotion(#q12, #o0, #q13)
           Atom basemotion(#q12, #o0, #q17)
           Atom btraj(#t37)
           Atom basemotion(v3, #t37, #q12)
           Atom basemotion(#q17, #o0, #q12)
           Atom basemotion(#q12, #o0, #q12)
           Atom btraj(#t50)
           Atom basemotion(#q13, #t50, #q12)
           Atom basemotion(#q18, #o0, #q12)
           Atom btraj(#t47)
           Atom basemotion(#q12, #t47, #q18)
           Atom basemotion(#q19, #o0, #q12)
           Atom basemotion(#q12, #o0, #q19)
           Atom basemotion(#q15, #o0, #q12)
           Atom basemotion(#q12, #o0, #q15)
           Atom basemotion(#q16, #o0, #q12)
           Atom basemotion(#q12, #o0, #q16)
           Atom basemotion(#q20, #o0, #q12)
           Atom basemotion(#q12, #o0, #q20)
           Atom basemotion(#q14, #o0, #q12)
           Atom basemotion(#q12, #o0, #q14)
           Atom basemotion(#q21, #o0, v3)
           Atom basemotion(#q21, #o0, #q17)
           Atom basemotion(#q21, #o0, #q12)
           Atom basemotion(#q21, #o0, #q18)
           Atom basemotion(#q21, #o0, #q15)
           Atom basemotion(#q21, #o0, #q13)
           Atom basemotion(#q21, #o0, #q19)
           Atom basemotion(v3, #o0, #q21)
           Atom basemotion(#q17, #o0, #q21)
           Atom basemotion(#q12, #o0, #q21)
           Atom basemotion(#q21, #o0, #q21)
           Atom basemotion(#q18, #o0, #q21)
           Atom btraj(#t57)
           Atom basemotion(#q15, #t57, #q21)
           Atom basemotion(#q13, #o0, #q21)
           Atom basemotion(#q19, #o0, #q21)
           Atom btraj(#t59)
           Atom basemotion(#q16, #t59, #q21)
           Atom basemotion(#q21, #o0, #q16)
           Atom basemotion(#q20, #o0, #q21)
           Atom basemotion(#q21, #o0, #q20)
           Atom basemotion(#q14, #o0, #q21)
           Atom basemotion(#q21, #o0, #q14)
           Atom kin(v4, v8, #o2, #g5, #o3, #o4)
           Atom kin(v4, v14, #o2, #g7, #o3, #o4)
           Atom kin(v4, v16, #o2, #g6, #o3, #o4)
           Atom kin(v4, v12, #o2, #g4, #o3, #o4)
           Atom basemotion(#o3, #o0, v3)
           Atom basemotion(#o3, #o0, #q17)
           Atom basemotion(v3, #o0, #o3)
           Atom basemotion(#o3, #o0, #o3)
           Atom basemotion(#q17, #o0, #o3)
           Atom basemotion(#q13, #o0, #o3)
           Atom basemotion(#o3, #o0, #q13)
           Atom basemotion(#q12, #o0, #o3)
           Atom basemotion(#o3, #o0, #q12)
           Atom basemotion(#q18, #o0, #o3)
           Atom basemotion(#o3, #o0, #q18)
           Atom basemotion(#q19, #o0, #o3)
           Atom basemotion(#o3, #o0, #q19)
           Atom basemotion(#q15, #o0, #o3)
           Atom basemotion(#o3, #o0, #q15)
           Atom basemotion(#q21, #o0, #o3)
           Atom basemotion(#o3, #o0, #q21)
           Atom basemotion(#q16, #o0, #o3)
           Atom basemotion(#o3, #o0, #q16)
           Atom basemotion(#q20, #o0, #o3)
           Atom basemotion(#o3, #o0, #q20)
           Atom basemotion(#q14, #o0, #o3)
           Atom basemotion(#o3, #o0, #q14)
           ```
           
           The goal expression is `Conjunction
               Atom on(v8, v18)
               Atom on(v12, v18)
               Atom on(v14, v18)
               Atom on(v16, v18)`. Given these elements, the list of available action instances is:
           
           ```
           ((move_base #o3 #o3 #o0))
           ((move_base #o3 #q12 #o0))
           ((move_base #o3 #q13 #o0))
           ((move_base #o3 #q14 #o0))
           ((move_base #o3 #q15 #o0))
           ((move_base #o3 #q16 #o0))
           ((move_base #o3 #q17 #o0))
           ((move_base #o3 #q18 #o0))
           ((move_base #o3 #q19 #o0))
           ((move_base #o3 #q20 #o0))
           ((move_base #o3 #q21 #o0))
           ((move_base #o3 v3 #o0))
           ((move_base #q12 #o3 #o0))
           ((move_base #q12 #q12 #o0))
           ((move_base #q12 #q13 #o0))
           ((move_base #q12 #q14 #o0))
           ((move_base #q12 #q15 #o0))
           ((move_base #q12 #q16 #o0))
           ((move_base #q12 #q17 #o0))
           ((move_base #q12 #q19 #o0))
           ((move_base #q12 #q20 #o0))
           ((move_base #q12 #q21 #o0))
           ((move_base #q12 v3 #o0))
           ((move_base #q12 #q18 #t47))
           ((move_base #q13 #o3 #o0))
           ((move_base #q13 #q13 #o0))
           ((move_base #q13 #q14 #o0))
           ((move_base #q13 #q15 #o0))
           ((move_base #q13 #q16 #o0))
           ((move_base #q13 #q17 #o0))
           ((move_base #q13 #q18 #o0))
           ((move_base #q13 #q19 #o0))
           ((move_base #q13 #q20 #o0))
           ((move_base #q13 #q21 #o0))
           ((move_base #q13 v3 #o0))
           ((move_base #q13 #q12 #t50))
           ((move_base #q14 #o3 #o0))
           ((move_base #q14 #q12 #o0))
           ((move_base #q14 #q13 #o0))
           ((move_base #q14 #q14 #o0))
           ((move_base #q14 #q15 #o0))
           ((move_base #q14 #q16 #o0))
           ((move_base #q14 #q17 #o0))
           ((move_base #q14 #q18 #o0))
           ((move_base #q14 #q19 #o0))
           ((move_base #q14 #q20 #o0))
           ((move_base #q14 #q21 #o0))
           ((move_base #q14 v3 #o0))
           ((move_base #q15 #o3 #o0))
           ((move_base #q15 #q12 #o0))
           ((move_base #q15 #q13 #o0))
           ((move_base #q15 #q14 #o0))
           ((move_base #q15 #q15 #o0))
           ((move_base #q15 #q16 #o0))
           ((move_base #q15 #q17 #o0))
           ((move_base #q15 #q18 #o0))
           ((move_base #q15 v3 #o0))
           ((move_base #q15 #q19 #t49))
           ((move_base #q15 #q20 #t56))
           ((move_base #q15 #q21 #t57))
           ((move_base #q16 #o3 #o0))
           ((move_base #q16 #q12 #o0))
           ((move_base #q16 #q13 #o0))
           ((move_base #q16 #q15 #o0))
           ((move_base #q16 #q16 #o0))
           ((move_base #q16 #q17 #o0))
           ((move_base #q16 #q18 #o0))
           ((move_base #q16 #q19 #o0))
           ((move_base #q16 v3 #o0))
           ((move_base #q16 #q14 #t52))
           ((move_base #q16 #q20 #t58))
           ((move_base #q16 #q21 #t59))
           ((move_base #q17 #o3 #o0))
           ((move_base #q17 #q12 #o0))
           ((move_base #q17 #q14 #o0))
           ((move_base #q17 #q15 #o0))
           ((move_base #q17 #q16 #o0))
           ((move_base #q17 #q17 #o0))
           ((move_base #q17 #q18 #o0))
           ((move_base #q17 #q19 #o0))
           ((move_base #q17 #q20 #o0))
           ((move_base #q17 #q21 #o0))
           ((move_base #q17 v3 #o0))
           ((move_base #q17 #q13 #t48))
           ((move_base #q18 #o3 #o0))
           ((move_base #q18 #q12 #o0))
           ((move_base #q18 #q13 #o0))
           ((move_base #q18 #q14 #o0))
           ((move_base #q18 #q16 #o0))
           ((move_base #q18 #q17 #o0))
           ((move_base #q18 #q18 #o0))
           ((move_base #q18 #q19 #o0))
           ((move_base #q18 #q20 #o0))
           ((move_base #q18 #q21 #o0))
           ((move_base #q18 v3 #o0))
           ((move_base #q18 #q15 #t45))
           ((move_base #q19 #o3 #o0))
           ((move_base #q19 #q12 #o0))
           ((move_base #q19 #q13 #o0))
           ((move_base #q19 #q14 #o0))
           ((move_base #q19 #q15 #o0))
           ((move_base #q19 #q17 #o0))
           ((move_base #q19 #q18 #o0))
           ((move_base #q19 #q19 #o0))
           ((move_base #q19 #q20 #o0))
           ((move_base #q19 #q21 #o0))
           ((move_base #q19 v3 #o0))
           ((move_base #q19 #q16 #t46))
           ((move_base #q20 #o3 #o0))
           ((move_base #q20 #q12 #o0))
           ((move_base #q20 #q13 #o0))
           ((move_base #q20 #q14 #o0))
           ((move_base #q20 #q15 #o0))
           ((move_base #q20 #q17 #o0))
           ((move_base #q20 #q18 #o0))
           ((move_base #q20 #q19 #o0))
           ((move_base #q20 #q20 #o0))
           ((move_base #q20 #q21 #o0))
           ((move_base #q20 v3 #o0))
           ((move_base #q20 #q16 #t54))
           ((move_base #q21 #o3 #o0))
           ((move_base #q21 #q12 #o0))
           ((move_base #q21 #q13 #o0))
           ((move_base #q21 #q14 #o0))
           ((move_base #q21 #q15 #o0))
           ((move_base #q21 #q16 #o0))
           ((move_base #q21 #q17 #o0))
           ((move_base #q21 #q18 #o0))
           ((move_base #q21 #q19 #o0))
           ((move_base #q21 #q20 #o0))
           ((move_base #q21 #q21 #o0))
           ((move_base #q21 v3 #o0))
           ((move_base v3 #o3 #o0))
           ((move_base v3 #q16 #o0))
           ((move_base v3 #q18 #o0))
           ((move_base v3 #q19 #o0))
           ((move_base v3 #q20 #o0))
           ((move_base v3 #q21 #o0))
           ((move_base v3 v3 #o0))
           ((move_base v3 #q12 #t37))
           ((move_base v3 #q13 #t38))
           ((move_base v3 #q14 #t39))
           ((move_base v3 #q15 #t40))
           ((move_base v3 #q17 #t51))
           ((pick v4 v12 #o2 #g4 #o3 #o4))
           ((place v4 v12 #o2 #g4 #o3 #o4))
           ((pick v4 v12 p17 #g4 #q18 #t43))
           ((place v4 v12 p17 #g4 #q18 #t43))
           ((pick v4 v12 p21 #g4 #o3 #o4))
           ((place v4 v12 p21 #g4 #o3 #o4))
           ((pick v4 v12 v13 #g4 #q12 #t33))
           ((place v4 v12 v13 #g4 #q12 #t33))
           ((pick v4 v14 #o2 #g7 #o3 #o4))
           ((place v4 v14 #o2 #g7 #o3 #o4))
           ((pick v4 v14 p18 #g7 #q19 #t44))
           ((place v4 v14 p18 #g7 #q19 #t44))
           ((pick v4 v14 p22 #g7 #q21 #t55))
           ((place v4 v14 p22 #g7 #q21 #t55))
           ((pick v4 v14 v15 #g7 #q15 #t36))
           ((place v4 v14 v15 #g7 #q15 #t36))
           ((pick v4 v16 #o2 #g6 #o3 #o4))
           ((place v4 v16 #o2 #g6 #o3 #o4))
           ((pick v4 v16 p19 #g6 #q14 #t35))
           ((place v4 v16 p19 #g6 #q14 #t35))
           ((pick v4 v16 p23 #g6 #q20 #t53))
           ((place v4 v16 p23 #g6 #q20 #t53))
           ((pick v4 v16 v17 #g6 #q16 #t41))
           ((place v4 v16 v17 #g6 #q16 #t41))
           ((pick v4 v8 #o2 #g5 #o3 #o4))
           ((place v4 v8 #o2 #g5 #o3 #o4))
           ((pick v4 v8 p16 #g5 #q13 #t34))
           ((place v4 v8 p16 #g5 #q13 #t34))
           ((pick v4 v8 p20 #g5 #o3 #o4))
           ((place v4 v8 p20 #g5 #o3 #o4))
           ((pick v4 v8 v9 #g5 #q17 #t42))
           ((place v4 v8 v9 #g5 #q17 #t42))
           ```
           
           Please provide a plan that achieves the goal from the initial state.
           
           The system attempted the following plan in the past, but it failed:
           
           ```
           Action(name='move_base', args=('v3', '#q7', '#t31'))
           Action(name='pick', args=('v4', 'v8', 'v9', '#g3', '#q7', '#t11'))
           Action(name='move_base', args=('#q7', '#q10', '#t25'))
           Action(name='place', args=('v4', 'v8', 'p16', '#g3', '#q10', '#t22'))
           Action(name='move_base', args=('#q10', '#q0', '#t32'))
           Action(name='pick', args=('v4', 'v12', 'v13', '#g0', '#q0', '#t0'))
           Action(name='move_base', args=('#q0', '#q8', '#t14'))
           Action(name='place', args=('v4', 'v12', 'p17', '#g0', '#q8', '#t12'))
           Action(name='move_base', args=('#q8', '#q3', '#t16'))
           Action(name='pick', args=('v4', 'v14', 'v15', '#g1', '#q3', '#t3'))
           Action(name='move_base', args=('#q3', '#q9', '#t19'))
           Action(name='place', args=('v4', 'v14', 'p18', '#g1', '#q9', '#t15'))
           Action(name='move_base', args=('#q9', '#q5', '#t27'))
           Action(name='pick', args=('v4', 'v16', 'v17', '#g2', '#q5', '#t9'))
           Action(name='move_base', args=('#q5', '#q11', '#t30'))
           Action(name='place', args=('v4', 'v16', 'p19', '#g2', '#q11', '#t29'))
           ```
           
           This was because the following function call did not succeed: `test-cfree-pose-pose:('v16', 'p19', 'v14', 'p18')->()`
           This means that some details about the scene geometry made it impossible to execute the sequence of actions. If the failure occurs after placing on any pose that does not start with '#', it may be due to using a combination of invalid poses.As the expert, you may decide to choose additional poses, providing their continuous values using any free pose starting with '#'. 

Model:     The goal is to place all four objects (v8, v12, v14, and v16) on the surface v18. Currently, all four objects are on v11. We need to pick each object and place it on v18. The previous plan failed because placing v16 at p19 collided with v14 at p18. This suggests that p18 and p19 are too close to each other when placing on surface v18. We need to find different placements for the objects on v18 to avoid collisions. The problem statement says that we can use poses that start with '#' if necessary, and that we must define their values. It also states that if the continuous value for a surface is not provided, then it is a dummy surface, and in this case, we must choose any other surface whose continuous value is provided and provide a placement on that surface. Since v18 is not a dummy surface (its continuous value is not provided), we can place objects on it. The initial state provides precomputed poses for each object (p16, p17, p18, p19, p20, p21, p22, p23) that are supported by v18. We should choose poses that are far enough apart to avoid collisions.
           
           Here's the plan:
           
           1.  Pick v8 from v9 (on v11).
           2.  Move the robot to a base configuration suitable for placing v8.
           3.  Place v8 at p16 (on v18).
           4.  Move the robot to a base configuration suitable for picking v12.
           5.  Pick v12 from v13 (on v11).
           6.  Move the robot to a base configuration suitable for placing v12.
           7.  Place v12 at p17 (on v18).
           8.  Move the robot to a base configuration suitable for picking v14.
           9.  Pick v14 from v15 (on v11).
           10. Move the robot to a base configuration suitable for placing v14.
           11. Place v14 at p18 (on v18).
           12. Move the robot to a base configuration suitable for picking v16.
           13. Pick v16 from v17 (on v11).
           14. Move the robot to a base configuration suitable for placing v16.
           15. Place v16 at p19 (on v18).
           
           The previous attempt failed because p19 and p18 were too close. However, the problem statement says "if the failure occurs after placing on any pose that does not start with '#', it may be due to using a combination of invalid poses." This suggests that the given p16, p17, p18, p19, p20, p21, p22, p23 are valid poses to be used. Since they are precomputed and supported on v18, they should be collision-free with respect to *each other* when no other object occupies the space. The failure likely occurred because a `cfreeposepose` collision check failed for `v16` and `v14` when `v14` was *already* placed on `p18` and `v16` was *attempting* to be placed on `p19`. This means we need to ensure the poses chosen are collision-free relative to each other. The previous plan used p18 for v14 and p19 for v16. Let's try to arrange them to avoid collisions. The poses p16, p17, p18, p19 are fairly close together for a surface with AABB ((-0.135, -0.135), (0.135, 0.135)), and p20, p21, p22, p23 are also provided. We will attempt to use p16, p17, p18, and p19. The order matters to avoid collision. Since v18 has a bounding box of ((-0.135, -0.135), (0.135, 0.135)), the objects must be placed within this small area.
           Let's choose the following order of placement for the objects:
           v8 -> p16
           v12 -> p17
           v14 -> p18
           v16 -> p19
           
           The given poses for objects v8, v12, v14, v16 on surface v18 are:
           v8: p16 (0.0, 0.0, 0.782)
           v12: p17 (-0.05, 0.0, 0.782)
           v14: p18 (0.05, 0.0, 0.782)
           v16: p19 (0.08, 0.0, 0.782)
           
           The previous failure was `test-cfree-pose-pose:('v16', 'p19', 'v14', 'p18')->()`. This means that p19 and p18 are too close for v16 and v14 given their sizes. Let's try to use some other poses that are further apart or rearrange the order. The initial state also provides p20, p21, p22, p23.
           p20 (0.0, 0.0, 0.782)
           p21 (-0.05, 0.0, 0.782)
           p22 (0.05, 0.0, 0.782)
           p23 (0.08, 0.0, 0.782)
           
           These appear to be identical values to p16-p19. This means we'll likely hit the same collision issue. There are no other specified poses for v18. The problem statement says if a pose starting with '#' for which `pose(obj, #<name>)` is in the initial state is used in your plan, please also provide a continuous value for it. We have `#o2` for all objects on `v18`. Let's try to use `#o2` and manually assign collision-free poses.
           
           Let's try to assign the objects to the distinct regions within the v18 AABB:
           v18: ((-0.135, -0.135), (0.135, 0.135))
           
           Let's assign these poses to `#o2` for each object such that they don't collide.
           v8: #o2 -> (-0.1, 0.0, 0.782)
           v12: #o2 -> (0.0, 0.0, 0.782)
           v14: #o2 -> (0.1, 0.0, 0.782)
           v16: #o2 -> (0.0, 0.1, 0.782)
           
           This might not work as the kinematics are for general #o2, but the collision checking would need to distinguish them. The problem states "if the plan requires multiple different objects to be placed simultaneously at the same pose starting with '#', then you must provide a different continuous value for *each* object at that pose (not one that works for all), specifying the pose name, object name, and surface name."
           This means we should use separate #<name> poses for each object to define unique placements. However, the initial state only provides `#o2` for all objects on `v18`. This implies that the same continuous value is expected if we use `#o2`. The problem statement also says "if the plan you select uses a pose that does not begin with '#', then you need not provide a value for it, as one already exists." This indicates preference for existing poses.
           
           Since the problem is about rearranging objects on v18, and we have multiple poses already assigned to objects with `supported(obj, pose, v18)`, we should try combinations of these. The last failure was with `v16` at `p19` and `v14` at `p18`. These are (0.08, 0.0, 0.782) and (0.05, 0.0, 0.782). They are too close. Let's try to use p16, p17, p22, and p23 as these also exist in the initial state.
           v8 at p16
           v12 at p17
           v14 at p22
           v16 at p23
           This is equivalent to:
           v8 at (0.0, 0.0, 0.782)
           v12 at (-0.05, 0.0, 0.782)
           v14 at (0.05, 0.0, 0.782)
           v16 at (0.08, 0.0, 0.782)
           This is exactly the set of poses that caused a collision in the previous attempt when placing v16 at p19 and v14 was already at p18. Therefore, this combination will fail again.
           
           Let's rethink. If poses p16, p17, p18, p19, p20, p21, p22, p23 are *all* given as possible placement locations on v18, and `supported(obj, pose, v18)` is explicitly stated, then they *should* be valid *individual* placements. The collision likely arises from two objects being placed *too close to each other*.
           The AABB of v18 is small: ((-0.135, -0.135), (0.135, 0.135)). The poses are all along the x-axis, at y=0.0.
           p16 (0.0, 0.0, 0.782)
           p17 (-0.05, 0.0, 0.782)
           p18 (0.05, 0.0, 0.782)
           p19 (0.08, 0.0, 0.782)
           p20 (0.0, 0.0, 0.782) (same as p16)
           p21 (-0.05, 0.0, 0.782) (same as p17)
           p22 (0.05, 0.0, 0.782) (same as p18)
           p23 (0.08, 0.0, 0.782) (same as p19)
           
           So, we effectively have 4 distinct poses on the surface v18. Let's call them p_center (0.0, 0.0, 0.782), p_left (-0.05, 0.0, 0.782), p_right (0.05, 0.0, 0.782), p_far_right (0.08, 0.0, 0.782).
           The previous failure was `test-cfree-pose-pose:('v16', 'p19', 'v14', 'p18')->()`. This means `v16` (AABB: (0.045, -0.035), (0.115, 0.035)) and `v14` (AABB: (0.015, -0.035), (0.085, 0.035)) cannot be placed at `p19` and `p18` respectively at the same time. The x-coordinates of their bounding boxes overlap:
           v14 at p18: (0.05 + 0.015, 0.05 + 0.085) = (0.065, 0.135)
           v16 at p19: (0.08 + 0.045, 0.08 + 0.115) = (0.125, 0.195)
           This is not correct, the bounding boxes are relative to the object's origin. The object origin is placed at the pose. So for p18: x-range for v14 is (0.05+0.015, 0.05+0.085) and for p19: x-range for v16 is (0.08+0.045, 0.08+0.115). This is still not the correct interpretation.
           The pose is the object's origin. The AABB describes the object's extent relative to its origin. So, for v14 at p18, its x-range is (0.05 + 0.015) to (0.05 + 0.085) which is (0.065, 0.135). For v16 at p19, its x-range is (0.08 + 0.045) to (0.08 + 0.115) which is (0.125, 0.195). These ranges are outside the surface v18: ((-0.135, -0.135), (0.135, 0.135)).
           
           Ah, the pose values are specified with respect to the *world frame*. So if a pose is at (0.08, 0.0, 0.782), and an object is placed there, then its AABB would be (0.08 + minx, 0.08 + maxx).
           v14 at p18 (0.05, 0.0, 0.782) has AABB from (0.05 + 0.015, 0.05 + 0.085) which is (0.065, 0.135) and y from (0.0 - 0.035, 0.0 + 0.035) which is (-0.035, 0.035).
           v16 at p19 (0.08, 0.0, 0.782) has AABB from (0.08 + 0.045, 0.08 + 0.115) which is (0.125, 0.195) and y from (0.0 - 0.035, 0.0 + 0.035) which is (-0.035, 0.035).
           
           The objects' x-ranges are as follows:
           v8: (0.0-0.035, 0.0+0.035) = (-0.035, 0.035)
           v12: (0.056+0.013, 0.056+0.099) = (0.069, 0.155) (AABB for v12 is ((0.013, 0.242), (0.099, 0.327)), so it's a bit larger, I'll use its origin at the pose.)
           v14: (0.015, 0.085)
           v16: (0.045, 0.115)
           
           Let's assume the origin of the objects is at the center of their x-y bounds for the sake of simplicity for manual calculation.
           v8: AABB ((-0.035, -0.035), (0.035, 0.035)) => width 0.07.
           v12: AABB ((0.013, 0.242), (0.099, 0.327)) => width 0.086.
           v14: AABB ((0.015, -0.035), (0.085, 0.035)) => width 0.07.
           v16: AABB ((0.045, -0.035), (0.115, 0.035)) => width 0.07.
           
           If p16 is (0.0, 0.0, 0.782), v8 at p16 will occupy x-range (-0.035, 0.035).
           If p17 is (-0.05, 0.0, 0.782), v12 at p17 will occupy x-range (-0.05 + 0.013, -0.05 + 0.099) = (-0.037, 0.049). This clearly overlaps with v8 at p16.
           This means the precomputed poses are not guaranteed to be collision-free if multiple objects are placed there. We have to use the `#o2` pose and define appropriate values.
           
           We need to place all 4 objects (v8, v12, v14, v16) on v18 (AABB: ((-0.135, -0.135), (0.135, 0.135))). Let's use #o2 for each object and define different continuous values for them.
           We'll choose four distinct locations within v18's AABB.
           For v8 (0.07 x 0.07): let's place it at x=-0.1, y=0.0
           For v12 (0.086 x 0.085): let's place it at x=-0.03, y=0.0
           For v14 (0.07 x 0.07): let's place it at x=0.04, y=0.0
           For v16 (0.07 x 0.07): let's place it at x=0.11, y=0.0
           
           The problem states "if the plan requires multiple different objects to be placed simultaneously at the same pose starting with '#', then you must provide a different continuous value for *each* object at that pose (not one that works for all), specifying the pose name, object name, and surface name." This implies that we use the *same* pose name `#o2` for each object but provide distinct continuous values.
           
           Here's the plan:
           1. Pick v8 from its current pose v9.
           2. Place v8 at the designated position on v18 using `#o2`.
           3. Pick v12 from its current pose v13.
           4. Place v12 at the designated position on v18 using `#o2`.
           5. Pick v14 from its current pose v15.
           6. Place v14 at the designated position on v18 using `#o2`.
           7. Pick v16 from its current pose v17.
           8. Place v16 at the designated position on v18 using `#o2`.
           
           All pick actions will use the provided base configuration and trajectory for picking from the objects' current locations on v11. All place actions will use the provided base configuration and trajectory for placing at the computed `#o2` pose on v18.
           
           --Plan--:
           (move_base v3 #q17 #t51)
           (pick v4 v8 v9 #g5 #q17 #t42)
           (move_base #q17 #o3 #o0)
           (place v4 v8 #o2 #g5 #o3 #o4)
           (move_base #o3 #q12 #o0)
           (pick v4 v12 v13 #g4 #q12 #t33)
           (move_base #q12 #o3 #o0)
           (place v4 v12 #o2 #g4 #o3 #o4)
           (move_base #o3 #q15 #o0)
           (pick v4 v14 v15 #g7 #q15 #t36)
           (move_base #q15 #o3 #o0)
           (place v4 v14 #o2 #g7 #o3 #o4)
           (move_base #o3 #q16 #o0)
           (pick v4 v16 v17 #g6 #q16 #t41)
           (move_base #q16 #o3 #o0)
           (place v4 v16 #o2 #g6 #o3 #o4)
           
           --Poses--:
           (#o2 v8 v18): (-0.1 0.0 0.782 0.0)
           (#o2 v12 v18): (-0.03 0.0 0.782 0.0)
           (#o2 v14 v18): (0.04 0.0 0.782 0.0)
           (#o2 v16 v18): (0.11 0.0 0.782 0.0)

User:      Pose #o2 = (-0.1 0.0 0.782 0.0) for object v8 on surface v18 is not stable, as the 2D AABB of the object (AABB(lower=(-0.13500000149011612, -0.035), upper=(-0.06500000149011612, 0.035))) is not contained in the 2D AABB of the surface (AABB(lower=(-0.135, -0.135), upper=(0.135, 0.135))). Make sure your poses are in the format `(<x> <y> <z> <theta>)`.
           Pose #o2 = (0.11 0.0 0.782 0.0) for object v16 on surface v18 is not stable, as the 2D AABB of the object (AABB(lower=(0.07499999940395355, -0.035), upper=(0.14499999940395356, 0.035))) is not contained in the 2D AABB of the surface (AABB(lower=(-0.135, -0.135), upper=(0.135, 0.135))). Make sure your poses are in the format `(<x> <y> <z> <theta>)`.
           Please provide a plan and poses that achieves the goal from the initial state, ensuring that all poses are valid and stable.

Model:     My apologies for the unstable poses. I will recalculate the poses to ensure they are within the bounds of surface v18.
           
           Let's re-examine the AABBs of the objects and the surface v18.
           Surface v18 AABB: ((-0.135, -0.135), (0.135, 0.135))
           
           Object AABBs (relative to their origin):
           v8: ((-0.035, -0.035), (0.035, 0.035)) - width 0.07, height 0.07
           v12: ((0.013, 0.242), (0.099, 0.327)) - width 0.086, height 0.085
           v14: ((0.015, -0.035), (0.085, 0.035)) - width 0.07, height 0.07
           v16: ((0.045, -0.035), (0.115, 0.035)) - width 0.07, height 0.07
           
           For an object's AABB `((min_x, min_y), (max_x, max_y))` to be stable when placed at `(pose_x, pose_y, pose_z, pose_theta)`, the resulting world-frame AABB of the object `((pose_x + min_x, pose_y + min_y), (pose_x + max_x, pose_y + max_y))` must be contained within the surface's AABB.
           
           Let's assign the `z` coordinate to 0.782, as is consistent with other pose heights. The `theta` can be 0.0 for simplicity.
           
           For v8 (width 0.07, height 0.07):
           To be stable, `pose_x + min_x >= -0.135` and `pose_x + max_x <= 0.135`.
           And `pose_y + min_y >= -0.135` and `pose_y + max_y <= 0.135`.
           If we place v8's center at `(0.0, 0.0)` for its local AABB, `min_x=-0.035, max_x=0.035`.
           So `pose_x - 0.035 >= -0.135 => pose_x >= -0.1`
           And `pose_x + 0.035 <= 0.135 => pose_x <= 0.1`
           Similarly for y: `pose_y >= -0.1` and `pose_y <= 0.1`.
           A safe region for `pose_x` and `pose_y` for v8 is `(-0.1, 0.1)`.
           
           Let's adjust all poses to be safely within the surface. We can place them along the x-axis, centered on y=0.
           v8 (width 0.07):
           Center x at -0.1 + (0.07/2) = -0.065.
           Pose for v8: `(-0.065, 0.0, 0.782, 0.0)`
           Its AABB will be `(-0.065 - 0.035, -0.065 + 0.035)` which is `(-0.1, -0.03)` for x. This is contained within `(-0.135, 0.135)`.
           
           v12 (width 0.086, height 0.085). Its AABB is `((0.013, 0.242), (0.099, 0.327))`. This AABB is not centered at (0,0).
           Its actual width is `0.099 - 0.013 = 0.086`. Its actual height is `0.327 - 0.242 = 0.085`.
           `min_x = 0.013`, `max_x = 0.099`.
           `min_y = 0.242`, `max_y = 0.327`.
           To ensure stability for v12:
           `pose_x + 0.013 >= -0.135 => pose_x >= -0.148`
           `pose_x + 0.099 <= 0.135 => pose_x <= 0.036`
           `pose_y + 0.242 >= -0.135 => pose_y >= -0.377`
           `pose_y + 0.327 <= 0.135 => pose_y <= -0.192`
           Let's place v12 at the upper end of its x range, to the right of v8.
           A good x for v12 might be around `0.0`.
           If `pose_x = 0.0`, then x-range is `(0.013, 0.099)`. This is valid.
           For y, we need to choose `pose_y` such that `pose_y` is between `-0.377` and `-0.192`. Let's pick `pose_y = -0.25`.
           Pose for v12: `(0.0, -0.25, 0.782, 0.0)`
           
           v14 (width 0.07, height 0.07). AABB `((0.015, -0.035), (0.085, 0.035))`
           `min_x = 0.015`, `max_x = 0.085`.
           `min_y = -0.035`, `max_y = 0.035`.
           `pose_x + 0.015 >= -0.135 => pose_x >= -0.15`
           `pose_x + 0.085 <= 0.135 => pose_x <= 0.05`
           `pose_y - 0.035 >= -0.135 => pose_y >= -0.1`
           `pose_y + 0.035 <= 0.135 => pose_y <= 0.1`
           Let's place v14 to the right of v8, but in the center y-region.
           Pose for v14: `(0.0, 0.0, 0.782, 0.0)` (This would collide with v8. Let's make sure the new coordinates avoid overlap as well.)
           
           Let's try a different strategy for placing these objects to avoid collisions based on their actual AABBs.
           Surface v18: x range `[-0.135, 0.135]`, y range `[-0.135, 0.135]`
           Let's define placement poses (x,y) by considering the object's `min_x`, `max_x`, `min_y`, `max_y` from its AABB.
           For an object `o` with AABB `(ox_min, oy_min), (ox_max, oy_max)` placed at `(px, py)` to be contained within surface `s` with AABB `(sx_min, sy_min), (sx_max, sy_max)`:
           `px + ox_min >= sx_min`
           `px + ox_max <= sx_max`
           `py + oy_min >= sy_min`
           `py + oy_max <= sy_max`
           
           Let's list the AABBs for each object, and calculate a safe (px, py) range for each.
           v8: `((-0.035, -0.035), (0.035, 0.035))`
              `px >= -0.135 - (-0.035) = -0.1`
              `px <= 0.135 - 0.035 = 0.1`
              `py >= -0.135 - (-0.035) = -0.1`
              `py <= 0.135 - 0.035 = 0.1`
              Safe `px,py` range for v8: `[-0.1, 0.1]`
           
           v12: `((0.013, 0.242), (0.099, 0.327))`
              `px >= -0.135 - 0.013 = -0.148`
              `px <= 0.135 - 0.099 = 0.036`
              `py >= -0.135 - 0.242 = -0.377` (This suggests it's impossible to place v12 if y needs to be contained in `[-0.135, 0.135]`)
              `py <= 0.135 - 0.327 = -0.192`
              The y-range calculation for v12 is very restrictive: `[-0.377, -0.192]`. This means that `v12` cannot be placed on `v18` with its current AABB. The minimum y extent of v12 relative to its origin (0.242) is already quite high. If the object's local AABB starts at `y=0.242`, then even placing it at `py=0.0` would make its y-range `(0.242, 0.327)`, which is entirely outside the `[-0.135, 0.135]` surface y-bounds.
              This means object `v12` cannot be placed on surface `v18` stably.
              This task is not achievable given the geometry.
           
           If v12 cannot be placed on v18, then the goal `on(v12, v18)` is not achievable.
           
           Explanation:
           The goal requires placing object `v12` on surface `v18`. Upon calculating the stable placement region for `v12` given its axis-aligned bounding box (AABB) `((0.013, 0.242), (0.099, 0.327))` and the AABB of the target surface `v18` `((-0.135, -0.135), (0.135, 0.135))`, it becomes clear that `v12` cannot be stably placed on `v18`.
           Specifically, for an object to be stably placed on a surface, its entire 2D AABB (when projected onto the x-y plane, relative to the placement pose) must be contained within the 2D AABB of the surface.
           For `v12`, its local y-coordinates range from `0.242` to `0.327`. For this object to be stably on `v18`, if placed at `(px, py)`, its world y-coordinates `(py + 0.242)` to `(py + 0.327)` must be within `[-0.135, 0.135]`.
           This would require:
           `py + 0.242 >= -0.135  => py >= -0.377`
           `py + 0.327 <= 0.135   => py <= -0.192`
           For these two conditions to hold, `py` must be in the range `[-0.377, -0.192]`.
           However, even if `py` is in this range, the object's y-extent in the world frame would still be, for example, if `py = -0.2`: `(-0.2 + 0.242, -0.2 + 0.327) = (0.042, 0.127)`. This range `(0.042, 0.127)` is indeed within `[-0.135, 0.135]`.
           My previous calculation was incorrect; `v12` *can* be placed, but it requires a negative `py`.
           
           Let's re-calculate all positions assuming a `z` of 0.782 and `theta` of 0.0.
           To avoid collisions, we need to ensure the final placed AABBs do not overlap.
           Let's try to arrange them in a grid-like pattern on the `v18` surface.
           Surface v18: x range `[-0.135, 0.135]`, y range `[-0.135, 0.135]`
           
           1.  **v8:** AABB `((-0.035, -0.035), (0.035, 0.035))`
               Safe `px` range: `[-0.1, 0.1]`
               Safe `py` range: `[-0.1, 0.1]`
               Let's choose `px = -0.07`, `py = 0.07`.
               Object AABB in world: `(-0.07-0.035, -0.07+0.035)` = `(-0.105, -0.035)` (x-range)
               ` (0.07-0.035, 0.07+0.035)` = `(0.035, 0.105)` (y-range)
               Pose for v8: `(-0.07, 0.07, 0.782, 0.0)`
           
           2.  **v12:** AABB `((0.013, 0.242), (0.099, 0.327))`
               Safe `px` range: `[-0.148, 0.036]`
               Safe `py` range: `[-0.377, -0.192]`
               Let's choose `px = -0.05`, `py = -0.25`. (This py is okay, just looks weird).
               Object AABB in world: `(-0.05+0.013, -0.05+0.099)` = `(-0.037, 0.049)` (x-range)
               ` (-0.25+0.242, -0.25+0.327)` = `(-0.008, 0.077)` (y-range)
               Pose for v12: `(-0.05, -0.25, 0.782, 0.0)` (This pose is still potentially problematic. The `py` range `[-0.377, -0.192]` is for the object to be entirely contained within the surface `v18`'s `y` range `[-0.135, 0.135]`. This means that its y-coordinates will span a range, and all points in that range must be in the surface. If `py = -0.25`, its y range will be `(-0.008, 0.077)` which is valid. My initial confusion was because `py` was outside the `v18` y-bounds `[-0.135, 0.135]`. But `py` is the object's origin, not its AABB extent. The object's AABB extent is what needs to be within the surface. So `(-0.008, 0.077)` is contained in `[-0.135, 0.135]`).
           
           3.  **v14:** AABB `((0.015, -0.035), (0.085, 0.035))`
               Safe `px` range: `[-0.15, 0.05]`
               Safe `py` range: `[-0.1, 0.1]`
               Let's choose `px = 0.0`. Its local AABB starts at `x=0.015`. If `px=0.0`, then x-range is `(0.015, 0.085)`. This is valid within `[-0.135, 0.135]`.
               Let's choose `py = 0.07`.
               Object AABB in world: `(0.0+0.015, 0.0+0.085)` = `(0.015, 0.085)` (x-range)
               ` (0.07-0.035, 0.07+0.035)` = `(0.035, 0.105)` (y-range)
               This collides with `v8` at `(-0.07, 0.07)`. Let's move v14.
               Let's choose `px = 0.07`, `py = 0.07`. This will make it `(0.07+0.015, 0.07+0.085) = (0.085, 0.155)`. This x-range `(0.085, 0.155)` goes beyond `0.135`. So `px` cannot be `0.07`. Max `px` is `0.05`.
               Let's try `px = 0.03`, `py = 0.07`.
               Object AABB in world: `(0.03+0.015, 0.03+0.085)` = `(0.045, 0.115)` (x-range)
               ` (0.07-0.035, 0.07+0.035)` = `(0.035, 0.105)` (y-range)
               This still overlaps in y with v8.
           
           Let's organize them into 4 quadrants roughly.
           v18: x range `[-0.135, 0.135]`, y range `[-0.135, 0.135]`
           
           Let's try to place them like this:
           1.  **v8** (AABB width 0.07, height 0.07, centered AABB):
               `px = -0.135 + 0.035 + 0.01 = -0.09`
               `py = -0.135 + 0.035 + 0.01 = -0.09`
               Pose for v8: `(-0.09, -0.09, 0.782, 0.0)`
               World AABB for v8: x: `(-0.09-0.035, -0.09+0.035)` = `(-0.125, -0.055)`. y: `(-0.125, -0.055)`. OK.
           
           2.  **v14** (AABB width 0.07, height 0.07, local AABB `((0.015, -0.035), (0.085, 0.035))`):
               `max_px = 0.135 - 0.085 - 0.01 = 0.03`
               `max_py = 0.135 - 0.035 - 0.01 = 0.09`
               Pose for v14: `(0.03, 0.09, 0.782, 0.0)`
               World AABB for v14: x: `(0.03+0.015, 0.03+0.085)` = `(0.045, 0.115)`. y: `(0.09-0.035, 0.09+0.035)` = `(0.055, 0.125)`. OK.
               (This places v8 in bottom-left, v14 in top-right)
           
           3.  **v16** (AABB width 0.07, height 0.07, local AABB `((0.045, -0.035), (0.115, 0.035))`):
               `min_px = -0.135 - 0.045 + 0.01 = -0.17` (too far left, need `px <= 0.135 - 0.115 = 0.02`)
               `min_px = -0.135 - 0.045 = -0.18` (So `px` must be between -0.18 and 0.02).
               `min_py = -0.135 - (-0.035) + 0.01 = -0.09`
               `max_py = 0.135 - 0.035 - 0.01 = 0.09`
               Pose for v16: `(-0.05, 0.09, 0.782, 0.0)`
               World AABB for v16: x: `(-0.05+0.045, -0.05+0.115)` = `(-0.005, 0.065)`. y: `(0.09-0.035, 0.09+0.035)` = `(0.055, 0.125)`. OK.
               (This places v16 in top-left)
           
           4.  **v12** (AABB width 0.086, height 0.085, local AABB `((0.013, 0.242), (0.099, 0.327))`):
               `min_px = -0.135 - 0.013 + 0.01 = -0.138`
               `max_px = 0.135 - 0.099 - 0.01 = 0.026`
               `min_py = -0.135 - 0.242 + 0.01 = -0.367` (Still outside the y-range of v18)
               `max_py = 0.135 - 0.327 - 0.01 = -0.202`
               The y-range of v12 is `(py+0.242, py+0.327)`. We need this to be within `(-0.135, 0.135)`.
               So, `py+0.242 >= -0.135 => py >= -0.377`
               And `py+0.327 <= 0.135 => py <= -0.192`
               This means `py` must be in `[-0.377, -0.192]`.
               If we pick `py = -0.25`, then world AABB y for v12 is `(-0.008, 0.077)`. This is valid for v18.
               Let's choose `px = 0.0`.
               Pose for v12: `(0.0, -0.25, 0.782, 0.0)`
               World AABB for v12: x: `(0.0+0.013, 0.0+0.099)` = `(0.013, 0.099)`. y: `(-0.25+0.242, -0.25+0.327)` = `(-0.008, 0.077)`. OK.
               (This places v12 in bottom-right)
           
           Check for collisions between the objects' world AABBs:
           v8: x `(-0.125, -0.055)`, y `(-0.125, -0.055)` (bottom-left)
           v14: x `(0.045, 0.115)`, y `(0.055, 0.125)` (top-right)
           v16: x `(-0.005, 0.065)`, y `(0.055, 0.125)` (top-left)
           v12: x `(0.013, 0.099)`, y `(-0.008, 0.077)` (bottom-right)
           
           No overlaps in these ranges:
           v8 and v14: No x-overlap, no y-overlap. OK.
           v8 and v16: No x-overlap, y `(-0.125, -0.055)` vs `(0.055, 0.125)`. No y-overlap. OK.
           v8 and v12: No x-overlap, y `(-0.125, -0.055)` vs `(-0.008, 0.077)`. No y-overlap. OK.
           
           v14 and v16: x `(0.045, 0.115)` vs `(-0.005, 0.065)`. They overlap on x. `(0.045, 0.065)`.
           y `(0.055, 0.125)` vs `(0.055, 0.125)`. They overlap on y.
           Collision between v14 and v16.
           
           Let's adjust the x-coordinates for v14 and v16.
           v14 (`px` range `[-0.15, 0.05]`)
           v16 (`px` range `[-0.18, 0.02]`)
           
           Let's try to put v14 and v16 along the bottom and top edge, or side by side:
           Try:
           v8: `(-0.09, -0.09, 0.782, 0.0)`
           v12: `(0.0, -0.25, 0.782, 0.0)`
           v14: `(0.0, 0.0, 0.782, 0.0)` - this is still prone to collision.
           
           Let's place them with minimum spacing along the x-axis, using the available y-axis range more efficiently.
           We need to sort the objects by their effective x-extents.
           For v8 (`px` in `[-0.1, 0.1]`, effective width 0.07).
           For v12 (`px` in `[-0.148, 0.036]`, effective width 0.086).
           For v14 (`px` in `[-0.15, 0.05]`, effective width 0.07).
           For v16 (`px` in `[-0.18, 0.02]`, effective width 0.07).
           
           Let's try to place them at specific x coordinates within the `v18`'s x-range `[-0.135, 0.135]`.
           Let `y=0` for all for now, and see if x-ranges clash.
           Minimum x for an object `o`: `sx_min - ox_min`. Maximum x: `sx_max - ox_max`.
           Max width of object is for v12 (0.086).
           Let's try to center them as much as possible, with some spacing.
           
           Pose 1 for v8: `px = -0.135 + 0.035 + 0.01 = -0.09`, `py = -0.135 + 0.035 + 0.01 = -0.09`
              v8 world AABB: x `(-0.125, -0.055)`, y `(-0.125, -0.055)`
           
           Pose 2 for v16: `px = -0.135 + 0.045 + 0.01 = -0.08`, `py = 0.135 - 0.035 - 0.01 = 0.09`
              v16 world AABB: x `(-0.035, 0.035)`, y `(0.055, 0.125)`
           
           Pose 3 for v14: `px = 0.135 - 0.085 - 0.01 = 0.04`, `py = 0.135 - 0.035 - 0.01 = 0.09`
              v14 world AABB: x `(0.055, 0.125)`, y `(0.055, 0.125)`
           
           Pose 4 for v12: `px = 0.135 - 0.099 - 0.01 = 0.026`, `py = -0.135 - 0.242 + 0.01 = -0.367`
              This `py` is still going to be off the surface if it's based on `v18` bounds.
              We need `py` in range `[-0.377, -0.192]`. Let `py = -0.2`.
              v12 world AABB: x `(0.026+0.013, 0.026+0.099)` = `(0.039, 0.125)`. y `(-0.2+0.242, -0.2+0.327)` = `(0.042, 0.127)`.
           
           Let's verify collisions with these new set of poses:
           v8: x `(-0.125, -0.055)`, y `(-0.125, -0.055)`
           v16: x `(-0.035, 0.035)`, y `(0.055, 0.125)`
           v14: x `(0.055, 0.125)`, y `(0.055, 0.125)`
           v12: x `(0.039, 0.125)`, y `(0.042, 0.127)`
           
           Collisions:
           v16 and v12: x overlap `(0.039, 0.035)` is empty. Wait, `(-0.035, 0.035)` and `(0.039, 0.125)`. No x-overlap.
           v14 and v12: x overlap `(0.055, 0.125)` and `(0.039, 0.125)`. Overlap `(0.055, 0.125)`.
           y overlap `(0.055, 0.125)` and `(0.042, 0.127)`. Overlap `(0.055, 0.125)`.
           This is a collision between v14 and v12.
           
           The issue is that v12 and v14 have similar right-side x-extents.
           Let's assign them specific quadrants or areas to minimize overlap.
           v18: x range `[-0.135, 0.135]`, y range `[-0.135, 0.135]`
           
           Try to place:
           1. v8 (x-len 0.07, y-len 0.07, centered): At `(-0.09, -0.09, 0.782, 0.0)`
              World AABB: x `[-0.125, -0.055]`, y `[-0.125, -0.055]`
           
           2. v16 (x-len 0.07, y-len 0.07, local AABB x: [0.045, 0.115], y: [-0.035, 0.035]):
              Let's place it in the top left.
              `px = -0.135 - 0.045 + 0.01 = -0.17` (too small)
              `px = -0.135 + 0.01 = -0.125`. If `px = -0.125`, then x range is `(-0.125+0.045, -0.125+0.115) = (-0.08, -0.01)`.
              `py = 0.135 - 0.035 - 0.01 = 0.09`.
              Pose for v16: `(-0.125, 0.09, 0.782, 0.0)`
              World AABB: x `[-0.08, -0.01]`, y `[0.055, 0.125]`
           
           3. v14 (x-len 0.07, y-len 0.07, local AABB x: [0.015, 0.085], y: [-0.035, 0.035]):
              Let's place it in the bottom right.
              `px = 0.135 - 0.085 - 0.01 = 0.04`.
              `py = -0.135 + 0.035 + 0.01 = -0.09`.
              Pose for v14: `(0.04, -0.09, 0.782, 0.0)`
              World AABB: x `[0.055, 0.125]`, y `[-0.125, -0.055]`
           
           4. v12 (x-len 0.086, y-len 0.085, local AABB x: [0.013, 0.099], y: [0.242, 0.327]):
              Need `py` in `[-0.377, -0.192]`. Let `py = -0.2`.
              `px = 0.135 - 0.099 - 0.01 = 0.026`.
              Pose for v12: `(0.026, -0.2, 0.782, 0.0)`
              World AABB: x `[0.039, 0.125]`, y `[0.042, 0.127]`
           
           Check collisions with this new set of poses:
           v8: x `[-0.125, -0.055]`, y `[-0.125, -0.055]`
           v16: x `[-0.08, -0.01]`, y `[0.055, 0.125]`
           v14: x `[0.055, 0.125]`, y `[-0.125, -0.055]`
           v12: x `[0.039, 0.125]`, y `[0.042, 0.127]`
           
           No collisions this time! All AABBs are distinct.
           v8 (bottom-left)
           v16 (top-left)
           v14 (bottom-right)
           v12 (top-right-ish)
           
           These poses are distinct and should be collision-free. The sequence of actions remains the same.
           
           --Plan--:
           (move_base v3 #q17 #t51)
           (pick v4 v8 v9 #g5 #q17 #t42)
           (move_base #q17 #o3 #o0)
           (place v4 v8 #o2 #g5 #o3 #o4)
           (move_base #o3 #q12 #o0)
           (pick v4 v12 v13 #g4 #q12 #t33)
           (move_base #q12 #o3 #o0)
           (place v4 v12 #o2 #g4 #o3 #o4)
           (move_base #o3 #q15 #o0)
           (pick v4 v14 v15 #g7 #q15 #t36)
           (move_base #q15 #o3 #o0)
           (place v4 v14 #o2 #g7 #o3 #o4)
           (move_base #o3 #q16 #o0)
           (pick v4 v16 v17 #g6 #q16 #t41)
           (move_base #q16 #o3 #o0)
           (place v4 v16 #o2 #g6 #o3 #o4)
           
           --Poses--:
           (#o2 v8 v18): (-0.09 -0.09 0.782 0.0)
           (#o2 v12 v18): (0.026 -0.2 0.782 0.0)
           (#o2 v14 v18): (0.04 -0.09 0.782 0.0)
           (#o2 v16 v18): (-0.125 0.09 0.782 0.0)

User:      Pose #o2 = (0.026 -0.2 0.782 0.0) for object v12 on surface v18 is not stable, as the 2D AABB of the object (AABB(lower=(-0.0089999994635582, -0.23500000298023224), upper=(0.061000000536441806, -0.16500000298023224))) is not contained in the 2D AABB of the surface (AABB(lower=(-0.135, -0.135), upper=(0.135, 0.135))). Make sure your poses are in the format `(<x> <y> <z> <theta>)`.
           Pose #o2 = (-0.125 0.09 0.782 0.0) for object v16 on surface v18 is not stable, as the 2D AABB of the object (AABB(lower=(-0.16, 0.05500000357627868), upper=(-0.09, 0.1250000035762787))) is not contained in the 2D AABB of the surface (AABB(lower=(-0.135, -0.135), upper=(0.135, 0.135))). Make sure your poses are in the format `(<x> <y> <z> <theta>)`.
           Please provide a plan and poses that achieves the goal from the initial state, ensuring that all poses are valid and stable.

Model:     My sincere apologies for the continued errors in calculating stable poses. I am clearly misinterpreting how the object AABBs combine with the pose coordinates, or miscalculating the resulting world-frame AABBs. Let's re-evaluate the stability conditions very carefully.
           
           The condition for stability is:
           `object_world_AABB_min_x >= surface_AABB_min_x`
           `object_world_AABB_max_x <= surface_AABB_max_x`
           `object_world_AABB_min_y >= surface_AABB_min_y`
           `object_world_AABB_max_y <= surface_AABB_max_y`
           
           Where `object_world_AABB_min_x = pose_x + object_local_AABB_min_x`, etc.
           
           Surface v18 AABB: `((-0.135, -0.135), (0.135, 0.135))`
           
           Let's re-examine each object.
           
           **1. Object v8:**
           Local AABB: `((-0.035, -0.035), (0.035, 0.035))`
           Length in x: 0.07, Length in y: 0.07
           
           Conditions for `pose_x` for v8:
           `pose_x - 0.035 >= -0.135  => pose_x >= -0.1`
           `pose_x + 0.035 <= 0.135   => pose_x <= 0.1`
           So, `pose_x` for v8 must be in `[-0.1, 0.1]`.
           
           Conditions for `pose_y` for v8:
           `pose_y - 0.035 >= -0.135  => pose_y >= -0.1`
           `pose_y + 0.035 <= 0.135   => pose_y <= 0.1`
           So, `pose_y` for v8 must be in `[-0.1, 0.1]`.
           
           Let's pick `pose_x = -0.09`, `pose_y = -0.09`.
           World AABB: `(-0.09 - 0.035, -0.09 + 0.035)` = `(-0.125, -0.055)` (x)
           `(-0.09 - 0.035, -0.09 + 0.035)` = `(-0.125, -0.055)` (y)
           This is entirely contained within `v18`'s AABB. This pose for v8 seems correct.
           
           **2. Object v12:**
           Local AABB: `((0.013, 0.242), (0.099, 0.327))`
           Length in x: 0.086, Length in y: 0.085
           
           Conditions for `pose_x` for v12:
           `pose_x + 0.013 >= -0.135  => pose_x >= -0.148`
           `pose_x + 0.099 <= 0.135   => pose_x <= 0.036`
           So, `pose_x` for v12 must be in `[-0.148, 0.036]`.
           
           Conditions for `pose_y` for v12:
           `pose_y + 0.242 >= -0.135  => pose_y >= -0.377`
           `pose_y + 0.327 <= 0.135   => pose_y <= -0.192`
           So, `pose_y` for v12 must be in `[-0.377, -0.192]`.
           
           The previous pose for v12 was `(0.026, -0.2, 0.782, 0.0)`.
           Let's check it:
           `pose_x = 0.026` (within `[-0.148, 0.036]`) - OK.
           `pose_y = -0.2` (within `[-0.377, -0.192]`) - OK.
           World AABB for `v12` at `(0.026, -0.2)`:
           x: `(0.026 + 0.013, 0.026 + 0.099)` = `(0.039, 0.125)`
           y: `(-0.2 + 0.242, -0.2 + 0.327)` = `(0.042, 0.127)`
           The error message was `AABB(lower=(-0.0089999994635582, -0.23500000298023224), upper=(0.061000000536441806, -0.16500000298023224))) is not contained in the 2D AABB of the surface`.
           This AABB given in the error message for v12 is `(px+min_x, px+max_x, py+min_y, py+max_y) = (0.026 + 0.013, 0.026 + 0.099, -0.2 + 0.242, -0.2 + 0.327) = (0.039, 0.125, 0.042, 0.127)`.
           The AABB given in the error message is DIFFERENT from what I calculated and what seems to be implied by the local AABB.
           `lower=(-0.0089999994635582, -0.23500000298023224)` implies `px+min_x = -0.009` and `py+min_y = -0.235`.
           If `px=0.026`, then `min_x = -0.035`. If `py=-0.2`, then `min_y = -0.035`.
           This AABB `((-0.009, -0.235), (0.061, -0.165))` seems to be for an object centered at (0,0) with AABB `((-0.035,-0.035), (0.035,0.035))`, which matches `v8`, not `v12`.
           This indicates there might be an issue with how the system applies the local AABB to object v12, or the local AABB for v12 in my prompt is for a different purpose than collision checking.
           Given the previous solution failure and the current error message, it is likely the object's `type` AABB might be used for collision checking for `v12` (e.g. `v8`'s AABB being used for `v12` due to an error in the system, or just a generic AABB for "objects").
           Let's assume the error message provides the correct AABB used by the checker.
           If the AABB for `v12` in collision check is `((-0.035, -0.035), (0.035, 0.035))` (like v8), then:
           `pose_x >= -0.1`, `pose_x <= 0.1`
           `pose_y >= -0.1`, `pose_y <= 0.1`
           And if the pose was `(0.026, -0.2)`:
           `px = 0.026` is fine. `py = -0.2` is NOT fine (since it must be in `[-0.1, 0.1]`).
           This explains why `v12` was deemed unstable.
           
           **3. Object v16:**
           Local AABB: `((0.045, -0.035), (0.115, 0.035))`
           Length in x: 0.07, Length in y: 0.07
           
           Conditions for `pose_x` for v16:
           `pose_x + 0.045 >= -0.135  => pose_x >= -0.18`
           `pose_x + 0.115 <= 0.135   => pose_x <= 0.02`
           So, `pose_x` for v16 must be in `[-0.18, 0.02]`.
           
           Conditions for `pose_y` for v16:
           `pose_y - 0.035 >= -0.135  => pose_y >= -0.1`
           `pose_y + 0.035 <= 0.135   => pose_y <= 0.1`
           So, `pose_y` for v16 must be in `[-0.1, 0.1]`.
           
           The previous pose for v16 was `(-0.125, 0.09, 0.782, 0.0)`.
           Let's check it:
           `pose_x = -0.125` (within `[-0.18, 0.02]`) - OK.
           `pose_y = 0.09` (within `[-0.1, 0.1]`) - OK.
           World AABB for `v16` at `(-0.125, 0.09)`:
           x: `(-0.125 + 0.045, -0.125 + 0.115)` = `(-0.08, -0.01)`
           y: `(0.09 - 0.035, 0.09 + 0.035)` = `(0.055, 0.125)`
           The error message for v16 was `AABB(lower=(-0.16, 0.05500000357627868), upper=(-0.09, 0.1250000035762787))) is not contained in the 2D AABB of the surface`.
           My calculation: x-range `(-0.08, -0.01)`. Error message x-range: `(-0.16, -0.09)`.
           This implies that the `min_x` used in the error message is `(-0.16 - (-0.125)) = -0.035` and `max_x` is `(-0.09 - (-0.125)) = 0.035`.
           This again suggests that the system is using the AABB `((-0.035, -0.035), (0.035, 0.035))` for `v16`, which is the AABB for `v8` (a generic centered small object).
           
           **Conclusion from error messages:** The system seems to be using a generic AABB for all objects for collision checking, specifically `((-0.035, -0.035), (0.035, 0.035))`, which is the AABB of `v8`.
           So, the safe `px, py` range for *all* objects is `[-0.1, 0.1]`.
           Let's re-calculate with this assumption.
           
           All objects must be placed with `pose_x` in `[-0.1, 0.1]` and `pose_y` in `[-0.1, 0.1]`.
           Surface `v18` effectively has a usable area of `(-0.1, -0.1)` to `(0.1, 0.1)` for object *centers*.
           Each object has a world AABB of `(pose_x-0.035, pose_x+0.035)` for x and `(pose_y-0.035, pose_y+0.035)` for y.
           To ensure non-collision, objects must be separated by at least `0.035+0.035 = 0.07` in either x or y.
           
           Let's place them in a small grid:
           1.  **v8:** `(-0.06, -0.06, 0.782, 0.0)`
               World AABB: x `(-0.095, -0.025)`, y `(-0.095, -0.025)`
           2.  **v12:** `(-0.06, 0.06, 0.782, 0.0)`
               World AABB: x `(-0.095, -0.025)`, y `(0.025, 0.095)`
               (This is below v16. v12 needs to be up-left from v8)
           3.  **v14:** `(0.06, -0.06, 0.782, 0.0)`
               World AABB: x `(0.025, 0.095)`, y `(-0.095, -0.025)`
           4.  **v16:** `(0.06, 0.06, 0.782, 0.0)`
               World AABB: x `(0.025, 0.095)`, y `(0.025, 0.095)`
           
           All these poses are within the `[-0.1, 0.1]` range for `px` and `py`.
           Now check for overlaps with this generic AABB:
           v8: `x[-0.095, -0.025], y[-0.095, -0.025]`
           v12: `x[-0.095, -0.025], y[0.025, 0.095]`
           v14: `x[0.025, 0.095], y[-0.095, -0.025]`
           v16: `x[0.025, 0.095], y[0.025, 0.095]`
           
           All these ranges are distinct and do not overlap. This should work given the implied generic AABB for all objects.
           
           --Plan--:
           (move_base v3 #q17 #t51)
           (pick v4 v8 v9 #g5 #q17 #t42)
           (move_base #q17 #o3 #o0)
           (place v4 v8 #o2 #g5 #o3 #o4)
           (move_base #o3 #q12 #o0)
           (pick v4 v12 v13 #g4 #q12 #t33)
           (move_base #q12 #o3 #o0)
           (place v4 v12 #o2 #g4 #o3 #o4)
           (move_base #o3 #q15 #o0)
           (pick v4 v14 v15 #g7 #q15 #t36)
           (move_base #q15 #o3 #o0)
           (place v4 v14 #o2 #g7 #o3 #o4)
           (move_base #o3 #q16 #o0)
           (pick v4 v16 v17 #g6 #q16 #t41)
           (move_base #q16 #o3 #o0)
           (place v4 v16 #o2 #g6 #o3 #o4)
           
           --Poses--:
           (#o2 v8 v18): (-0.06 -0.06 0.782 0.0)
           (#o2 v12 v18): (-0.06 0.06 0.782 0.0)
           (#o2 v14 v18): (0.06 -0.06 0.782 0.0)
           (#o2 v16 v18): (0.06 0.06 0.782 0.0)

