User:      Here is a list of objects present in this scene for this task: 
           
           ```
           #o0: object
           #o1: object
           #o2: object
           #o3: object
           #o4: object
           v10: object
           v11: object
           v12: object
           v13: object
           v14: object
           v15: object
           v16: object
           v17: object
           v18: object
           v3: object
           v4: object
           v5: object
           v6: object
           v7: object
           v8: object
           v9: object
           ```
           
           The initial state is given by the following facts: 
           
           ```
           Atom aconf(v6, v7)
           Atom ataconf(v4, v5)
           Atom pose(v8, v9)
           Atom handempty(v6)
           Atom atpose(v15, v16)
           Atom atbconf(v3)
           Atom graspable(v12)
           Atom pose(v12, v13)
           Atom stackable(v15, v10)
           Atom type(v12, v17)
           Atom atpose(v8, v9)
           Atom canmove()
           Atom handempty(v4)
           Atom ataconf(v6, v7)
           Atom arm(v4)
           Atom arm(v6)
           Atom type(v8, v17)
           Atom graspable(v8)
           Atom atpose(v12, v13)
           Atom stackable(v8, v10)
           Atom stackable(v12, v18)
           Atom stackable(v12, v10)
           Atom graspable(v15)
           Atom controllable(v4)
           Atom pose(v15, v16)
           Atom supported(v15, v16, v11)
           Atom supported(v12, v13, v14)
           Atom bconf(v3)
           Atom aconf(v4, v5)
           Atom supported(v8, v9, v11)
           Atom stackable(v8, v18)
           Atom btraj(#o0)
           Atom basemotion(v3, #o0, v3)
           Atom pose(v8, #o2)
           Atom supported(v8, #o2, v18)
           Atom grasp(v15, #o1)
           Atom pose(v12, #o2)
           Atom supported(v12, #o2, v18)
           Atom supported(v12, #o2, v10)
           Atom supported(v8, #o2, v10)
           Atom pose(v15, #o2)
           Atom supported(v15, #o2, v10)
           Atom grasp(v8, #o1)
           Atom grasp(v12, #o1)
           Atom bconf(#o3)
           Atom atraj(#o4)
           Atom kin(v4, v15, v16, #o1, #o3, #o4)
           Atom kin(v4, v15, #o2, #o1, #o3, #o4)
           Atom kin(v4, v8, v9, #o1, #o3, #o4)
           Atom kin(v4, v8, #o2, #o1, #o3, #o4)
           Atom kin(v4, v12, v13, #o1, #o3, #o4)
           Atom kin(v4, v12, #o2, #o1, #o3, #o4)
           ```
           
           The goal expression is `Atom new-axiom@0()`. Given these elements, the list of available action instances is:
           
           ```
           ((move_base v3 v3 #o0))
           ```
           
           Please provide a plan that achieves the goal from the initial state.

Model:     The scene contains several objects, `v3` to `v18`, and continuous parameters like `#o0`, `#o1`, `#o2`, `#o3`, and `#o4`.
           The robot has two arms, `v4` and `v6`, and both are currently empty. The robot's base is at `v3`.
           There are three graspable and stackable objects: `v8`, `v12`, and `v15`.
           `v15` is at pose `v16` and supported by `v11`.
           `v12` is at pose `v13` and supported by `v14`.
           `v8` is at pose `v9` and supported by `v11`.
           
           The goal `new-axiom@0()` can be satisfied if `on(?green, v18)` and `type(?green, v17)` are true for some object `?green`.
           From the initial state, we know `type(v12, v17)` and `type(v8, v17)`. So, `?green` could be `v12` or `v8`.
           To satisfy `on(?green, v18)`, we need `supported(?green, ?p, v18)` and `atpose(?green, ?p)`.
           Looking at the initial state, `supported(v8, #o2, v18)` and `supported(v12, #o2, v18)` are given, as well as `pose(v8, #o2)` and `pose(v12, #o2)`.
           However, `atpose(v8, #o2)` and `atpose(v12, #o2)` are not explicitly stated. Instead, we have `atpose(v8, v9)` and `atpose(v12, v13)`.
           This means that neither `v8` nor `v12` are currently on `v18`.
           
           The only available action instance is `(move_base v3 v3 #o0)`. This action moves the robot's base from `v3` to `v3` using trajectory `#o0`. This action doesn't change the state of any object in terms of being "on" a surface. It also requires `canmove()` as a precondition, which is true in the initial state. However, after the action, `canmove()` becomes false, and `atbconf(v3)` is still true. The cost increases, but it doesn't help achieve the goal.
           
           Since the goal requires an object (`v8` or `v12`) of type `v17` to be on `v18`, and there are no `pick` or `place` actions available to move these objects to `v18`, the goal is unreachable with the given actions. The `move_base` action does not affect the `on` predicate.
           
           The goal `new-axiom@0()` implies `on(?green, v18)` where `type(?green, v17)`. We have objects `v8` and `v12` that are of type `v17`. To achieve `on(v8, v18)` or `on(v12, v18)`, we would need to pick one of these objects and place it on `v18`. However, there are no `pick` or `place` action instances available in the provided list. The only available action is `move_base`, which cannot change the `on` predicate for any object. Therefore, the goal is unreachable.

