User:      Here is a list of objects present in this scene for this task: 
           
           ```
           #o0: object
           #o1: object
           #o2: object
           #o3: object
           #o4: object
           #o5: object
           v1: object
           v10: object
           v11: object
           v12: object
           v13: object
           v14: object
           v15: object
           v16: object
           v17: object
           v18: object
           v19: object
           v2: object
           v3: object
           v4: object
           v5: object
           v6: object
           v7: object
           v8: object
           v9: object
           ```
           
           Some of the objects represent continuous values that have already been computed. In particular:
           Object v15 is a base configuration with (x, y, theta) = (-1.0, -1.75, 0.0).
           Object v9 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-2.405, -2.346), (-1.395, -1.654)).
           Object v5 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((0.368, -2.107), (0.507, -1.967)).
           Object v3 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((0.826, 0.828), (0.917, 0.918)).
           Object v13 is a base configuration with (x, y, theta) = (1.0, -1.75, 3.142).
           Object v18 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((0.405, 1.972), (0.493, 2.06)).
           Object v19 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((2.093, 1.863), (2.177, 1.947)).
           Object v17 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-2.223, 2.148), (-2.136, 2.235)).
           Object v7 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-1.427, 0.846), (-1.319, 0.954)).
           Object v4 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((1.025, 1.866), (1.127, 1.967)).
           Object v14 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-1.187, -1.929), (-0.821, -1.571)).
           Object v12 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((0.821, -1.929), (1.187, -1.571)).
           Object v8 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-0.492, 0.148), (-0.376, 0.264)).
           Object v1 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((1.162, 1.477), (1.259, 1.574)).
           
           You *must* use these values to select actions that are more likely to be executable (e.g., objects that are not obstructed by others) and that will have the least cost (e.g., objects that are closer to the robot or to the target region).
           
           The initial state is given by the following facts: 
           
           ```
           Atom conf(v14, v15)
           Atom onboard(v10, v14)
           Atom rover(v14)
           Atom rock(v7)
           Atom free(v14, v16)
           Atom lander(v9)
           Atom rock(v5)
           Atom type(v8, v6)
           Atom atconf(v12, v13)
           Atom objective(v19)
           Atom conf(v12, v13)
           Atom objective(v17)
           Atom rock(v8)
           Atom camera(v10)
           Atom store(v16)
           Atom rock(v4)
           Atom type(v4, v2)
           Atom mode(v11)
           Atom supports(v10, v11)
           Atom rock(v3)
           Atom objective(v18)
           Atom rover(v12)
           Atom rock(v1)
           Atom free(v12, v16)
           Atom type(v1, v2)
           Atom atconf(v14, v15)
           Atom onboard(v10, v12)
           Atom type(v3, v2)
           Atom type(v7, v6)
           Atom type(v5, v6)
           Atom above(v12, #o5, v1)
           Atom conf(v12, #o5)
           Atom comvisible(v12, #o0, #o1, v9)
           Atom comrange(v12, #o0, v9)
           Atom conf(v12, #o0)
           Atom ray(#o1)
           Atom imagevisible(v12, #o3, #o4, v18)
           Atom imagerange(v12, #o3, v18)
           Atom conf(v12, #o3)
           Atom ray(#o4)
           Atom above(v12, #o5, v3)
           Atom above(v12, #o5, v8)
           Atom imagevisible(v12, #o3, #o4, v17)
           Atom imagerange(v12, #o3, v17)
           Atom motion(v12, v13, #o2, v13)
           Atom motion(v14, v15, #o2, v15)
           Atom above(v12, #o5, v7)
           Atom imagevisible(v12, #o3, #o4, v19)
           Atom imagerange(v12, #o3, v19)
           Atom above(v14, #o5, v8)
           Atom conf(v14, #o5)
           Atom above(v14, #o5, v1)
           Atom above(v14, #o5, v7)
           Atom imagevisible(v14, #o3, #o4, v17)
           Atom imagerange(v14, #o3, v17)
           Atom conf(v14, #o3)
           Atom imagevisible(v14, #o3, #o4, v19)
           Atom imagerange(v14, #o3, v19)
           Atom comvisible(v14, #o0, #o1, v9)
           Atom comrange(v14, #o0, v9)
           Atom conf(v14, #o0)
           Atom above(v14, #o5, v3)
           Atom imagevisible(v14, #o3, #o4, v18)
           Atom imagerange(v14, #o3, v18)
           Atom above(v12, #o5, v5)
           Atom above(v14, #o5, v5)
           Atom above(v12, #o5, v4)
           Atom above(v14, #o5, v4)
           Atom motion(v14, v15, #o2, #o3)
           Atom motion(v14, #o3, #o2, v15)
           Atom motion(v14, #o3, #o2, #o3)
           Atom motion(v14, #o0, #o2, v15)
           Atom motion(v14, v15, #o2, #o0)
           Atom motion(v14, #o0, #o2, #o3)
           Atom motion(v14, #o0, #o2, #o0)
           Atom motion(v14, #o3, #o2, #o0)
           Atom motion(v12, #o3, #o2, v13)
           Atom motion(v12, v13, #o2, #o3)
           Atom motion(v12, #o3, #o2, #o3)
           Atom motion(v14, #o5, #o2, v15)
           Atom motion(v14, #o5, #o2, #o3)
           Atom motion(v14, #o5, #o2, #o5)
           Atom motion(v14, #o3, #o2, #o5)
           Atom motion(v14, #o5, #o2, #o0)
           Atom motion(v14, v15, #o2, #o5)
           Atom motion(v14, #o0, #o2, #o5)
           Atom motion(v12, #o0, #o2, #o3)
           Atom motion(v12, #o3, #o2, #o0)
           Atom motion(v12, v13, #o2, #o0)
           Atom motion(v12, #o0, #o2, v13)
           Atom motion(v12, #o0, #o2, #o0)
           Atom motion(v12, #o5, #o2, v13)
           Atom motion(v12, #o5, #o2, #o5)
           Atom motion(v12, #o5, #o2, #o0)
           Atom motion(v12, #o5, #o2, #o3)
           Atom motion(v12, #o3, #o2, #o5)
           Atom motion(v12, #o0, #o2, #o5)
           Atom motion(v12, v13, #o2, #o5)
           ```
           
           The goal expression is `Atom new-axiom@0()`. Given these elements, the list of available action instances is:
           
           ```
           ((sample_rock v12 #o5 v1 v16))
           ((sample_rock v12 #o5 v3 v16))
           ((sample_rock v12 #o5 v4 v16))
           ((sample_rock v12 #o5 v5 v16))
           ((sample_rock v12 #o5 v7 v16))
           ((sample_rock v12 #o5 v8 v16))
           ((sample_rock v14 #o5 v1 v16))
           ((sample_rock v14 #o5 v3 v16))
           ((sample_rock v14 #o5 v4 v16))
           ((sample_rock v14 #o5 v5 v16))
           ((sample_rock v14 #o5 v7 v16))
           ((sample_rock v14 #o5 v8 v16))
           ((move v12 #o0 #o2 #o0))
           ((move v12 #o0 #o2 #o3))
           ((move v12 #o0 #o2 #o5))
           ((move v12 #o0 #o2 v13))
           ((move v12 #o3 #o2 #o0))
           ((move v12 #o3 #o2 #o3))
           ((move v12 #o3 #o2 #o5))
           ((move v12 #o3 #o2 v13))
           ((move v12 #o5 #o2 #o0))
           ((move v12 #o5 #o2 #o3))
           ((move v12 #o5 #o2 #o5))
           ((move v12 #o5 #o2 v13))
           ((move v12 v13 #o2 #o0))
           ((move v12 v13 #o2 #o3))
           ((move v12 v13 #o2 #o5))
           ((move v12 v13 #o2 v13))
           ((move v14 #o0 #o2 #o0))
           ((move v14 #o0 #o2 #o3))
           ((move v14 #o0 #o2 #o5))
           ((move v14 #o0 #o2 v15))
           ((move v14 #o3 #o2 #o0))
           ((move v14 #o3 #o2 #o3))
           ((move v14 #o3 #o2 #o5))
           ((move v14 #o3 #o2 v15))
           ((move v14 #o5 #o2 #o0))
           ((move v14 #o5 #o2 #o3))
           ((move v14 #o5 #o2 #o5))
           ((move v14 #o5 #o2 v15))
           ((move v14 v15 #o2 #o0))
           ((move v14 v15 #o2 #o3))
           ((move v14 v15 #o2 #o5))
           ((move v14 v15 #o2 v15))
           ((calibrate v12 #o3 #o4 v17 v10))
           ((calibrate v12 #o3 #o4 v18 v10))
           ((calibrate v12 #o3 #o4 v19 v10))
           ((calibrate v14 #o3 #o4 v17 v10))
           ((calibrate v14 #o3 #o4 v18 v10))
           ((calibrate v14 #o3 #o4 v19 v10))
           ((take_image v12 #o3 #o4 v17 v10 v11))
           ((take_image v12 #o3 #o4 v18 v10 v11))
           ((take_image v12 #o3 #o4 v19 v10 v11))
           ((take_image v14 #o3 #o4 v17 v10 v11))
           ((take_image v14 #o3 #o4 v18 v10 v11))
           ((take_image v14 #o3 #o4 v19 v10 v11))
           ((drop_rock v12 v16))
           ((send_analysis v12 #o0 #o1 v9 v1))
           ((send_analysis v12 #o0 #o1 v9 v3))
           ((send_analysis v12 #o0 #o1 v9 v4))
           ((send_analysis v12 #o0 #o1 v9 v5))
           ((send_analysis v12 #o0 #o1 v9 v7))
           ((send_analysis v12 #o0 #o1 v9 v8))
           ((drop_rock v14 v16))
           ((send_analysis v14 #o0 #o1 v9 v1))
           ((send_analysis v14 #o0 #o1 v9 v3))
           ((send_analysis v14 #o0 #o1 v9 v4))
           ((send_analysis v14 #o0 #o1 v9 v5))
           ((send_analysis v14 #o0 #o1 v9 v7))
           ((send_analysis v14 #o0 #o1 v9 v8))
           ((send_image v12 #o0 #o1 v9 v17 v11))
           ((send_image v12 #o0 #o1 v9 v18 v11))
           ((send_image v12 #o0 #o1 v9 v19 v11))
           ((send_image v14 #o0 #o1 v9 v17 v11))
           ((send_image v14 #o0 #o1 v9 v18 v11))
           ((send_image v14 #o0 #o1 v9 v19 v11))
           ```
           
           Please provide a plan that achieves the goal from the initial state.

(Thoughts: **Final Plan Summary & Continuous Values**
           
           My primary goal is to achieve `new-axiom@0()`, a complex task requiring both image acquisition and rock analysis. The core challenges revolve around coordinating two rovers, v12 and v14, while adhering to spatial constraints and ensuring that specific conditions within the problem state remain valid throughout. The key initial facts are that v12 is at configuration v13, v14 is at v15, that certain objects are free, the rovers are onboard and have cameras that support the image mode, and the `imagevisible` and `comvisible` predicates hold true (meaning the robots can see the objectives and communicate with the lander). The task demands that the two rovers successfully image specific objectives (v17, v18, and v19) using their onboard cameras in a particular mode (v11), analyze a 'stone' of type v2 (object v4) and a 'soil' of type v6 (object v8), and communicate these analyses to the lander (v9).
           
           **Here's the planned strategy:**
           
           I'm dividing the task between the two rovers to improve efficiency. Rover v12, initially at config v13, will focus on imaging, while rover v14, initially at v15, will handle rock analysis and communication.
           
           **Rover v12 - Imaging and Communication**
           
           1.  **Move to Imaging Configuration**: `move(v12, v13, #o2, #o3)`
           2.  **Calibrate for Image Acquisition**: `calibrate(v12, #o3, #o4, v17, v10)`. (The value for `v10` is given already.)
           3.  **Take Image**: `take_image(v12, #o3, #o4, v17, v10, v11)`.
           4.  **Repeat steps 2-3 for v18**
           5.  **Repeat steps 2-3 for v19**
           6.  **Move to Communication Configuration**: `move(v12, #o3, #o2, #o0)`
           7.  **Send Images**: `send_image(v12, #o0, #o1, v9, v17, v11)`, `send_image(v12, #o0, #o1, v9, v18, v11)`, `send_image(v12, #o0, #o1, v9, v19, v11)`.
           8.  **Return to Initial Configuration**: `move(v12, #o0, #o2, v13)`
           
           **Rover v14 - Rock Analysis and Communication**
           
           1.  **Move to Analysis Configuration**: `move(v14, v15, #o2, #o5)`
           2.  **Sample and Analyze Stone**: `sample_rock(v14, #o5, v4, v16)`
           3.  **Drop Stone**: `drop_rock(v14, v16)` (To make store `free` for the second rock sample)
           4.  **Sample and Analyze Soil**: `sample_rock(v14, #o5, v8, v16)`
           5.  **Drop Soil**: `drop_rock(v14, v16)` (To make store `free` for return move, otherwise the analysis won't be sent)
           6.  **Move to Communication Configuration**: `move(v14, #o5, #o2, #o0)`
           7.  **Send Analysis**: `send_analysis(v14, #o0, #o1, v9, v4)`, `send_analysis(v14, #o0, #o1, v9, v8)`
           8.  **Return to Initial Configuration**: `move(v14, #o0, #o2, v15)`
           
           For this plan, the *critical values* that need to be provided are continuous positions of the rovers (`conf` values) and the rays from them to objects. The rule states: "If your plan uses some object #<name> ... then you must provide a continuous value ... such that ... occlusion-free line-of-sight to the target object in the fourth argument in the `imagevisible` or `comvisible` predicate".
           
           Based on that instruction, the geometry may not be perfectly satisfied, but the `imagevisible` facts are given in the initial state so I proceed with the following values that meet the criteria of my understanding of the prompt and the geometric interpretation:
           
           *   
)

Model:     **Final Plan Summary & Continuous Values**
           
           My primary goal is to achieve `new-axiom@0()`, a complex task requiring both image acquisition and rock analysis. The core challenges revolve around coordinating two rovers, v12 and v14, while adhering to spatial constraints and ensuring that specific conditions within the problem state remain valid throughout. The key initial facts are that v12 is at configuration v13, v14 is at v15, that certain objects are free, the rovers are onboard and have cameras that support the image mode, and the `imagevisible` and `comvisible` predicates hold true (meaning the robots can see the objectives and communicate with the lander). The task demands that the two rovers successfully image specific objectives (v17, v18, and v19) using their onboard cameras in a particular mode (v11), analyze a 'stone' of type v2 (object v4) and a 'soil' of type v6 (object v8), and communicate these analyses to the lander (v9).
           
           **Here's the planned strategy:**
           
           I'm dividing the task between the two rovers to improve efficiency. Rover v12, initially at config v13, will focus on imaging, while rover v14, initially at v15, will handle rock analysis and communication.
           
           **Rover v12 - Imaging and Communication**
           
           1.  **Move to Imaging Configuration**: `move(v12, v13, #o2, #o3)`
           2.  **Calibrate for Image Acquisition**: `calibrate(v12, #o3, #o4, v17, v10)`. (The value for `v10` is given already.)
           3.  **Take Image**: `take_image(v12, #o3, #o4, v17, v10, v11)`.
           4.  **Repeat steps 2-3 for v18**
           5.  **Repeat steps 2-3 for v19**
           6.  **Move to Communication Configuration**: `move(v12, #o3, #o2, #o0)`
           7.  **Send Images**: `send_image(v12, #o0, #o1, v9, v17, v11)`, `send_image(v12, #o0, #o1, v9, v18, v11)`, `send_image(v12, #o0, #o1, v9, v19, v11)`.
           8.  **Return to Initial Configuration**: `move(v12, #o0, #o2, v13)`
           
           **Rover v14 - Rock Analysis and Communication**
           
           1.  **Move to Analysis Configuration**: `move(v14, v15, #o2, #o5)`
           2.  **Sample and Analyze Stone**: `sample_rock(v14, #o5, v4, v16)`
           3.  **Drop Stone**: `drop_rock(v14, v16)` (To make store `free` for the second rock sample)
           4.  **Sample and Analyze Soil**: `sample_rock(v14, #o5, v8, v16)`
           5.  **Drop Soil**: `drop_rock(v14, v16)` (To make store `free` for return move, otherwise the analysis won't be sent)
           6.  **Move to Communication Configuration**: `move(v14, #o5, #o2, #o0)`
           7.  **Send Analysis**: `send_analysis(v14, #o0, #o1, v9, v4)`, `send_analysis(v14, #o0, #o1, v9, v8)`
           8.  **Return to Initial Configuration**: `move(v14, #o0, #o2, v15)`
           
           For this plan, the *critical values* that need to be provided are continuous positions of the rovers (`conf` values) and the rays from them to objects. The rule states: "If your plan uses some object #<name> ... then you must provide a continuous value ... such that ... occlusion-free line-of-sight to the target object in the fourth argument in the `imagevisible` or `comvisible` predicate".
           
           Based on that instruction, the geometry may not be perfectly satisfied, but the `imagevisible` facts are given in the initial state so I proceed with the following values that meet the criteria of my understanding of the prompt and the geometric interpretation:
           
           *   

