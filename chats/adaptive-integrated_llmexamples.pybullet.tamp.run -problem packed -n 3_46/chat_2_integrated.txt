User:      Here is a list of objects present in this scene for this task: 
           
           ```
           #o0: object
           #o1: object
           #o2: object
           #o3: object
           #o4: object
           v10: object
           v11: object
           v12: object
           v13: object
           v14: object
           v15: object
           v16: object
           v3: object
           v4: object
           v5: object
           v6: object
           v7: object
           v8: object
           v9: object
           ```
           
           Some of the objects represent continuous values that have already been computed. In particular:
           Object v7 is an arm configuration with joint values (-2.135, 1.296, -3.75, -0.15, -10000.0, -0.1, -10000.0).
           Object v13 is a pose with position (-0.207, 0.534, 0.781) and quaternion (0.0, 0.0, 0.88, 0.475).
           Object v11 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-0.3, -0.6), (0.3, 0.6)).
           Object v8 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-0.13, -0.506), (-0.031, -0.407)).
           Object v5 is an arm configuration with joint values (0.677, -0.343, 1.2, -1.467, 1.242, -1.954, 2.223).
           Object v16 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-0.135, -0.135), (0.135, 0.135)).
           Object v3 is a base configuration with (x, y, theta) = (-1.0, 0.0, 0.0).
           Object v14 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-0.242, -0.587), (-0.147, -0.491)).
           Object v9 is a pose with position (-0.08, -0.457, 0.781) and quaternion (0.0, 0.0, 0.925, -0.381).
           Object v12 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-0.256, 0.485), (-0.159, 0.582)).
           Object v15 is a pose with position (-0.195, -0.539, 0.781) and quaternion (0.0, 0.0, 0.968, 0.25).
           
           You *must* use these values to select actions that are more likely to be executable (e.g., objects that are not obstructed by others) and that will have the least cost (e.g., objects that are closer to the robot or to the target region).
           
           The initial state is given by the following facts: 
           
           ```
           Atom graspable(v12)
           Atom handempty(v6)
           Atom stackable(v14, v10)
           Atom graspable(v14)
           Atom supported(v14, v15, v11)
           Atom aconf(v4, v5)
           Atom stackable(v8, v16)
           Atom aconf(v6, v7)
           Atom stackable(v12, v16)
           Atom atpose(v12, v13)
           Atom atpose(v14, v15)
           Atom canmove()
           Atom ataconf(v4, v5)
           Atom stackable(v12, v10)
           Atom arm(v4)
           Atom pose(v14, v15)
           Atom ataconf(v6, v7)
           Atom atbconf(v3)
           Atom pose(v12, v13)
           Atom stackable(v14, v16)
           Atom controllable(v4)
           Atom atpose(v8, v9)
           Atom bconf(v3)
           Atom supported(v12, v13, v11)
           Atom handempty(v4)
           Atom supported(v8, v9, v11)
           Atom graspable(v8)
           Atom arm(v6)
           Atom stackable(v8, v10)
           Atom pose(v8, v9)
           Atom grasp(v8, #o1)
           Atom pose(v8, #o2)
           Atom supported(v8, #o2, v10)
           Atom btraj(#o0)
           Atom basemotion(v3, #o0, v3)
           Atom pose(v14, #o2)
           Atom supported(v14, #o2, v16)
           Atom grasp(v12, #o1)
           Atom grasp(v14, #o1)
           Atom pose(v12, #o2)
           Atom supported(v12, #o2, v16)
           Atom supported(v14, #o2, v10)
           Atom supported(v8, #o2, v16)
           Atom supported(v12, #o2, v10)
           Atom bconf(#o3)
           Atom atraj(#o4)
           Atom kin(v4, v8, v9, #o1, #o3, #o4)
           Atom kin(v4, v8, #o2, #o1, #o3, #o4)
           Atom kin(v4, v12, v13, #o1, #o3, #o4)
           Atom kin(v4, v14, v15, #o1, #o3, #o4)
           Atom kin(v4, v14, #o2, #o1, #o3, #o4)
           Atom kin(v4, v12, #o2, #o1, #o3, #o4)
           Atom basemotion(v3, #o0, #o3)
           Atom basemotion(#o3, #o0, #o3)
           Atom basemotion(#o3, #o0, v3)
           ```
           
           The goal expression is `Conjunction
               Atom on(v8, v16)
               Atom on(v12, v16)
               Atom on(v14, v16)`. Given these elements, the list of available action instances is:
           
           ```
           ((move_base #o3 #o3 #o0))
           ((move_base #o3 v3 #o0))
           ((move_base v3 #o3 #o0))
           ((move_base v3 v3 #o0))
           ((pick v4 v12 #o2 #o1 #o3 #o4))
           ((place v4 v12 #o2 #o1 #o3 #o4))
           ((pick v4 v12 v13 #o1 #o3 #o4))
           ((place v4 v12 v13 #o1 #o3 #o4))
           ((pick v4 v14 #o2 #o1 #o3 #o4))
           ((place v4 v14 #o2 #o1 #o3 #o4))
           ((pick v4 v14 v15 #o1 #o3 #o4))
           ((place v4 v14 v15 #o1 #o3 #o4))
           ((pick v4 v8 #o2 #o1 #o3 #o4))
           ((place v4 v8 #o2 #o1 #o3 #o4))
           ((pick v4 v8 v9 #o1 #o3 #o4))
           ((place v4 v8 v9 #o1 #o3 #o4))
           ```
           
           Please provide a plan that achieves the goal from the initial state.

Model:     The scene contains three objects (v12, v14, v8) that need to be placed on v16. Currently, v12 is at pose v13, v14 is at pose v15, and v8 is at pose v9. All these initial poses are supported by v11. The goal requires all three objects to be supported by v16. The robot arm v4 is currently at arm configuration v5, and its hand is empty. The base is at configuration v3.
           
           The plan involves picking up each object from its initial position and placing it on v16. Since there are three objects and only one arm (v4) is specified as controllable and empty, we'll need to perform three pick and three place operations. The continuous parameter #o2 represents a pose on v16. We will need to define a unique collision-free pose for each object on v16. The robot also needs to move its base to a configuration (#o3) that allows it to reach the objects, and then move back to v3. However, since the current base configuration `v3` is given, and the kin relations state that the arm can reach the object from a base configuration `#o3`, we should compute a base configuration `#o3` that enables the pick and place operations, and then use `move_base` actions to move to and from this configuration.
           
           Looking at the AABBs:
           - v11 (table): ((-0.3, -0.6), (0.3, 0.6))
           - v16 (target surface): ((-0.135, -0.135), (0.135, 0.135))
           
           The objects are:
           - v12: ((-0.256, 0.485), (-0.159, 0.582))
           - v14: ((-0.242, -0.587), (-0.147, -0.491))
           - v8: ((-0.13, -0.506), (-0.031, -0.407))
           
           Since v16 is a smaller surface, we need to carefully place the objects to avoid collisions and ensure stability. The target poses must be within the bounds of v16. We also need to account for the z-coordinate to place them on top of the surface. We will define specific collision-free poses for each object on `v16`. Since the goal is `on(object, v16)`, the `supported` predicate is `supported(?o, #o2, v16)`.
           
           Let's assume the z-coordinate for placing objects on v16 is 0.781 (same as the initial poses, implying v16 is at this height).
           
           For object v8 (AABB: ((-0.13, -0.506), (-0.031, -0.407))), we can place it on v16 (AABB: ((-0.135, -0.135), (0.135, 0.135))) at a pose like (-0.08, -0.08, 0.781, 0.0).
           For object v12 (AABB: ((-0.256, 0.485), (-0.159, 0.582))), we can place it on v16 at a pose like (0.0, 0.08, 0.781, 0.0).
           For object v14 (AABB: ((-0.242, -0.587), (-0.147, -0.491))), we can place it on v16 at a pose like (0.08, -0.08, 0.781, 0.0).
           
           These positions are chosen to be within the bounds of v16 and also to ensure they don't overlap with each other.
           
           The `basemotion(v3, #o0, v3)` action in the initial state suggests we can move the base without cost to some intermediate configuration and return, but the cost is defined for `distance(?q1, ?q2)`. So, the `move_base` actions that return to the original configuration will incur cost if `q1` and `q2` are different. We will use `move_base v3 #o3 #o0` to move the robot to a position where it can reach the objects and then `move_base #o3 v3 #o0` to return to the initial configuration. Since there are three objects to pick and place, we'll need to move to the appropriate base configuration for each pick and place pair. For simplicity, we can assume a single base configuration #o3 works for all pick and place operations, or that #o3 is close to v3, resulting in minimal distance.
           
           Given that `atbconf(v3)` is true initially, we will start by moving to `#o3`. Then, we perform the pick and place for each object.
           
           --Plan--:
           (move_base v3 #o3 #o0)
           (pick v4 v12 v13 #o1 #o3 #o4)
           (place v4 v12 #o2 #o1 #o3 #o4)
           (pick v4 v14 v15 #o1 #o3 #o4)
           (place v4 v14 #o2 #o1 #o3 #o4)
           (pick v4 v8 v9 #o1 #o3 #o4)
           (place v4 v8 #o2 #o1 #o3 #o4)
           (move_base #o3 v3 #o0)
           
           --Poses--:
           (#o2 v12 v16): (0.0 0.08 0.781 0.0)
           (#o2 v14 v16): (0.08 -0.08 0.781 0.0)
           (#o2 v8 v16): (-0.08 -0.08 0.781 0.0)

