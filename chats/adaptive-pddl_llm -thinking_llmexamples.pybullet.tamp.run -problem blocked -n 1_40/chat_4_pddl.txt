User:      Here is a list of objects present in this scene for this task: 
           
           ```
           #g0: object
           #o0: object
           #o1: object
           #o2: object
           #o3: object
           #o4: object
           #p0: object
           #q0: object
           #q1: object
           #t0: object
           #t1: object
           #t2: object
           #t3: object
           v10: object
           v11: object
           v12: object
           v13: object
           v14: object
           v15: object
           v16: object
           v17: object
           v18: object
           v3: object
           v4: object
           v5: object
           v6: object
           v7: object
           v8: object
           v9: object
           ```
           
           The initial state is given by the following facts: 
           
           ```
           Atom type(v8, v17)
           Atom graspable(v15)
           Atom canmove()
           Atom aconf(v4, v5)
           Atom stackable(v12, v18)
           Atom stackable(v15, v10)
           Atom aconf(v6, v7)
           Atom supported(v12, v13, v14)
           Atom stackable(v8, v18)
           Atom controllable(v4)
           Atom atpose(v8, v9)
           Atom pose(v12, v13)
           Atom pose(v8, v9)
           Atom stackable(v8, v10)
           Atom handempty(v4)
           Atom supported(v8, v9, v11)
           Atom atbconf(v3)
           Atom graspable(v12)
           Atom arm(v6)
           Atom stackable(v12, v10)
           Atom pose(v15, v16)
           Atom supported(v15, v16, v11)
           Atom atpose(v12, v13)
           Atom bconf(v3)
           Atom handempty(v6)
           Atom graspable(v8)
           Atom ataconf(v4, v5)
           Atom type(v12, v17)
           Atom arm(v4)
           Atom ataconf(v6, v7)
           Atom atpose(v15, v16)
           Atom grasp(v15, #o1)
           Atom pose(v15, #o2)
           Atom supported(v15, #o2, v10)
           Atom pose(v8, #o2)
           Atom supported(v8, #o2, v10)
           Atom grasp(v8, #o1)
           Atom pose(v12, #p0)
           Atom supported(v12, #p0, v18)
           Atom btraj(#o0)
           Atom basemotion(v3, #o0, v3)
           Atom pose(v12, #o2)
           Atom supported(v12, #o2, v10)
           Atom supported(v8, #o2, v18)
           Atom grasp(v12, #g0)
           Atom bconf(#q0)
           Atom atraj(#t0)
           Atom kin(v4, v12, v13, #g0, #q0, #t0)
           Atom bconf(#q1)
           Atom atraj(#t2)
           Atom kin(v4, v12, #p0, #g0, #q1, #t2)
           Atom btraj(#t1)
           Atom basemotion(v3, #t1, #q0)
           Atom basemotion(#q0, #o0, #q0)
           Atom basemotion(#q0, #o0, v3)
           Atom basemotion(#q1, #o0, #q0)
           Atom basemotion(#q1, #o0, v3)
           Atom btraj(#t3)
           Atom basemotion(#q0, #t3, #q1)
           Atom basemotion(#q1, #o0, #q1)
           Atom basemotion(v3, #o0, #q1)
           Atom bconf(#o3)
           Atom atraj(#o4)
           Atom kin(v4, v15, v16, #o1, #o3, #o4)
           Atom kin(v4, v8, #o2, #o1, #o3, #o4)
           Atom kin(v4, v8, v9, #o1, #o3, #o4)
           Atom kin(v4, v12, #o2, #g0, #o3, #o4)
           Atom kin(v4, v15, #o2, #o1, #o3, #o4)
           Atom basemotion(#o3, #o0, v3)
           Atom basemotion(#q0, #o0, #o3)
           Atom basemotion(#o3, #o0, #o3)
           Atom basemotion(v3, #o0, #o3)
           Atom basemotion(#o3, #o0, #q1)
           Atom basemotion(#o3, #o0, #q0)
           Atom basemotion(#q1, #o0, #o3)
           ```
           
           The goal expression is `Atom new-axiom@0()`. Given these elements, the list of available action instances is:
           
           ```
           ((move_base #o3 #o3 #o0))
           ((move_base #o3 #q0 #o0))
           ((move_base #o3 #q1 #o0))
           ((move_base #o3 v3 #o0))
           ((move_base #q0 #o3 #o0))
           ((move_base #q0 #q0 #o0))
           ((move_base #q0 v3 #o0))
           ((move_base #q0 #q1 #t3))
           ((move_base #q1 #o3 #o0))
           ((move_base #q1 #q0 #o0))
           ((move_base #q1 #q1 #o0))
           ((move_base #q1 v3 #o0))
           ((move_base v3 #o3 #o0))
           ((move_base v3 #q1 #o0))
           ((move_base v3 v3 #o0))
           ((move_base v3 #q0 #t1))
           ((pick v4 v12 #o2 #g0 #o3 #o4))
           ((place v4 v12 #o2 #g0 #o3 #o4))
           ((pick v4 v12 #p0 #g0 #q1 #t2))
           ((place v4 v12 #p0 #g0 #q1 #t2))
           ((pick v4 v12 v13 #g0 #q0 #t0))
           ((place v4 v12 v13 #g0 #q0 #t0))
           ((pick v4 v15 #o2 #o1 #o3 #o4))
           ((place v4 v15 #o2 #o1 #o3 #o4))
           ((pick v4 v15 v16 #o1 #o3 #o4))
           ((place v4 v15 v16 #o1 #o3 #o4))
           ((pick v4 v8 #o2 #o1 #o3 #o4))
           ((place v4 v8 #o2 #o1 #o3 #o4))
           ((pick v4 v8 v9 #o1 #o3 #o4))
           ((place v4 v8 v9 #o1 #o3 #o4))
           ```
           
           Please provide a plan that achieves the goal from the initial state.

(Thoughts: **Planning to Achieve `new-axiom@0()`**
           
           Okay, so the task at hand is to generate a plan to satisfy `new-axiom@0()`, which translates to the conjunctive goal: `on(?green, v18) ∧ type(?green, v17)`. The thing is, `?green` is a variable, so we're looking for *some* object that fulfills these criteria.
           
           I've examined the initial state and can see a few candidates: `v8` and `v12`, both of which have the required `type(v*, v17)`.  I've also noticed that `v12` is *stackable* on `v18`.  Since *we need to get one of these objects to be on the v18 object,* `v12` would work. The plan seems to be to get `v12` onto `v18`.
           
           Currently, `v12` is located at pose `v13`. Looking at the available actions, it seems that I must pick this object, then place it on the intended v18 object.
           
           To actually make this happen, I'll need to use some `move_base` actions to go to a location `q0` (the initial base configuration seems to be `v3`, but the 'q0' pose is needed to pick up the object at its initial pose - which will move `q0` to `q1`, as that seems to be the place where `v12` must be placed), pick up the object `v12` from its current pose `v13` (making sure that there is no unsafety or the grasp is unsafe), and place the object at pose `#p0` on top of the intended object `v18`.
           
           After confirming all the preconditions, I think I have a solid plan:
           
           1.  `move_base v3 q0`
           2.  `pick v4 v12 v13 g0 q0`
           3.  `move_base q0 q1`
           4.  `place v4 v12 #p0 g0 q1`
           
           This plan should successfully manipulate `v12` so that the goal is achieved. It takes into consideration the configuration required by the grasp and pick, and the base motions necessary to pick and place.
           
)

Model:     **Planning to Achieve `new-axiom@0()`**
           
           Okay, so the task at hand is to generate a plan to satisfy `new-axiom@0()`, which translates to the conjunctive goal: `on(?green, v18) ∧ type(?green, v17)`. The thing is, `?green` is a variable, so we're looking for *some* object that fulfills these criteria.
           
           I've examined the initial state and can see a few candidates: `v8` and `v12`, both of which have the required `type(v*, v17)`.  I've also noticed that `v12` is *stackable* on `v18`.  Since *we need to get one of these objects to be on the v18 object,* `v12` would work. The plan seems to be to get `v12` onto `v18`.
           
           Currently, `v12` is located at pose `v13`. Looking at the available actions, it seems that I must pick this object, then place it on the intended v18 object.
           
           To actually make this happen, I'll need to use some `move_base` actions to go to a location `q0` (the initial base configuration seems to be `v3`, but the 'q0' pose is needed to pick up the object at its initial pose - which will move `q0` to `q1`, as that seems to be the place where `v12` must be placed), pick up the object `v12` from its current pose `v13` (making sure that there is no unsafety or the grasp is unsafe), and place the object at pose `#p0` on top of the intended object `v18`.
           
           After confirming all the preconditions, I think I have a solid plan:
           
           1.  `move_base v3 q0`
           2.  `pick v4 v12 v13 g0 q0`
           3.  `move_base q0 q1`
           4.  `place v4 v12 #p0 g0 q1`
           
           This plan should successfully manipulate `v12` so that the goal is achieved. It takes into consideration the configuration required by the grasp and pick, and the base motions necessary to pick and place.
           

