User:      Here is a list of objects present in this scene for this task: 
           
           ```
           #o0: object
           #o1: object
           #o2: object
           #o3: object
           #o4: object
           #o5: object
           v1: object
           v10: object
           v11: object
           v12: object
           v13: object
           v14: object
           v15: object
           v16: object
           v17: object
           v18: object
           v19: object
           v2: object
           v3: object
           v4: object
           v5: object
           v6: object
           v7: object
           v8: object
           v9: object
           ```
           
           The initial state is given by the following facts: 
           
           ```
           Atom atconf(v12, v13)
           Atom conf(v12, v13)
           Atom free(v14, v16)
           Atom rock(v4)
           Atom rover(v14)
           Atom type(v5, v6)
           Atom free(v12, v16)
           Atom onboard(v10, v14)
           Atom store(v16)
           Atom rock(v7)
           Atom type(v7, v6)
           Atom atconf(v14, v15)
           Atom camera(v10)
           Atom objective(v18)
           Atom rock(v1)
           Atom type(v8, v6)
           Atom rock(v8)
           Atom mode(v11)
           Atom supports(v10, v11)
           Atom type(v1, v2)
           Atom conf(v14, v15)
           Atom rock(v3)
           Atom lander(v9)
           Atom objective(v19)
           Atom objective(v17)
           Atom rover(v12)
           Atom type(v3, v2)
           Atom type(v4, v2)
           Atom rock(v5)
           Atom onboard(v10, v12)
           Atom motion(v12, v13, #o2, v13)
           Atom imagevisible(v12, #o3, #o4, v18)
           Atom imagerange(v12, #o3, v18)
           Atom conf(v12, #o3)
           Atom ray(#o4)
           Atom above(v12, #o5, v5)
           Atom conf(v12, #o5)
           Atom imagevisible(v12, #o3, #o4, v17)
           Atom imagerange(v12, #o3, v17)
           Atom imagevisible(v12, #o3, #o4, v19)
           Atom imagerange(v12, #o3, v19)
           Atom comvisible(v12, #o0, #o1, v9)
           Atom comrange(v12, #o0, v9)
           Atom conf(v12, #o0)
           Atom ray(#o1)
           Atom above(v12, #o5, v3)
           Atom imagevisible(v14, #o3, #o4, v18)
           Atom imagerange(v14, #o3, v18)
           Atom conf(v14, #o3)
           Atom above(v14, #o5, v3)
           Atom conf(v14, #o5)
           Atom above(v14, #o5, v5)
           Atom imagevisible(v14, #o3, #o4, v19)
           Atom imagerange(v14, #o3, v19)
           Atom comvisible(v14, #o0, #o1, v9)
           Atom comrange(v14, #o0, v9)
           Atom conf(v14, #o0)
           Atom imagevisible(v14, #o3, #o4, v17)
           Atom imagerange(v14, #o3, v17)
           Atom above(v14, #o5, v4)
           Atom above(v12, #o5, v4)
           Atom above(v14, #o5, v7)
           Atom above(v12, #o5, v7)
           Atom motion(v14, v15, #o2, v15)
           Atom above(v12, #o5, v8)
           Atom above(v14, #o5, v8)
           Atom above(v12, #o5, v1)
           Atom above(v14, #o5, v1)
           Atom motion(v12, v13, #o2, #o0)
           Atom motion(v12, #o0, #o2, v13)
           Atom motion(v12, #o0, #o2, #o0)
           Atom motion(v12, v13, #o2, #o5)
           Atom motion(v12, #o0, #o2, #o5)
           Atom motion(v12, #o5, #o2, #o5)
           Atom motion(v12, #o5, #o2, #o0)
           Atom motion(v12, #o5, #o2, v13)
           Atom motion(v12, #o5, #o2, #o3)
           Atom motion(v12, #o3, #o2, #o5)
           Atom motion(v12, #o0, #o2, #o3)
           Atom motion(v12, #o3, #o2, #o0)
           Atom motion(v12, v13, #o2, #o3)
           Atom motion(v12, #o3, #o2, v13)
           Atom motion(v12, #o3, #o2, #o3)
           Atom motion(v14, v15, #o2, #o0)
           Atom motion(v14, #o0, #o2, #o0)
           Atom motion(v14, #o0, #o2, v15)
           Atom motion(v14, #o5, #o2, #o5)
           Atom motion(v14, #o0, #o2, #o5)
           Atom motion(v14, #o5, #o2, v15)
           Atom motion(v14, #o5, #o2, #o0)
           Atom motion(v14, v15, #o2, #o5)
           Atom motion(v14, v15, #o2, #o3)
           Atom motion(v14, #o3, #o2, #o0)
           Atom motion(v14, #o3, #o2, #o5)
           Atom motion(v14, #o5, #o2, #o3)
           Atom motion(v14, #o0, #o2, #o3)
           Atom motion(v14, #o3, #o2, #o3)
           Atom motion(v14, #o3, #o2, v15)
           ```
           
           The goal expression is `Atom new-axiom@0()`. Given these elements, the list of available action instances is:
           
           ```
           ((sample_rock v12 #o5 v1 v16))
           ((sample_rock v12 #o5 v3 v16))
           ((sample_rock v12 #o5 v4 v16))
           ((sample_rock v12 #o5 v5 v16))
           ((sample_rock v12 #o5 v7 v16))
           ((sample_rock v12 #o5 v8 v16))
           ((sample_rock v14 #o5 v1 v16))
           ((sample_rock v14 #o5 v3 v16))
           ((sample_rock v14 #o5 v4 v16))
           ((sample_rock v14 #o5 v5 v16))
           ((sample_rock v14 #o5 v7 v16))
           ((sample_rock v14 #o5 v8 v16))
           ((move v12 #o0 #o2 #o0))
           ((move v12 #o0 #o2 #o3))
           ((move v12 #o0 #o2 #o5))
           ((move v12 #o0 #o2 v13))
           ((move v12 #o3 #o2 #o0))
           ((move v12 #o3 #o2 #o3))
           ((move v12 #o3 #o2 #o5))
           ((move v12 #o3 #o2 v13))
           ((move v12 #o5 #o2 #o0))
           ((move v12 #o5 #o2 #o3))
           ((move v12 #o5 #o2 #o5))
           ((move v12 #o5 #o2 v13))
           ((move v12 v13 #o2 #o0))
           ((move v12 v13 #o2 #o3))
           ((move v12 v13 #o2 #o5))
           ((move v12 v13 #o2 v13))
           ((move v14 #o0 #o2 #o0))
           ((move v14 #o0 #o2 #o3))
           ((move v14 #o0 #o2 #o5))
           ((move v14 #o0 #o2 v15))
           ((move v14 #o3 #o2 #o0))
           ((move v14 #o3 #o2 #o3))
           ((move v14 #o3 #o2 #o5))
           ((move v14 #o3 #o2 v15))
           ((move v14 #o5 #o2 #o0))
           ((move v14 #o5 #o2 #o3))
           ((move v14 #o5 #o2 #o5))
           ((move v14 #o5 #o2 v15))
           ((move v14 v15 #o2 #o0))
           ((move v14 v15 #o2 #o3))
           ((move v14 v15 #o2 #o5))
           ((move v14 v15 #o2 v15))
           ((calibrate v12 #o3 #o4 v17 v10))
           ((calibrate v12 #o3 #o4 v18 v10))
           ((calibrate v12 #o3 #o4 v19 v10))
           ((calibrate v14 #o3 #o4 v17 v10))
           ((calibrate v14 #o3 #o4 v18 v10))
           ((calibrate v14 #o3 #o4 v19 v10))
           ((take_image v12 #o3 #o4 v17 v10 v11))
           ((take_image v12 #o3 #o4 v18 v10 v11))
           ((take_image v12 #o3 #o4 v19 v10 v11))
           ((take_image v14 #o3 #o4 v17 v10 v11))
           ((take_image v14 #o3 #o4 v18 v10 v11))
           ((take_image v14 #o3 #o4 v19 v10 v11))
           ((drop_rock v12 v16))
           ((send_analysis v12 #o0 #o1 v9 v1))
           ((send_analysis v12 #o0 #o1 v9 v3))
           ((send_analysis v12 #o0 #o1 v9 v4))
           ((send_analysis v12 #o0 #o1 v9 v5))
           ((send_analysis v12 #o0 #o1 v9 v7))
           ((send_analysis v12 #o0 #o1 v9 v8))
           ((drop_rock v14 v16))
           ((send_analysis v14 #o0 #o1 v9 v1))
           ((send_analysis v14 #o0 #o1 v9 v3))
           ((send_analysis v14 #o0 #o1 v9 v4))
           ((send_analysis v14 #o0 #o1 v9 v5))
           ((send_analysis v14 #o0 #o1 v9 v7))
           ((send_analysis v14 #o0 #o1 v9 v8))
           ((send_image v12 #o0 #o1 v9 v17 v11))
           ((send_image v12 #o0 #o1 v9 v18 v11))
           ((send_image v12 #o0 #o1 v9 v19 v11))
           ((send_image v14 #o0 #o1 v9 v17 v11))
           ((send_image v14 #o0 #o1 v9 v18 v11))
           ((send_image v14 #o0 #o1 v9 v19 v11))
           ```
           
           Please provide a plan that achieves the goal from the initial state.

Model:     The scene contains two rovers (v12, v14), a lander (v9), a camera (v10), a storage unit (v16), and several rocks (v1, v3, v4, v5, v7, v8) and objectives (v17, v18, v19). The goal is to satisfy `new-axiom@0()`, which requires:
           1. `atconf(v12, v13)`
           2. `atconf(v14, v15)`
           3. `free(v12, v16)`
           4. `free(v14, v16)`
           5. `receivedimage(v17, v11)`
           6. `receivedimage(v18, v11)`
           7. `receivedimage(v19, v11)`
           8. `type(?stone, v2)` (implicit existence of a stone of type v2)
           9. `receivedanalysis(?stone)` (implicit existence of a stone that has been analyzed)
           10. `type(?soil, v6)` (implicit existence of soil of type v6)
           11. `receivedanalysis(?soil)` (implicit existence of soil that has been analyzed)
           
           Let's analyze the initial state and how to achieve each part of the goal:
           
           *   **`atconf(v12, v13)` and `atconf(v14, v15)`:** These are already true in the initial state.
           *   **`free(v12, v16)` and `free(v14, v16)`:** These are also true in the initial state.
           *   **`receivedimage(v17, v11)`, `receivedimage(v18, v11)`, `receivedimage(v19, v11)`:** To achieve these, a rover needs to:
               1.  Calibrate its camera.
               2.  Take an image of the objective.
               3.  Send the image to the lander.
               Rover v12 has a camera v10 onboard which supports mode v11. It can see objectives v17, v18, v19 from configuration #o3 and can communicate with lander v9 from configuration #o0.
           *   **`type(?stone, v2)` and `receivedanalysis(?stone)`:** Rocks v1, v3, v4 are of type v2 (stone). We need to sample one of them and send its analysis.
           *   **`type(?soil, v6)` and `receivedanalysis(?soil)`:** Rocks v5, v7, v8 are of type v6 (soil). We need to sample one of them and send its analysis.
           
           The plan will involve using either rover v12 or v14 to perform the image collection and analysis tasks. Since both rovers have similar capabilities and are in configurations that allow for the necessary actions, we can choose one to perform the tasks. Rover v12 is currently at v13, and has imagevisible and comvisible configurations (#o3 and #o0). It can also sample rocks from #o5.
           
           Let's use rover v12:
           1.  **Move to the configuration for imaging and communication if not already there.** Rover v12 is at v13, it needs to move to #o3 for imaging and #o0 for communication. We can prioritize the imaging tasks first. Let's assume the continuous parameters allow direct movement between relevant configurations.
           2.  **Calibrate the camera for each objective.**
           3.  **Take image of each objective.**
           4.  **Move to a communication configuration.**
           5.  **Send the images.**
           6.  **Move to a configuration above a rock for sampling.**
           7.  **Sample a rock of type v2 (stone) and a rock of type v6 (soil).**
           8.  **Send the analysis of both sampled rocks.**
           
           The available actions show that we can directly calibrate, take images, and send images/analyses from relevant configurations. The initial state doesn't show any `blocked` rays.
           
           Let's focus on Rover v12 since it's at v13 and has connections to #o0, #o3, #o5, which are configurations relevant for all actions needed.
           To get `receivedimage` for v17, v18, v19:
           - Calibrate for v17 (from #o3)
           - Take image of v17 (from #o3)
           - Calibrate for v18 (from #o3)
           - Take image of v18 (from #o3)
           - Calibrate for v19 (from #o3)
           - Take image of v19 (from #o3)
           - Move to #o0 for communication.
           - Send images of v17, v18, v19.
           
           To get `receivedanalysis` for a stone and a soil:
           - Move to #o5 for sampling.
           - Sample v1 (type v2, stone)
           - Sample v5 (type v6, soil)
           - Move to #o0 for communication.
           - Send analysis of v1
           - Send analysis of v5
           
           Combining these, we need to carefully sequence movements and actions.
           
           Current rover v12 is at v13.
           All imaging tasks need v12 at #o3.
           All sampling tasks need v12 at #o5.
           All sending tasks need v12 at #o0.
           
           Let's organize the plan to minimize movement.
           1. Move to #o3 for imaging.
           2. Calibrate and take images for all three objectives.
           3. Move to #o5 for sampling.
           4. Sample a stone and a soil.
           5. Move to #o0 for sending data.
           6. Send all three images.
           7. Send analysis of the two sampled rocks.
           
           Initial State check:
           - `atconf(v12, v13)` is true.
           
           Let's start by moving v12 to #o3.
           
           --Plan--:
           (move v12 v13 #o2 #o3)
           (calibrate v12 #o3 #o4 v17 v10)
           (take_image v12 #o3 #o4 v17 v10 v11)
           (calibrate v12 #o3 #o4 v18 v10)
           (take_image v12 #o3 #o4 v18 v10 v11)
           (calibrate v12 #o3 #o4 v19 v10)
           (take_image v12 #o3 #o4 v19 v10 v11)
           (move v12 #o3 #o2 #o5)
           (sample_rock v12 #o5 v1 v16)
           (sample_rock v12 #o5 v5 v16)
           (move v12 #o5 #o2 #o0)
           (send_image v12 #o0 #o1 v9 v17 v11)
           (send_image v12 #o0 #o1 v9 v18 v11)
           (send_image v12 #o0 #o1 v9 v19 v11)
           (send_analysis v12 #o0 #o1 v9 v1)
           (send_analysis v12 #o0 #o1 v9 v5)

User:      The plan you provided is not valid because: `Fact is not satisfied: Atom new-axiom@0()`. Recall that the action preconditions and the goal *must* be satisfied.
           
           Please provide a plan that achieves the goal from the initial state ensuring that action preconditions are satisfied and adhering to the response format.

Model:     The previous plan failed because the final goal `new-axiom@0()` was not satisfied. Let's re-examine the goal `new-axiom@0()` requirements and my proposed plan.
           
           The goal `new-axiom@0()` has 11 conditions:
           1.  `atconf(v12, v13)`: Achieved in initial state.
           2.  `atconf(v14, v15)`: Achieved in initial state.
           3.  `free(v12, v16)`: Achieved in initial state.
           4.  `free(v14, v16)`: Achieved in initial state.
           5.  `receivedimage(v17, v11)`: My plan achieves this via calibrate, take_image, send_image.
           6.  `receivedimage(v18, v11)`: My plan achieves this via calibrate, take_image, send_image.
           7.  `receivedimage(v19, v11)`: My plan achieves this via calibrate, take_image, send_image.
           8.  `type(?stone, v2)`: Satisfied by rocks v1, v3, v4. My plan samples v1.
           9.  `receivedanalysis(?stone)`: My plan samples v1 (type v2 stone) and sends analysis.
           10. `type(?soil, v6)`: Satisfied by rocks v5, v7, v8. My plan samples v5.
           11. `receivedanalysis(?soil)`: My plan samples v5 (type v6 soil) and sends analysis.
           
           The previous plan correctly addresses all these conditions. The issue might be in how `sample_rock` and `drop_rock` interact with the `free` predicate.
           The `sample_rock` action makes a store `full` and no longer `free`. The `drop_rock` action makes a store `free` again.
           The goal requires `free(v12, v16)` and `free(v14, v16)`.
           My plan includes:
           `(sample_rock v12 #o5 v1 v16)`: This makes `full(v12, v16)` and `~free(v12, v16)`.
           `(sample_rock v12 #o5 v5 v16)`: This would require `free(v12, v16)` again, which is not true after the first sample. This is the crucial mistake. A rover can only carry one sample at a time if it only has one store. Rover v12 only has store v16.
           
           To fix this, rover v12 must drop the first rock before sampling the second, or use rover v14 to sample the second rock. Since both `free(v12, v16)` and `free(v14, v16)` are required in the final state, any rocks sampled must be dropped.
           
           Let's modify the plan to account for the `free` and `full` predicates and the goal requiring *both* stores to be free *at the end*.
           
           Revised strategy:
           Use Rover v12 for all imaging and analysis tasks, dropping samples to ensure the `free` predicate is true at the end.
           
           1.  Move v12 to #o3 (for imaging).
           2.  Calibrate and take images for v17, v18, v19.
           3.  Move v12 to #o5 (for sampling).
           4.  Sample v1 (type v2, stone). This makes v12's store v16 `full`.
           5.  Move v12 to #o0 (for communication).
           6.  Send analysis of v1.
           7.  Drop v1 from v16. This makes v12's store v16 `free` again.
           8.  Move v12 back to #o5 (for sampling soil).
           9.  Sample v5 (type v6, soil). This makes v12's store v16 `full`.
           10. Move v12 to #o0 (for communication).
           11. Send analysis of v5.
           12. Drop v5 from v16. This makes v12's store v16 `free` again.
           13. Send all three images. (Can be done after the first move to #o0 as well).
           
           Let's re-sequence to minimize movements and satisfy all conditions.
           
           Initial state: `atconf(v12, v13)`, `atconf(v14, v15)`, `free(v12, v16)`, `free(v14, v16)`.
           
           Plan:
           1.  Rover v12 moves to #o3 (imaging configuration).
           2.  Rover v12 calibrates and takes images of v17, v18, v19.
           3.  Rover v12 moves to #o5 (sampling configuration).
           4.  Rover v12 samples rock v1 (stone). `free(v12, v16)` becomes `full(v12, v16)`.
           5.  Rover v12 moves to #o0 (communication configuration).
           6.  Rover v12 sends analysis for v1.
           7.  Rover v12 drops rock v1. `full(v12, v16)` becomes `free(v12, v16)`.
           8.  Rover v12 moves back to #o5 (sampling configuration) to sample soil.
           9.  Rover v12 samples rock v5 (soil). `free(v12, v16)` becomes `full(v12, v16)`.
           10. Rover v12 moves to #o0 (communication configuration).
           11. Rover v12 sends analysis for v5.
           12. Rover v12 drops rock v5. `full(v12, v16)` becomes `free(v12, v16)`.
           13. Rover v12 sends images for v17, v18, v19.
           
           This sequence ensures `free(v12, v16)` is true at the end and both analyses and images are sent.
           
           --Plan--:
           (move v12 v13 #o2 #o3)
           (calibrate v12 #o3 #o4 v17 v10)
           (take_image v12 #o3 #o4 v17 v10 v11)
           (calibrate v12 #o3 #o4 v18 v10)
           (take_image v12 #o3 #o4 v18 v10 v11)
           (calibrate v12 #o3 #o4 v19 v10)
           (take_image v12 #o3 #o4 v19 v10 v11)
           (move v12 #o3 #o2 #o5)
           (sample_rock v12 #o5 v1 v16)
           (move v12 #o5 #o2 #o0)
           (send_analysis v12 #o0 #o1 v9 v1)
           (drop_rock v12 v16)
           (move v12 #o0 #o2 #o5)
           (sample_rock v12 #o5 v5 v16)
           (move v12 #o5 #o2 #o0)
           (send_analysis v12 #o0 #o1 v9 v5)
           (drop_rock v12 v16)
           (send_image v12 #o0 #o1 v9 v17 v11)
           (send_image v12 #o0 #o1 v9 v18 v11)
           (send_image v12 #o0 #o1 v9 v19 v11)

User:      The plan you provided is not valid because: `Fact is not satisfied: Atom new-axiom@0()`. Recall that the action preconditions and the goal *must* be satisfied.
           
           Please provide a plan that achieves the goal from the initial state ensuring that action preconditions are satisfied and adhering to the response format.

Model:     The plan was still reported as invalid because the goal `new-axiom@0()` was not satisfied. Let's re-evaluate the components of `new-axiom@0()` and the current state.
           
           The goal `new-axiom@0()` requires:
           1.  `atconf(v12, v13)` (true initially)
           2.  `atconf(v14, v15)` (true initially)
           3.  `free(v12, v16)` (true initially, but becomes false after `sample_rock`, must be true at goal)
           4.  `free(v14, v16)` (true initially)
           5.  `receivedimage(v17, v11)`
           6.  `receivedimage(v18, v11)`
           7.  `receivedimage(v19, v11)`
           8.  `type(?stone, v2)` (satisfied by v1, v3, v4)
           9.  `receivedanalysis(?stone)`
           10. `type(?soil, v6)` (satisfied by v5, v7, v8)
           11. `receivedanalysis(?soil)`
           
           My previous plan correctly included `drop_rock` actions to ensure `free(v12, v16)` is true at the end. The initial state already provides `atconf(v12, v13)` and `atconf(v14, v15)` and `free(v14, v16)`. So, the remaining challenges are:
           *   Ensure `receivedimage` for v17, v18, v19.
           *   Ensure `receivedanalysis` for a stone (type v2) and a soil (type v6).
           *   Ensure `free(v12, v16)` at the end.
           
           Let's double check the `receivedanalysis` and `receivedimage` parts.
           The plan correctly identifies rocks v1 (type v2, stone) and v5 (type v6, soil) and takes samples, sends analysis, and drops them.
           The plan also correctly identifies objectives v17, v18, v19 and takes images and sends them.
           
           Could the issue be that Rover v14 is not used, and `new-axiom@0()` implicitly requires both rovers to somehow contribute, or that the specific objects chosen for `?stone` and `?soil` are not recognized? The axiom definitions use `?stone` and `?soil` as variables, meaning *any* rock of type v2 and *any* rock of type v6. So, v1 and v5 are valid choices.
           
           One possible error source is the continuous parameters. I am using `#o0`, `#o2`, `#o3`, `#o4`, `#o5` as defined in the initial state and valid actions. These should be correctly instantiated by the underlying system.
           
           Let's assume the continuous parameters are valid. The problem must be in the logical flow or state changes.
           The `calibrate` action makes `calibrated(?c, ?v)` true. The `take_image` action consumes `calibrated(?c, ?v)`. So, we need to calibrate *before each* `take_image` or ensure the camera is calibrated for each shot. The current plan re-calibrates for each objective, which is correct.
           
           Let's verify the goal again:
           `atconf(v12, v13)` - Yes, initially, and rover 12 moves around. The final state of rover 12 is at #o0. But the goal needs it to be at v13. This is a critical point. The rover must end up at v13.
           `atconf(v14, v15)` - Yes, initially, and rover 14 does not move.
           `free(v12, v16)` - My plan ensures this by dropping rocks.
           `free(v14, v16)` - Yes, initially.
           
           The problem likely lies with `atconf(v12, v13)`. My plan moves `v12` to `#o0` for sending the last data, and leaves it there. It needs to move back to `v13`.
           
           Revised Plan:
           1.  Rover v12 moves to #o3 (imaging configuration).
           2.  Rover v12 calibrates and takes images of v17, v18, v19.
           3.  Rover v12 moves to #o5 (sampling configuration).
           4.  Rover v12 samples rock v1 (stone).
           5.  Rover v12 moves to #o0 (communication configuration).
           6.  Rover v12 sends analysis for v1.
           7.  Rover v12 drops rock v1.
           8.  Rover v12 moves back to #o5 (sampling configuration) to sample soil.
           9.  Rover v12 samples rock v5 (soil).
           10. Rover v12 moves to #o0 (communication configuration).
           11. Rover v12 sends analysis for v5.
           12. Rover v12 drops rock v5.
           13. Rover v12 sends images for v17, v18, v19.
           14. **Rover v12 moves back to v13.**
           
           This should satisfy all conditions.
           
           --Plan--:
           (move v12 v13 #o2 #o3)
           (calibrate v12 #o3 #o4 v17 v10)
           (take_image v12 #o3 #o4 v17 v10 v11)
           (calibrate v12 #o3 #o4 v18 v10)
           (take_image v12 #o3 #o4 v18 v10 v11)
           (calibrate v12 #o3 #o4 v19 v10)
           (take_image v12 #o3 #o4 v19 v10 v11)
           (move v12 #o3 #o2 #o5)
           (sample_rock v12 #o5 v1 v16)
           (move v12 #o5 #o2 #o0)
           (send_analysis v12 #o0 #o1 v9 v1)
           (drop_rock v12 v16)
           (move v12 #o0 #o2 #o5)
           (sample_rock v12 #o5 v5 v16)
           (move v12 #o5 #o2 #o0)
           (send_analysis v12 #o0 #o1 v9 v5)
           (drop_rock v12 v16)
           (send_image v12 #o0 #o1 v9 v17 v11)
           (send_image v12 #o0 #o1 v9 v18 v11)
           (send_image v12 #o0 #o1 v9 v19 v11)
           (move v12 #o0 #o2 v13)

