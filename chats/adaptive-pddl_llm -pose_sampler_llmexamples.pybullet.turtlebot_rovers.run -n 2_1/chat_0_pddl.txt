User:      The robot can only be placed within the following limits for (x, y, theta):
           x: [-2.5, 2.5], y: [-2.5, 2.5], theta: [-inf, inf]
           
           New request:
           
           Target point: {target_point}. Please provide a valid placement for the robot base (x y) within the max distance 2 from the target point. 

Model:     The scene is enclosed by walls at x = -2.5, x = 2.5, y = -2.5, and y = 2.5. There's a central vertical wall at x = 0. There are also several smaller rectangular obstacles scattered around. My goal is to find 3 robot base positions within a distance of 2 from the target point that avoid collisions with these fixed obstacles and provide line-of-sight. Given the target point is {target_point}, I will try to find positions that are within the allowed x and y limits and consider the known obstacles.
           
           Positions:
           ({target_point[0] + 1.5} {target_point[1]})
           ({target_point[0] - 1.5} {target_point[1]})
           ({target_point[0]} {target_point[1] + 1.5})

User:      The robot can only be placed within the following limits for (x, y, theta):
           x: [-2.5, 2.5], y: [-2.5, 2.5], theta: [-inf, inf]
           
           New request:
           
           Target point: {target_point}. Please provide a valid placement for the robot base (x y) within the max distance 2 from the target point. 

Model:     The scene is enclosed by walls at x = -2.5, x = 2.5, y = -2.5, and y = 2.5. There's a central vertical wall at x = 0. There are also several smaller rectangular obstacles scattered around. My goal is to find 3 robot base positions within a distance of 2 from the target point that avoid collisions with these fixed obstacles and provide line-of-sight. Given the target point is {target_point}, I will try to find positions that are within the allowed x and y limits and consider the known obstacles.
           
           Positions:
           ({target_point[0] + 1.5} {target_point[1]})
           ({target_point[0] - 1.5} {target_point[1]})
           ({target_point[0]} {target_point[1] + 1.5})

