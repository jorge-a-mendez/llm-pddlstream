User:      Here is a list of objects present in this scene for this task: 
           
           ```
           #o0: object
           #o1: object
           #o2: object
           #o3: object
           #o4: object
           #o5: object
           #q0: object
           #q1: object
           #q2: object
           #q3: object
           #q4: object
           #q5: object
           #t0: object
           #t1: object
           #t2: object
           #t3: object
           #t4: object
           #t5: object
           #t6: object
           #t7: object
           #y0: object
           #y1: object
           #y2: object
           #y3: object
           v1: object
           v10: object
           v11: object
           v12: object
           v13: object
           v14: object
           v15: object
           v16: object
           v17: object
           v18: object
           v19: object
           v2: object
           v3: object
           v4: object
           v5: object
           v6: object
           v7: object
           v8: object
           v9: object
           ```
           
           The initial state is given by the following facts: 
           
           ```
           Atom camera(v10)
           Atom type(v3, v2)
           Atom atconf(v14, v15)
           Atom type(v8, v6)
           Atom conf(v14, v15)
           Atom rock(v1)
           Atom objective(v17)
           Atom rover(v14)
           Atom conf(v12, v13)
           Atom rock(v7)
           Atom free(v14, v16)
           Atom rover(v12)
           Atom type(v1, v2)
           Atom mode(v11)
           Atom objective(v18)
           Atom rock(v4)
           Atom atconf(v12, v13)
           Atom supports(v10, v11)
           Atom onboard(v10, v12)
           Atom store(v16)
           Atom type(v5, v6)
           Atom rock(v3)
           Atom rock(v8)
           Atom type(v7, v6)
           Atom type(v4, v2)
           Atom rock(v5)
           Atom onboard(v10, v14)
           Atom lander(v9)
           Atom objective(v19)
           Atom free(v12, v16)
           Atom above(v12, #o5, v3)
           Atom conf(v12, #o5)
           Atom imagevisible(v12, #q0, #y0, v19)
           Atom imagerange(v12, #q0, v19)
           Atom conf(v12, #q0)
           Atom ray(#y0)
           Atom above(v12, #q5, v5)
           Atom conf(v12, #q5)
           Atom above(v12, #q2, v1)
           Atom conf(v12, #q2)
           Atom imagevisible(v12, #q3, #y2, v18)
           Atom imagerange(v12, #q3, v18)
           Atom conf(v12, #q3)
           Atom ray(#y2)
           Atom above(v12, #o5, v4)
           Atom comvisible(v12, #q1, #y1, v9)
           Atom comrange(v12, #q1, v9)
           Atom conf(v12, #q1)
           Atom ray(#y1)
           Atom above(v12, #o5, v8)
           Atom above(v12, #o5, v7)
           Atom motion(v12, v13, #o2, v13)
           Atom motion(v14, v15, #o2, v15)
           Atom above(v14, #o5, v5)
           Atom conf(v14, #o5)
           Atom above(v14, #o5, v1)
           Atom above(v14, #o5, v7)
           Atom above(v14, #o5, v8)
           Atom above(v14, #o5, v3)
           Atom imagevisible(v14, #o3, #o4, v18)
           Atom imagerange(v14, #o3, v18)
           Atom conf(v14, #o3)
           Atom ray(#o4)
           Atom comvisible(v14, #o0, #o1, v9)
           Atom comrange(v14, #o0, v9)
           Atom conf(v14, #o0)
           Atom ray(#o1)
           Atom imagevisible(v14, #o3, #o4, v19)
           Atom imagerange(v14, #o3, v19)
           Atom above(v14, #o5, v4)
           Atom imagevisible(v14, #o3, #o4, v17)
           Atom imagerange(v14, #o3, v17)
           Atom imagevisible(v12, #q4, #y3, v17)
           Atom imagerange(v12, #q4, v17)
           Atom conf(v12, #q4)
           Atom ray(#y3)
           Atom motion(v12, #q0, #o2, #q0)
           Atom motion(v12, #q0, #o2, v13)
           Atom motion(v12, v13, #t4, #q0)
           Atom motion(v12, #q0, #t2, #q1)
           Atom motion(v12, v13, #o2, #q1)
           Atom motion(v12, #q1, #o2, #q1)
           Atom motion(v12, #q1, #t7, v13)
           Atom motion(v12, #q1, #o2, #q0)
           Atom motion(v12, #q0, #o2, #q4)
           Atom motion(v12, #q4, #o2, #q1)
           Atom motion(v12, #q1, #o2, #q4)
           Atom motion(v12, #q4, #o2, #q4)
           Atom motion(v12, #q4, #o2, v13)
           Atom motion(v12, #q4, #o2, #q0)
           Atom motion(v12, v13, #t6, #q4)
           Atom motion(v12, #q0, #o2, #q3)
           Atom motion(v12, #q3, #o2, #q3)
           Atom motion(v12, #q1, #o2, #q3)
           Atom motion(v12, #q3, #o2, #q4)
           Atom motion(v12, v13, #t5, #q3)
           Atom motion(v12, #q3, #t3, #q1)
           Atom motion(v12, #q3, #o2, v13)
           Atom motion(v12, #q4, #o2, #q3)
           Atom motion(v12, #q3, #o2, #q0)
           Atom motion(v12, #q2, #o2, #q0)
           Atom motion(v12, v13, #o2, #q2)
           Atom motion(v12, #q2, #o2, #q4)
           Atom motion(v12, #q2, #o2, v13)
           Atom motion(v12, #q0, #o2, #q2)
           Atom motion(v12, #q3, #o2, #q2)
           Atom motion(v12, #q1, #t0, #q2)
           Atom motion(v12, #q2, #t1, #q1)
           Atom motion(v12, #q2, #o2, #q2)
           Atom motion(v12, #q2, #o2, #q3)
           Atom motion(v12, #q4, #o2, #q2)
           Atom motion(v12, #q5, #o2, #q0)
           Atom motion(v12, #q5, #o2, #q3)
           Atom motion(v12, #q2, #o2, #q5)
           Atom motion(v12, #q0, #o2, #q5)
           Atom motion(v12, #q5, #o2, #q4)
           Atom motion(v12, #q5, #o2, #q1)
           Atom motion(v12, v13, #o2, #q5)
           Atom motion(v12, #q5, #o2, #q2)
           Atom motion(v12, #q5, #o2, v13)
           Atom motion(v12, #q4, #o2, #q5)
           Atom motion(v12, #q3, #o2, #q5)
           Atom motion(v12, #q1, #o2, #q5)
           Atom motion(v12, #q5, #o2, #q5)
           Atom motion(v14, v15, #o2, #o5)
           Atom motion(v14, #o5, #o2, v15)
           Atom motion(v14, #o5, #o2, #o5)
           Atom motion(v12, #q3, #o2, #o5)
           Atom motion(v12, #o5, #o2, v13)
           Atom motion(v12, #o5, #o2, #o5)
           Atom motion(v12, #o5, #o2, #q3)
           Atom motion(v12, v13, #o2, #o5)
           Atom motion(v12, #q1, #o2, #o5)
           Atom motion(v12, #o5, #o2, #q2)
           Atom motion(v12, #o5, #o2, #q0)
           Atom motion(v12, #q0, #o2, #o5)
           Atom motion(v12, #q5, #o2, #o5)
           Atom motion(v12, #o5, #o2, #q4)
           Atom motion(v12, #q4, #o2, #o5)
           Atom motion(v12, #q2, #o2, #o5)
           Atom motion(v12, #o5, #o2, #q5)
           Atom motion(v12, #o5, #o2, #q1)
           Atom motion(v14, #o0, #o2, #o0)
           Atom motion(v14, #o5, #o2, #o0)
           Atom motion(v14, v15, #o2, #o0)
           Atom motion(v14, #o0, #o2, v15)
           Atom motion(v14, #o0, #o2, #o5)
           Atom motion(v14, #o3, #o2, #o5)
           Atom motion(v14, v15, #o2, #o3)
           Atom motion(v14, #o3, #o2, v15)
           Atom motion(v14, #o3, #o2, #o3)
           Atom motion(v14, #o0, #o2, #o3)
           Atom motion(v14, #o3, #o2, #o0)
           Atom motion(v14, #o5, #o2, #o3)
           ```
           
           The goal expression is `Atom new-axiom@0()`. Given these elements, the list of available action instances is:
           
           ```
           ((sample_rock v12 #o5 v3 v16))
           ((sample_rock v12 #o5 v4 v16))
           ((sample_rock v12 #o5 v7 v16))
           ((sample_rock v12 #o5 v8 v16))
           ((sample_rock v12 #q2 v1 v16))
           ((sample_rock v12 #q5 v5 v16))
           ((sample_rock v14 #o5 v1 v16))
           ((sample_rock v14 #o5 v3 v16))
           ((sample_rock v14 #o5 v4 v16))
           ((sample_rock v14 #o5 v5 v16))
           ((sample_rock v14 #o5 v7 v16))
           ((sample_rock v14 #o5 v8 v16))
           ((move v12 #o5 #o2 #o5))
           ((move v12 #o5 #o2 #q0))
           ((move v12 #o5 #o2 #q1))
           ((move v12 #o5 #o2 #q2))
           ((move v12 #o5 #o2 #q3))
           ((move v12 #o5 #o2 #q4))
           ((move v12 #o5 #o2 #q5))
           ((move v12 #o5 #o2 v13))
           ((move v12 #q0 #o2 #o5))
           ((move v12 #q0 #o2 #q0))
           ((move v12 #q0 #o2 #q2))
           ((move v12 #q0 #o2 #q3))
           ((move v12 #q0 #o2 #q4))
           ((move v12 #q0 #o2 #q5))
           ((move v12 #q0 #o2 v13))
           ((move v12 #q0 #t2 #q1))
           ((move v12 #q1 #o2 #o5))
           ((move v12 #q1 #o2 #q0))
           ((move v12 #q1 #o2 #q1))
           ((move v12 #q1 #o2 #q3))
           ((move v12 #q1 #o2 #q4))
           ((move v12 #q1 #o2 #q5))
           ((move v12 #q1 #t0 #q2))
           ((move v12 #q1 #t7 v13))
           ((move v12 #q2 #o2 #o5))
           ((move v12 #q2 #o2 #q0))
           ((move v12 #q2 #o2 #q2))
           ((move v12 #q2 #o2 #q3))
           ((move v12 #q2 #o2 #q4))
           ((move v12 #q2 #o2 #q5))
           ((move v12 #q2 #o2 v13))
           ((move v12 #q2 #t1 #q1))
           ((move v12 #q3 #o2 #o5))
           ((move v12 #q3 #o2 #q0))
           ((move v12 #q3 #o2 #q2))
           ((move v12 #q3 #o2 #q3))
           ((move v12 #q3 #o2 #q4))
           ((move v12 #q3 #o2 #q5))
           ((move v12 #q3 #o2 v13))
           ((move v12 #q3 #t3 #q1))
           ((move v12 #q4 #o2 #o5))
           ((move v12 #q4 #o2 #q0))
           ((move v12 #q4 #o2 #q1))
           ((move v12 #q4 #o2 #q2))
           ((move v12 #q4 #o2 #q3))
           ((move v12 #q4 #o2 #q4))
           ((move v12 #q4 #o2 #q5))
           ((move v12 #q4 #o2 v13))
           ((move v12 #q5 #o2 #o5))
           ((move v12 #q5 #o2 #q0))
           ((move v12 #q5 #o2 #q1))
           ((move v12 #q5 #o2 #q2))
           ((move v12 #q5 #o2 #q3))
           ((move v12 #q5 #o2 #q4))
           ((move v12 #q5 #o2 #q5))
           ((move v12 #q5 #o2 v13))
           ((move v12 v13 #o2 #o5))
           ((move v12 v13 #o2 #q1))
           ((move v12 v13 #o2 #q2))
           ((move v12 v13 #o2 #q5))
           ((move v12 v13 #o2 v13))
           ((move v12 v13 #t4 #q0))
           ((move v12 v13 #t5 #q3))
           ((move v12 v13 #t6 #q4))
           ((move v14 #o0 #o2 #o0))
           ((move v14 #o0 #o2 #o3))
           ((move v14 #o0 #o2 #o5))
           ((move v14 #o0 #o2 v15))
           ((move v14 #o3 #o2 #o0))
           ((move v14 #o3 #o2 #o3))
           ((move v14 #o3 #o2 #o5))
           ((move v14 #o3 #o2 v15))
           ((move v14 #o5 #o2 #o0))
           ((move v14 #o5 #o2 #o3))
           ((move v14 #o5 #o2 #o5))
           ((move v14 #o5 #o2 v15))
           ((move v14 v15 #o2 #o0))
           ((move v14 v15 #o2 #o3))
           ((move v14 v15 #o2 #o5))
           ((move v14 v15 #o2 v15))
           ((calibrate v12 #q0 #y0 v19 v10))
           ((calibrate v12 #q3 #y2 v18 v10))
           ((calibrate v12 #q4 #y3 v17 v10))
           ((calibrate v14 #o3 #o4 v17 v10))
           ((calibrate v14 #o3 #o4 v18 v10))
           ((calibrate v14 #o3 #o4 v19 v10))
           ((take_image v12 #q0 #y0 v19 v10 v11))
           ((take_image v12 #q3 #y2 v18 v10 v11))
           ((take_image v12 #q4 #y3 v17 v10 v11))
           ((take_image v14 #o3 #o4 v17 v10 v11))
           ((take_image v14 #o3 #o4 v18 v10 v11))
           ((take_image v14 #o3 #o4 v19 v10 v11))
           ((drop_rock v12 v16))
           ((send_analysis v12 #q1 #y1 v9 v3))
           ((send_analysis v12 #q1 #y1 v9 v4))
           ((send_analysis v12 #q1 #y1 v9 v7))
           ((send_analysis v12 #q1 #y1 v9 v8))
           ((send_analysis v12 #q1 #y1 v9 v1))
           ((send_analysis v12 #q1 #y1 v9 v5))
           ((drop_rock v14 v16))
           ((send_analysis v14 #o0 #o1 v9 v1))
           ((send_analysis v14 #o0 #o1 v9 v3))
           ((send_analysis v14 #o0 #o1 v9 v4))
           ((send_analysis v14 #o0 #o1 v9 v5))
           ((send_analysis v14 #o0 #o1 v9 v7))
           ((send_analysis v14 #o0 #o1 v9 v8))
           ((send_image v12 #q1 #y1 v9 v19 v11))
           ((send_image v12 #q1 #y1 v9 v18 v11))
           ((send_image v12 #q1 #y1 v9 v17 v11))
           ((send_image v14 #o0 #o1 v9 v17 v11))
           ((send_image v14 #o0 #o1 v9 v18 v11))
           ((send_image v14 #o0 #o1 v9 v19 v11))
           ```
           
           Please provide a plan that achieves the goal from the initial state.

Model:     The goal `new-axiom@0()` represents a complex state that requires several sub-goals to be met:
           1.  `atconf(v12, v13)`: Rover v12 must be at configuration v13. This is already true in the initial state.
           2.  `atconf(v14, v15)`: Rover v14 must be at configuration v15. This is already true in the initial state.
           3.  `free(v12, v16)`: Rover v12's store v16 must be free. This is already true in the initial state.
           4.  `free(v14, v16)`: Rover v14's store v16 must be free. This is already true in the initial state.
           5.  `receivedimage(v17, v11)`: An image of objective v17 in mode v11 must be received.
           6.  `receivedimage(v18, v11)`: An image of objective v18 in mode v11 must be received.
           7.  `receivedimage(v19, v11)`: An image of objective v19 in mode v11 must be received.
           8.  `type(?stone, v2)`: There exists a rock of type v2 (stone).
           9.  `receivedanalysis(?stone)`: An analysis of a rock of type v2 (stone) must be received.
           10. `type(?soil, v6)`: There exists a rock of type v6 (soil).
           11. `receivedanalysis(?soil)`: An analysis of a rock of type v6 (soil) must be received.
           
           From the initial state, we have:
           -   `atconf(v12, v13)` and `atconf(v14, v15)` are true.
           -   `free(v12, v16)` and `free(v14, v16)` are true.
           -   Rocks `v1`, `v3`, `v4` are of type `v2` (stone).
           -   Rocks `v5`, `v7`, `v8` are of type `v6` (soil).
           -   Objectives `v17`, `v18`, `v19` exist.
           -   Camera `v10` is onboard both `v12` and `v14` and supports mode `v11`.
           
           To achieve `receivedanalysis(?stone)` and `receivedanalysis(?soil)`, we need to:
           1.  `sample_rock` of type `v2` (e.g., `v1`, `v3`, `v4`) and a rock of type `v6` (e.g., `v5`, `v7`, `v8`).
           2.  `send_analysis` for both sampled rocks.
           
           To achieve `receivedimage(v17, v11)`, `receivedimage(v18, v11)`, and `receivedimage(v19, v11)`, we need to:
           1.  `calibrate` a camera for each objective.
           2.  `take_image` of each objective.
           3.  `send_image` for each objective.
           
           We have two rovers, `v12` and `v14`. Let's use `v12` for sampling rocks and sending analyses and `v14` for imaging and sending images.
           
           **Sampling and Analysis (Rover v12):**
           -   Rover `v12` is at `v13`.
           -   It is above `v3` (type `v2` - stone) at configuration `#o5`. We can move to `#o5` and sample.
           -   It is above `v5` (type `v6` - soil) at configuration `#q5`. We can move to `#q5` and sample.
           -   To send analysis, `v12` needs to be in a configuration with `comvisible` to `v9` (lander). `comvisible(v12, #q1, #y1, v9)` is true. So we need to move to `#q1` to send analyses.
           
           **Imaging and Sending Images (Rover v14):**
           -   Rover `v14` is at `v15`.
           -   It has `imagevisible` to `v17`, `v18`, `v19` at configuration `#o3` with ray `#o4`.
           -   It has `comvisible` to `v9` at configuration `#o0` with ray `#o1`.
           -   All image visible configurations and communication configurations are accessible by `v14` through moves.
           
           Let's plan:
           
           **Rover v12 actions:**
           1.  Move to `#o5` to sample `v3` (stone).
           2.  Sample `v3`.
           3.  Move to `#q5` to sample `v5` (soil).
           4.  Sample `v5`.
           5.  Move to `#q1` to send analysis.
           6.  Send analysis for `v3`.
           7.  Send analysis for `v5`.
           
           **Rover v14 actions:**
           1.  Move to `#o3`.
           2.  Calibrate for `v17`.
           3.  Take image of `v17`.
           4.  Calibrate for `v18`.
           5.  Take image of `v18`.
           6.  Calibrate for `v19`.
           7.  Take image of `v19`.
           8.  Move to `#o0` to send images.
           9.  Send image of `v17`.
           10. Send image of `v18`.
           11. Send image of `v19`.
           
           Note that the `calibrate` action uncalibrates the camera after `take_image`, so we need to calibrate for each image.
           The order of actions between rovers doesn't strictly matter for the goal predicates, as long as preconditions are met for each individual action.
           
           --Plan--:
           (move v12 v13 #o2 #o5)
           (sample_rock v12 #o5 v3 v16)
           (move v12 #o5 #o2 #q5)
           (sample_rock v12 #q5 v5 v16)
           (move v12 #q5 #o2 #q1)
           (send_analysis v12 #q1 #y1 v9 v3)
           (send_analysis v12 #q1 #y1 v9 v5)
           (move v14 v15 #o2 #o3)
           (calibrate v14 #o3 #o4 v17 v10)
           (take_image v14 #o3 #o4 v17 v10 v11)
           (calibrate v14 #o3 #o4 v18 v10)
           (take_image v14 #o3 #o4 v18 v10 v11)
           (calibrate v14 #o3 #o4 v19 v10)
           (take_image v14 #o3 #o4 v19 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v17 v11)
           (send_image v14 #o0 #o1 v9 v18 v11)
           (send_image v14 #o0 #o1 v9 v19 v11)

User:      The plan you provided is not valid because: `Fact is not satisfied: Atom new-axiom@0()`. Recall that the action preconditions and the goal *must* be satisfied.
           
           Please provide a plan that achieves the goal from the initial state ensuring that action preconditions are satisfied and adhering to the response format.

Model:     The previous plan aimed to satisfy the literal conditions of `new-axiom@0()`, but the validator indicated it was not achieved. Let's re-examine the goal `new-axiom@0()`. This axiom is a conjunction of several atoms. All of these atoms need to be true for the axiom to be satisfied.
           
           The atoms are:
           1.  `atconf(v12, v13)`: True initially.
           2.  `atconf(v14, v15)`: True initially.
           3.  `free(v12, v16)`: True initially.
           4.  `free(v14, v16)`: True initially.
           5.  `receivedimage(v17, v11)`
           6.  `receivedimage(v18, v11)`
           7.  `receivedimage(v19, v11)`
           8.  `type(?stone, v2)`: True initially for v1, v3, v4.
           9.  `receivedanalysis(?stone)`: This means `receivedanalysis(v1)` or `receivedanalysis(v3)` or `receivedanalysis(v4)`.
           10. `type(?soil, v6)`: True initially for v5, v7, v8.
           11. `receivedanalysis(?soil)`: This means `receivedanalysis(v5)` or `receivedanalysis(v7)` or `receivedanalysis(v8)`.
           
           My previous plan attempted to achieve all these. The issue must lie in one of the specific sub-goals not being met, or a precondition was not correctly checked by my previous reasoning. Let's trace it carefully.
           
           For `receivedanalysis(?stone)`:
           -   Sample a rock of type `v2` (e.g., `v3`). `sample_rock(v12, #o5, v3, v16)`. Preconditions: `above(v12, #o5, v3)`, `store(v16)`, `atconf(v12, #o5)`, `free(v12, v16)`.
               -   `atconf(v12, v13)` is true initially.
               -   Move `v12` from `v13` to `#o5`. `motion(v12, v13, #o2, #o5)` exists.
               -   `above(v12, #o5, v3)` is true.
               -   `free(v12, v16)` is true.
               -   `store(v16)` is true.
               -   After `sample_rock`, `analyzed(v12, v3)` becomes true and `full(v12, v16)` becomes true.
           -   Send analysis of `v3`. `send_analysis(v12, #q1, #y1, v9, v3)`. Preconditions: `comvisible(v12, #q1, #y1, v9)`, `rock(v3)`, `analyzed(v12, v3)`, `atconf(v12, #q1)`, `~blocked(#y1)`.
               -   `comvisible(v12, #q1, #y1, v9)` is true.
               -   `rock(v3)` is true.
               -   Need `atconf(v12, #q1)`. Move `v12` from `#o5` to `#q1`. `motion(v12, #o5, #o2, #q1)` exists.
               -   `analyzed(v12, v3)` becomes true after `sample_rock`.
               -   `~blocked(#y1)` is assumed true as no `blocked` atom is given, and no `test-cfree-ray-conf-negative` implies it.
               -   After `send_analysis`, `receivedanalysis(v3)` becomes true, satisfying `receivedanalysis(?stone)`.
           
           For `receivedanalysis(?soil)`:
           -   Sample a rock of type `v6` (e.g., `v5`). `sample_rock(v12, #q5, v5, v16)`. Preconditions: `above(v12, #q5, v5)`, `store(v16)`, `atconf(v12, #q5)`, `free(v12, v16)`.
               -   After sampling `v3`, `free(v12, v16)` becomes false and `full(v12, v16)` becomes true. This is the problem! I need to drop the rock before sampling another one, or use a different rover, or ensure a free store.
               -   The axiom `new-axiom@0()` doesn't require a specific rover to do the analysis, just that *some* rock of type stone and *some* rock of type soil are analyzed.
               -   Rover `v12` has only one store `v16` and it becomes `full` after `sample_rock`.
               -   `drop_rock(v12, v16)` can make `v16` free again.
           
           Let's adjust the sampling strategy.
           
           **Revised Rover v12 actions for analysis:**
           1.  Move to `#o5`.
           2.  Sample `v3` (stone). Now `full(v12, v16)` is true, `analyzed(v12, v3)` is true.
           3.  Move to `#q1`.
           4.  Send analysis of `v3`. Now `receivedanalysis(v3)` is true.
           5.  Drop `v3`. Now `free(v12, v16)` is true again.
           6.  Move to `#q5`.
           7.  Sample `v5` (soil). Now `full(v12, v16)` is true, `analyzed(v12, v5)` is true.
           8.  Move back to `#q1`.
           9.  Send analysis of `v5`. Now `receivedanalysis(v5)` is true.
           
           **Revised Rover v14 actions for images:**
           The logic for images seems robust, assuming no `blocked` rays.
           1.  Move `v14` to `#o3`.
           2.  Calibrate `v10` for `v17`.
           3.  Take image of `v17`. (Camera `v10` becomes uncalibrated).
           4.  Calibrate `v10` for `v18`.
           5.  Take image of `v18`. (Camera `v10` becomes uncalibrated).
           6.  Calibrate `v10` for `v19`.
           7.  Take image of `v19`. (Camera `v10` becomes uncalibrated).
           8.  Move `v14` to `#o0`.
           9.  Send image `v17`.
           10. Send image `v18`.
           11. Send image `v19`.
           
           This strategy addresses the `full` store issue.
           
           --Plan--:
           (move v12 v13 #o2 #o5)
           (sample_rock v12 #o5 v3 v16)
           (move v12 #o5 #o2 #q1)
           (send_analysis v12 #q1 #y1 v9 v3)
           (drop_rock v12 v16)
           (move v12 #q1 #o2 #q5)
           (sample_rock v12 #q5 v5 v16)
           (move v12 #q5 #o2 #q1)
           (send_analysis v12 #q1 #y1 v9 v5)
           (move v14 v15 #o2 #o3)
           (calibrate v14 #o3 #o4 v17 v10)
           (take_image v14 #o3 #o4 v17 v10 v11)
           (calibrate v14 #o3 #o4 v18 v10)
           (take_image v14 #o3 #o4 v18 v10 v11)
           (calibrate v14 #o3 #o4 v19 v10)
           (take_image v14 #o3 #o4 v19 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v17 v11)
           (send_image v14 #o0 #o1 v9 v18 v11)
           (send_image v14 #o0 #o1 v9 v19 v11)

User:      The plan you provided is not valid because: `Fact is not satisfied: Atom new-axiom@0()`. Recall that the action preconditions and the goal *must* be satisfied.
           
           Please provide a plan that achieves the goal from the initial state ensuring that action preconditions are satisfied and adhering to the response format.

Model:     The goal `new-axiom@0()` represents a conjunction of several conditions. Since the previous plan was still deemed invalid, let's meticulously review each condition of `new-axiom@0()` and ensure every step in the plan contributes to its satisfaction, keeping in mind the exact state changes and available actions.
           
           The conditions for `new-axiom@0()` are:
           1.  `atconf(v12, v13)`: (Initial state: true)
           2.  `atconf(v14, v15)`: (Initial state: true)
           3.  `free(v12, v16)`: (Initial state: true. After `sample_rock`, becomes false. After `drop_rock`, becomes true.)
           4.  `free(v14, v16)`: (Initial state: true) - Rover v14 doesn't sample, so this should remain true.
           5.  `receivedimage(v17, v11)`
           6.  `receivedimage(v18, v11)`
           7.  `receivedimage(v19, v11)`
           8.  `type(?stone, v2)`: (Initial state: e.g., `type(v3, v2)`)
           9.  `receivedanalysis(?stone)`: (Achieved by `send_analysis` after `sample_rock` for a type `v2` rock)
           10. `type(?soil, v6)`: (Initial state: e.g., `type(v5, v6)`)
           11. `receivedanalysis(?soil)`: (Achieved by `send_analysis` after `sample_rock` for a type `v6` rock)
           
           Let's re-verify the plan's actions and preconditions, focusing on potential missed nuances:
           
           **Rover v12 (Sampling and Analysis)**
           *   Initial: `atconf(v12, v13)`, `free(v12, v16)`
           *   Goal: `receivedanalysis(v3)` (stone), `receivedanalysis(v5)` (soil)
               *   To get `receivedanalysis(v3)`:
                   *   `move v12 v13 #o2 #o5`: Pre: `atconf(v12, v13)`, `motion(v12, v13, #o2, #o5)`. Effects: `atconf(v12, #o5)`. (Valid)
                   *   `sample_rock v12 #o5 v3 v16`: Pre: `above(v12, #o5, v3)`, `store(v16)`, `atconf(v12, #o5)`, `free(v12, v16)`. Effects: `full(v12, v16)`, `analyzed(v12, v3)`, `~free(v12, v16)`. (Valid, `free(v12, v16)` was true, becomes false)
                   *   `move v12 #o5 #o2 #q1`: Pre: `atconf(v12, #o5)`, `motion(v12, #o5, #o2, #q1)`. Effects: `atconf(v12, #q1)`. (Valid)
                   *   `send_analysis v12 #q1 #y1 v9 v3`: Pre: `comvisible(v12, #q1, #y1, v9)`, `rock(v3)`, `analyzed(v12, v3)`, `atconf(v12, #q1)`, `~blocked(#y1)`. Effects: `receivedanalysis(v3)`. (Valid, `analyzed(v12, v3)` was true from sampling)
               *   To get `receivedanalysis(v5)`:
                   *   `drop_rock v12 v16`: Pre: `rover(v12)`, `store(v16)`, `full(v12, v16)`. Effects: `free(v12, v16)`, `~full(v12, v16)`. (Valid, `full(v12, v16)` was true, becomes false, `free(v12, v16)` becomes true)
                   *   `move v12 #q1 #o2 #q5`: Pre: `atconf(v12, #q1)`, `motion(v12, #q1, #o2, #q5)`. Effects: `atconf(v12, #q5)`. (Valid)
                   *   `sample_rock v12 #q5 v5 v16`: Pre: `above(v12, #q5, v5)`, `store(v16)`, `atconf(v12, #q5)`, `free(v12, v16)`. Effects: `full(v12, v16)`, `analyzed(v12, v5)`, `~free(v12, v16)`. (Valid, `free(v12, v16)` was true, becomes false)
                   *   `move v12 #q5 #o2 #q1`: Pre: `atconf(v12, #q5)`, `motion(v12, #q5, #o2, #q1)`. Effects: `atconf(v12, #q1)`. (Valid)
                   *   `send_analysis v12 #q1 #y1 v9 v5`: Pre: `comvisible(v12, #q1, #y1, v9)`, `rock(v5)`, `analyzed(v12, v5)`, `atconf(v12, #q1)`, `~blocked(#y1)`. Effects: `receivedanalysis(v5)`. (Valid, `analyzed(v12, v5)` was true from sampling)
           
           **Rover v14 (Imaging and Sending)**
           *   Initial: `atconf(v14, v15)`
           *   Goal: `receivedimage(v17, v11)`, `receivedimage(v18, v11)`, `receivedimage(v19, v11)`
               *   `move v14 v15 #o2 #o3`: Pre: `atconf(v14, v15)`, `motion(v14, v15, #o2, #o3)`. Effects: `atconf(v14, #o3)`. (Valid)
               *   `calibrate v14 #o3 #o4 v17 v10`: Pre: `imagevisible(v14, #o3, #o4, v17)`, `onboard(v10, v14)`, `atconf(v14, #o3)`, `~blocked(#o4)`. Effects: `calibrated(v10, v14)`. (Valid)
               *   `take_image v14 #o3 #o4 v17 v10 v11`: Pre: `imagevisible(v14, #o3, #o4, v17)`, `onboard(v10, v14)`, `supports(v10, v11)`, `atconf(v14, #o3)`, `calibrated(v10, v14)`, `~blocked(#o4)`. Effects: `haveimage(v14, v17, v11)`, `~calibrated(v10, v14)`. (Valid, `calibrated` was set by previous action, becomes false)
               *   `calibrate v14 #o3 #o4 v18 v10`: Pre: `imagevisible(v14, #o3, #o4, v18)`, `onboard(v10, v14)`, `atconf(v14, #o3)`, `~blocked(#o4)`. Effects: `calibrated(v10, v14)`. (Valid, recalibrating)
               *   `take_image v14 #o3 #o4 v18 v10 v11`: Pre: `imagevisible(v14, #o3, #o4, v18)`, `onboard(v10, v14)`, `supports(v10, v11)`, `atconf(v14, #o3)`, `calibrated(v10, v14)`, `~blocked(#o4)`. Effects: `haveimage(v14, v18, v11)`, `~calibrated(v10, v14)`. (Valid)
               *   `calibrate v14 #o3 #o4 v19 v10`: Pre: `imagevisible(v14, #o3, #o4, v19)`, `onboard(v10, v14)`, `atconf(v14, #o3)`, `~blocked(#o4)`. Effects: `calibrated(v10, v14)`. (Valid)
               *   `take_image v14 #o3 #o4 v19 v10 v11`: Pre: `imagevisible(v14, #o3, #o4, v19)`, `onboard(v10, v14)`, `supports(v10, v11)`, `atconf(v14, #o3)`, `calibrated(v10, v14)`, `~blocked(#o4)`. Effects: `haveimage(v14, v19, v11)`, `~calibrated(v10, v14)`. (Valid)
               *   `move v14 #o3 #o2 #o0`: Pre: `atconf(v14, #o3)`, `motion(v14, #o3, #o2, #o0)`. Effects: `atconf(v14, #o0)`. (Valid)
               *   `send_image v14 #o0 #o1 v9 v17 v11`: Pre: `comvisible(v14, #o0, #o1, v9)`, `objective(v17)`, `mode(v11)`, `haveimage(v14, v17, v11)`, `atconf(v14, #o0)`, `~blocked(#o1)`. Effects: `receivedimage(v17, v11)`. (Valid)
               *   `send_image v14 #o0 #o1 v9 v18 v11`: Pre: `comvisible(v14, #o0, #o1, v9)`, `objective(v18)`, `mode(v11)`, `haveimage(v14, v18, v11)`, `atconf(v14, #o0)`, `~blocked(#o1)`. Effects: `receivedimage(v18, v11)`. (Valid)
               *   `send_image v14 #o0 #o1 v9 v19 v11`: Pre: `comvisible(v14, #o0, #o1, v9)`, `objective(v19)`, `mode(v11)`, `haveimage(v14, v19, v11)`, `atconf(v14, #o0)`, `~blocked(#o1)`. Effects: `receivedimage(v19, v11)`. (Valid)
           
           All the necessary sub-goals seem to be achieved in the correct sequence with satisfied preconditions. The issue might be very subtle, or perhaps the axiom `new-axiom@0()` refers to something beyond what I'm directly mapping.
           
           One possibility for the `new-axiom@0()` not being satisfied could be due to a specific object for `?stone` or `?soil` not being chosen.
           `type(v3, v2)` (stone) and `type(v5, v6)` (soil) are explicitly in the initial state. My plan uses these exact objects.
           
           Let's ensure that the continuous parameters are correctly used. All `#o` and `#q` values for positions and `#t` for trajectories are used consistently as they appear in `motion` or `above` or `imagevisible` or `comvisible` predicates. `#y` values for rays are also consistent.
           No `blocked` conditions are explicitly stated in the initial state, so we assume `~blocked` is true.
           
           Given the comprehensive check, the plan should be valid according to the PDDL definition. I will provide the same plan again. There might be an environmental factor or an assumption I'm making about the axiom that isn't true. However, based *strictly* on the PDDL and provided information, this plan fulfills all conditions.
           
           --Plan--:
           (move v12 v13 #o2 #o5)
           (sample_rock v12 #o5 v3 v16)
           (move v12 #o5 #o2 #q1)
           (send_analysis v12 #q1 #y1 v9 v3)
           (drop_rock v12 v16)
           (move v12 #q1 #o2 #q5)
           (sample_rock v12 #q5 v5 v16)
           (move v12 #q5 #o2 #q1)
           (send_analysis v12 #q1 #y1 v9 v5)
           (move v14 v15 #o2 #o3)
           (calibrate v14 #o3 #o4 v17 v10)
           (take_image v14 #o3 #o4 v17 v10 v11)
           (calibrate v14 #o3 #o4 v18 v10)
           (take_image v14 #o3 #o4 v18 v10 v11)
           (calibrate v14 #o3 #o4 v19 v10)
           (take_image v14 #o3 #o4 v19 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v17 v11)
           (send_image v14 #o0 #o1 v9 v18 v11)
           (send_image v14 #o0 #o1 v9 v19 v11)

User:      The plan you provided is not valid because: `Fact is not satisfied: Atom new-axiom@0()`. Recall that the action preconditions and the goal *must* be satisfied.
           
           Please provide a plan that achieves the goal from the initial state ensuring that action preconditions are satisfied and adhering to the response format.

Model:     The goal `Atom new-axiom@0()` being unsatisfied despite a seemingly complete plan implies a deeper misunderstanding of the axiom's conditions or how they interact. Let's look very closely at the `new-axiom@0()` definitions provided at the beginning.
           
           There are *many* identical `new-axiom@0()` definitions. They all list the same conjunction of atoms:
           ```
             Conjunction
               Atom atconf(v12, v13)
               Atom atconf(v14, v15)
               Atom free(v12, v16)
               Atom free(v14, v16)
               Atom receivedimage(v17, v11)
               Atom receivedimage(v18, v11)
               Atom receivedimage(v19, v11)
               Atom type(?stone, v2)
               Atom receivedanalysis(?stone)
               Atom type(?soil, v6)
               Atom receivedanalysis(?soil)
           ```
           
           The key insight might be that the existence of *some* `?stone` and `?soil` of specific types is part of the axiom, along with their `receivedanalysis`.
           My plan ensures `receivedanalysis(v3)` (where `v3` is `type v2`, stone) and `receivedanalysis(v5)` (where `v5` is `type v6`, soil). These should satisfy `type(?stone, v2) AND receivedanalysis(?stone)` and `type(?soil, v6) AND receivedanalysis(?soil)`.
           
           The state of `free(v12, v16)` and `free(v14, v16)` must be true at the *end* of the plan for the axiom to hold.
           In my previous plan:
           -   `free(v12, v16)` starts true.
           -   Becomes false after `sample_rock v12 #o5 v3 v16`.
           -   Becomes true after `drop_rock v12 v16`.
           -   Becomes false after `sample_rock v12 #q5 v5 v16`.
           -   **Crucially, it is left as `full(v12, v16)` at the end of the plan.** This would make `free(v12, v16)` false, and thus the axiom `new-axiom@0()` would not be satisfied!
           
           This is a critical oversight. Rover `v12` must `drop_rock` after the second sample and analysis for `v16` to be `free` again at the plan's conclusion.
           
           Let's correct this. After sending the analysis of `v5`, `v12` should drop `v5`.
           
           **Revised Rover v12 actions for analysis (Final correction):**
           1.  Move to `#o5`.
           2.  Sample `v3` (stone). Now `full(v12, v16)` is true, `analyzed(v12, v3)` is true.
           3.  Move to `#q1`.
           4.  Send analysis of `v3`. Now `receivedanalysis(v3)` is true.
           5.  Drop `v3`. Now `free(v12, v16)` is true again.
           6.  Move to `#q5`.
           7.  Sample `v5` (soil). Now `full(v12, v16)` is true, `analyzed(v12, v5)` is true.
           8.  Move back to `#q1`.
           9.  Send analysis of `v5`. Now `receivedanalysis(v5)` is true.
           10. **ADDITION:** Drop `v5`. Now `free(v12, v16)` is true again at the end of the plan.
           
           The rest of the plan for Rover `v14` remains correct.
           
           --Plan--:
           (move v12 v13 #o2 #o5)
           (sample_rock v12 #o5 v3 v16)
           (move v12 #o5 #o2 #q1)
           (send_analysis v12 #q1 #y1 v9 v3)
           (drop_rock v12 v16)
           (move v12 #q1 #o2 #q5)
           (sample_rock v12 #q5 v5 v16)
           (move v12 #q5 #o2 #q1)
           (send_analysis v12 #q1 #y1 v9 v5)
           (drop_rock v12 v16)
           (move v14 v15 #o2 #o3)
           (calibrate v14 #o3 #o4 v17 v10)
           (take_image v14 #o3 #o4 v17 v10 v11)
           (calibrate v14 #o3 #o4 v18 v10)
           (take_image v14 #o3 #o4 v18 v10 v11)
           (calibrate v14 #o3 #o4 v19 v10)
           (take_image v14 #o3 #o4 v19 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v17 v11)
           (send_image v14 #o0 #o1 v9 v18 v11)
           (send_image v14 #o0 #o1 v9 v19 v11)

User:      The plan you provided is not valid because: `Fact is not satisfied: Atom new-axiom@0()`. Recall that the action preconditions and the goal *must* be satisfied.
           
           Please provide a plan that achieves the goal from the initial state ensuring that action preconditions are satisfied and adhering to the response format.

Model:     The goal `new-axiom@0()` is persistently reported as unsatisfied. Given the repeated failures, there must be a very specific interpretation or constraint I am missing. Let's revisit the goal statement and the domain completely.
           
           The goal `new-axiom@0()` is a conjunction of these atoms:
           1.  `atconf(v12, v13)`: (True initially)
           2.  `atconf(v14, v15)`: (True initially)
           3.  `free(v12, v16)`: (True initially. Must be true at the end.)
           4.  `free(v14, v16)`: (True initially. Must be true at the end.)
           5.  `receivedimage(v17, v11)`
           6.  `receivedimage(v18, v11)`
           7.  `receivedimage(v19, v11)`
           8.  `type(?stone, v2)`: This just asserts that there *is* an object of type v2 which is considered stone. `v3` is of type `v2`.
           9.  `receivedanalysis(?stone)`: This means `receivedanalysis(v3)` or `receivedanalysis(v1)` or `receivedanalysis(v4)` for example.
           10. `type(?soil, v6)`: Similar to stone, `v5` is of type `v6`.
           11. `receivedanalysis(?soil)`: This means `receivedanalysis(v5)` or `receivedanalysis(v7)` or `receivedanalysis(v8)`.
           
           My previous plan successfully ensures `receivedanalysis(v3)` and `receivedanalysis(v5)`. It also ensures `receivedimage(v17, v11)`, `receivedimage(v18, v11)`, and `receivedimage(v19, v11)`. The `atconf` states are maintained or restored. The `free` states are restored for `v12, v16` and `v14, v16` is never used for sampling.
           
           Could it be the `blocked(?y)` predicate? The definition is:
           `Axiom blocked(?y: object)`
             `Conjunction`
               `Atom ray(?y)`
               `Atom conf(?v, ?q)`
               `Atom ~test-cfree-ray-conf-negative(?y, ?v, ?q)`
               `Atom atconf(?v, ?q)`
           
           My assumption has been that since `blocked(?y)` isn't explicitly stated, `~blocked(?y)` is true. If any of the rays used (`#y0`, `#y1`, `#y2`, `#y3`, `#o1`, `#o4`) were blocked, then `take_image`, `send_image`, or `send_analysis` would fail. However, the problem statement says "Any fact that is not explicitly stated in the initial state is *false*." This implies `blocked(?y)` is false for all `?y` because there are no `blocked` facts in the initial state. This interpretation leads to `~blocked(?y)` being true. So, this is likely not the issue.
           
           Let's re-examine the objects and the structure. Maybe the variables in the axiom are instantiated differently than I expect.
           `Atom type(?stone, v2)` and `Atom receivedanalysis(?stone)`: These mean there must exist *some* object, let's call it `stone_obj`, such that `type(stone_obj, v2)` is true AND `receivedanalysis(stone_obj)` is true. My plan ensures `receivedanalysis(v3)` and `type(v3, v2)` is true. So `?stone` can be instantiated as `v3`.
           Similarly for soil. My plan ensures `receivedanalysis(v5)` and `type(v5, v6)` is true. So `?soil` can be instantiated as `v5`.
           
           Could there be a timing issue? All actions are sequential. `atconf` must be true at the start of an action and is modified immediately.
           
           What if some continuous parameters `#o` or `#q` are not valid across different actions for the same object?
           E.g., `above(v12, #o5, v3)` and `above(v12, #o5, v4)`. These mean that at configuration `#o5`, `v12` is above both `v3` and `v4`.
           This seems fine. The `conf` predicates (e.g., `conf(v12, #o5)`) exist for all configurations I'm using.
           
           Could the problem be simpler than I am making it? The axiom definition of `new-axiom@0()` is listed multiple times. Perhaps this indicates something specific, but typically duplicate axioms are just redundant.
           
           Let's try a minimal change. What if only one rover must achieve *all* parts of the goal? The problem description does not indicate this constraint. The goal involves states of different rovers and objectives, so it implies a global state.
           
           Perhaps a specific sequence of sampling and image taking is required, or maybe some resource is implicitly exhausted?
           For example, if `v16` (the store) was rover-specific instead of a general store object. "free(v14, v16)" indicates `v14` *also* has `v16`. But `onboard(v10, v12)` and `onboard(v10, v14)` shows `v10` can be used by both rovers. `store(v16)` indicates `v16` is a general store. If `v16` is shared, then `v14` cannot be assumed `free(v14, v16)` if `v12` made it `full(v12, v16)`.
           This is a critical point. `store(v16)` is a global object.
           If `v16` is a *global* store that both `v12` and `v14` can utilize, then:
           -   `free(v12, v16)` means `v12` has an empty slot in `v16`.
           -   `free(v14, v16)` means `v14` has an empty slot in `v16`.
           This usually implies that each rover has its *own* stores, and `v16` is just the *type* of store. But the objects are `v12`, `v14` as rovers and `v16` as *the* store object. If it means `v16` is *a* specific physical storage unit, it means `v16` is a shared resource.
           The predicates `free(?v: object, ?s: object)` and `full(?v: object, ?s: object)` link the rover and the store. This means `v16` is associated with the rover `v`. So `v12` has its own capacity associated with `v16`, and `v14` has its own capacity associated with `v16`. My interpretation of `v16` as a specific store on each rover is likely correct given the predicates. If it was a shared physical location, the predicates would more likely be `store_free(v16)` or `store_full(v16)`.
           
           Let's consider if it's strictly necessary to move between sampling and sending analysis.
           For `v12` (sampling and analysis):
           -   Sample `v3` at `#o5`. `analyzed(v12, v3)` and `full(v12, v16)`.
           -   Move to `#q1` for `send_analysis`. This is necessary as `comvisible(v12, #q1, #y1, v9)` is the only `comvisible` fact for `v12` given.
           -   Drop `v3`. `free(v12, v16)`.
           -   Sample `v5` at `#q5`. `analyzed(v12, v5)` and `full(v12, v16)`.
           -   Move to `#q1` for `send_analysis`. This is necessary.
           -   Send analysis for `v5`. `receivedanalysis(v5)`.
           -   Drop `v5`. `free(v12, v16)`.
           
           This sequence ensures `free(v12, v16)` at the end and both analyses are sent.
           
           For `v14` (imaging and sending):
           -   Move to `#o3`.
           -   Calibrate, Take Image for `v17`. `haveimage(v14, v17, v11)`. Camera uncalibrated.
           -   Calibrate, Take Image for `v18`. `haveimage(v14, v18, v11)`. Camera uncalibrated.
           -   Calibrate, Take Image for `v19`. `haveimage(v14, v19, v11)`. Camera uncalibrated.
           -   Move to `#o0` for `send_image`. This is necessary as `comvisible(v14, #o0, #o1, v9)` is the only `comvisible` fact for `v14` given.
           -   Send image for `v17`. `receivedimage(v17, v11)`.
           -   Send image for `v18`. `receivedimage(v18, v11)`.
           -   Send image for `v19`. `receivedimage(v19, v11)`.
           
           This sequence ensures all images are taken and sent.
           The predicates `atconf(v12, v13)` and `atconf(v14, v15)` are not necessarily required at the *end* state, but are true initially. Since no action forces `v12` to `v13` or `v14` to `v15` by the end of the plan, these predicates might be false at the plan's end.
           The goal states: `Atom atconf(v12, v13)` and `Atom atconf(v14, v15)`. This means that at the very end of the plan, these must be true.
           This is the most likely error I've made. My plan leaves `v12` at `#q1` and `v14` at `#o0`. They must be moved back to `v13` and `v15` respectively!
           
           **Final corrections:**
           -   After `send_analysis v12 #q1 #y1 v9 v5`, `v12` must move from `#q1` back to `v13`.
           -   After `send_image v14 #o0 #o1 v9 v19 v11`, `v14` must move from `#o0` back to `v15`.
           
           Let's incorporate these final moves.
           
           --Plan--:
           (move v12 v13 #o2 #o5)
           (sample_rock v12 #o5 v3 v16)
           (move v12 #o5 #o2 #q1)
           (send_analysis v12 #q1 #y1 v9 v3)
           (drop_rock v12 v16)
           (move v12 #q1 #o2 #q5)
           (sample_rock v12 #q5 v5 v16)
           (move v12 #q5 #o2 #q1)
           (send_analysis v12 #q1 #y1 v9 v5)
           (drop_rock v12 v16)
           (move v12 #q1 #t7 v13) ; Move v12 back to v13
           (move v14 v15 #o2 #o3)
           (calibrate v14 #o3 #o4 v17 v10)
           (take_image v14 #o3 #o4 v17 v10 v11)
           (calibrate v14 #o3 #o4 v18 v10)
           (take_image v14 #o3 #o4 v18 v10 v11)
           (calibrate v14 #o3 #o4 v19 v10)
           (take_image v14 #o3 #o4 v19 v10 v11)
           (move v14 #o3 #o2 #o0)
           (send_image v14 #o0 #o1 v9 v17 v11)
           (send_image v14 #o0 #o1 v9 v18 v11)
           (send_image v14 #o0 #o1 v9 v19 v11)
           (move v14 #o0 #o2 v15) ; Move v14 back to v15

