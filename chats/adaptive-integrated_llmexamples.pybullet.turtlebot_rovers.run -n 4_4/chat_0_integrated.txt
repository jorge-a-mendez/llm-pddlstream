User:      Here is a list of objects present in this scene for this task: 
           
           ```
           #o0: object
           #o1: object
           #o2: object
           #o3: object
           #o4: object
           #o5: object
           v1: object
           v10: object
           v11: object
           v12: object
           v13: object
           v14: object
           v15: object
           v16: object
           v17: object
           v18: object
           v19: object
           v2: object
           v20: object
           v3: object
           v4: object
           v5: object
           v6: object
           v7: object
           v8: object
           v9: object
           ```
           
           Some of the objects represent continuous values that have already been computed. In particular:
           Object v17 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-0.59, 1.966), (-0.493, 2.063)).
           Object v3 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((1.104, -0.817), (1.209, -0.712)).
           Object v15 is a base configuration with (x, y, theta) = (-1.0, -1.75, 0.0).
           Object v9 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-2.405, -2.346), (-1.395, -1.654)).
           Object v18 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((0.62, 1.986), (0.714, 2.08)).
           Object v13 is a base configuration with (x, y, theta) = (1.0, -1.75, 3.142).
           Object v1 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((0.765, 0.665), (0.867, 0.767)).
           Object v5 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-1.066, 0.969), (-0.925, 1.11)).
           Object v19 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((1.905, 2.045), (1.99, 2.13)).
           Object v4 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((1.633, -0.598), (1.733, -0.498)).
           Object v7 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-2.008, -0.027), (-1.895, 0.086)).
           Object v20 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-2.059, 1.892), (-1.987, 1.964)).
           Object v14 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((-1.187, -1.929), (-0.821, -1.571)).
           Object v12 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((0.821, -1.929), (1.187, -1.571)).
           Object v8 is an object with axis aligned bounding box (AABB = ((minx, miny), (maxx, maxy))): ((0.376, -1.67), (0.517, -1.529)).
           
           You *must* use these values to select actions that are more likely to be executable (e.g., objects that are not obstructed by others) and that will have the least cost (e.g., objects that are closer to the robot or to the target region).
           
           The initial state is given by the following facts: 
           
           ```
           Atom objective(v18)
           Atom type(v1, v2)
           Atom camera(v10)
           Atom conf(v14, v15)
           Atom rock(v5)
           Atom objective(v17)
           Atom atconf(v12, v13)
           Atom onboard(v10, v12)
           Atom supports(v10, v11)
           Atom objective(v20)
           Atom conf(v12, v13)
           Atom rock(v4)
           Atom lander(v9)
           Atom objective(v19)
           Atom rock(v3)
           Atom type(v5, v6)
           Atom type(v7, v6)
           Atom rock(v7)
           Atom rock(v1)
           Atom rock(v8)
           Atom atconf(v14, v15)
           Atom mode(v11)
           Atom free(v12, v16)
           Atom rover(v14)
           Atom rover(v12)
           Atom onboard(v10, v14)
           Atom free(v14, v16)
           Atom type(v3, v2)
           Atom store(v16)
           Atom type(v8, v6)
           Atom type(v4, v2)
           Atom imagevisible(v12, #o3, #o4, v19)
           Atom imagerange(v12, #o3, v19)
           Atom conf(v12, #o3)
           Atom ray(#o4)
           Atom imagevisible(v12, #o3, #o4, v17)
           Atom imagerange(v12, #o3, v17)
           Atom imagevisible(v14, #o3, #o4, v19)
           Atom imagerange(v14, #o3, v19)
           Atom conf(v14, #o3)
           Atom imagevisible(v14, #o3, #o4, v17)
           Atom imagerange(v14, #o3, v17)
           Atom comvisible(v12, #o0, #o1, v9)
           Atom comrange(v12, #o0, v9)
           Atom conf(v12, #o0)
           Atom ray(#o1)
           Atom comvisible(v14, #o0, #o1, v9)
           Atom comrange(v14, #o0, v9)
           Atom conf(v14, #o0)
           Atom above(v12, #o5, v5)
           Atom conf(v12, #o5)
           Atom above(v14, #o5, v5)
           Atom conf(v14, #o5)
           Atom above(v12, #o5, v4)
           Atom above(v14, #o5, v4)
           Atom motion(v12, v13, #o2, v13)
           Atom imagevisible(v14, #o3, #o4, v18)
           Atom imagerange(v14, #o3, v18)
           Atom imagevisible(v12, #o3, #o4, v18)
           Atom imagerange(v12, #o3, v18)
           Atom motion(v14, v15, #o2, v15)
           Atom imagevisible(v12, #o3, #o4, v20)
           Atom imagerange(v12, #o3, v20)
           Atom imagevisible(v14, #o3, #o4, v20)
           Atom imagerange(v14, #o3, v20)
           Atom above(v12, #o5, v8)
           Atom above(v14, #o5, v8)
           Atom above(v12, #o5, v1)
           Atom above(v14, #o5, v1)
           Atom above(v14, #o5, v7)
           Atom above(v12, #o5, v7)
           Atom above(v14, #o5, v3)
           Atom above(v12, #o5, v3)
           ```
           
           The goal expression is `Atom new-axiom@0()`. Given these elements, the list of available action instances is:
           
           ```
           ((move v12 v13 #o2 v13))
           ((move v14 v15 #o2 v15))
           ((drop_rock v12 v16))
           ((drop_rock v14 v16))
           ```
           
           Please provide a plan that achieves the goal from the initial state.

Model:     The problem requires satisfying the `new-axiom@0` axiom. This axiom has several components, but given the available actions and initial state, the key parts we can influence are `receivedimage` for multiple objectives with mode `v11` and `receivedanalysis` for `v2` (stone) and `v6` (soil) type rocks.
           
           Looking at the initial state, we have two rovers, `v12` and `v14`, and a camera `v10` that supports mode `v11`. Both rovers are at their respective initial configurations (`v13` for `v12` and `v15` for `v14`). Both rovers have the camera `v10` onboard.
           
           The goal involves having `receivedimage` for `v17`, `v18`, `v19`, `v20` with `v11` mode. These are all `objective` objects. The rovers also need to `receivedanalysis` for a rock of type `v2` (stone) and a rock of type `v6` (soil).
           
           Let's break down how to achieve these:
           
           **1. Received Images:**
              - To get `receivedimage(?o, ?m)`, a rover needs to `send_image`.
              - To `send_image`, the rover needs to `haveimage(?v, ?o, ?m)`.
              - To `haveimage`, the rover needs to `take_image`.
              - To `take_image`, the camera needs to be `calibrated`.
              - To `calibrate`, the rover needs to be at a configuration where the `imagevisible` predicate is true.
           
              We have `imagevisible` predicates for both `v12` and `v14` for all target objectives (`v17`, `v18`, `v19`, `v20`) at a common continuous configuration `#o3` with a common ray `#o4`. This is good, as we can calibrate, take an image, and then send the image using that same configuration.
           
              We also have `comvisible` predicates for both `v12` and `v14` to the lander `v9` at a common continuous configuration `#o0` with a common ray `#o1`. This will be used for sending images and analysis.
           
           **2. Received Analysis:**
              - To get `receivedanalysis(?r)`, a rover needs to `send_analysis`.
              - To `send_analysis`, the rover needs to have `analyzed(?v, ?r)`.
              - To `analyzed(?v, ?r)`, the rover needs to `sample_rock`.
              - To `sample_rock`, the rover needs to be `above(?v, ?q, ?r)` and have a `free` store.
           
              Both rovers `v12` and `v14` have `free` store `v16`. They are also `above` many rocks at continuous configuration `#o5`. We need to sample one rock of type `v2` (stone) and one of type `v6` (soil).
              - Rocks of type `v2` (stone): `v1`, `v3`, `v4`.
              - Rocks of type `v6` (soil): `v5`, `v7`, `v8`.
           
              We can use `v12` to handle one set of tasks (e.g., images and one rock type) and `v14` to handle the other, or one rover can do all the image tasks and another all the sampling tasks. Since the image and communication configurations are shared, it seems efficient for one rover to handle the image tasks. For simplicity, let's have `v12` handle taking and sending images and `v14` handle sampling and sending analysis. However, since the goal requires `receivedimage` to be true for multiple objectives, and `calibrated` becomes false after `take_image`, we need to recalibrate for each image or choose a different strategy. But, the provided action instances are limited. Let's re-evaluate.
           
           The available action instances are very limited: `move` and `drop_rock`. This means we cannot use `take_image`, `calibrate`, `send_image`, `sample_rock`, or `send_analysis`. This implies that the goal `new-axiom@0()` must be achievable through the initial state and these very limited actions.
           
           Let's re-examine the `new-axiom@0()` axiom:
           ```
           Axiom new-axiom@0()
             Conjunction
               Atom atconf(v12, v13)
               Atom atconf(v14, v15)
               Atom free(v12, v16)
               Atom free(v14, v16)
               Atom receivedimage(v17, v11)
               Atom receivedimage(v18, v11)
               Atom receivedimage(v19, v11)
               Atom receivedimage(v20, v11)
               Atom type(?stone, v2)
               Atom receivedanalysis(?stone)
               Atom type(?soil, v6)
               Atom receivedanalysis(?soil)
           ```
           The initial state already has:
           - `atconf(v12, v13)`
           - `atconf(v14, v15)`
           - `free(v12, v16)`
           - `free(v14, v16)`
           
           The remaining conditions are:
           - `receivedimage(v17, v11)`
           - `receivedimage(v18, v11)`
           - `receivedimage(v19, v11)`
           - `receivedimage(v20, v11)`
           - `receivedanalysis(?stone)` for a rock of type `v2`
           - `receivedanalysis(?soil)` for a rock of type `v6`
           
           Since the only available actions are `move` and `drop_rock`, and these actions do not affect any `receivedimage` or `receivedanalysis` predicates, it implies that these predicates *must* already be true in the initial state or be achievable through an axiom that uses only predicates that are true or can be made true by `move`/`drop_rock`. However, `new-axiom@0()` refers to itself, which doesn't help in achieving its conditions.
           
           The `new-axiom@0()` in the initial state is a statement of the goal, not a fact that triggers other facts. The problem states "Any fact that is not explicitly stated in the initial state is *false*".
           
           Therefore, if `receivedimage` and `receivedanalysis` are not explicitly stated in the initial state, they are false. The provided action instances do not include any actions that can make `receivedimage` or `receivedanalysis` true. This means the goal is unreachable with the given allowed actions.
           
           The presence of multiple `new-axiom@0()` definitions, which are identical and circularly reference predicates that are part of the goal state, along with an extremely restricted set of available action instances, strongly indicates that the intention might be that these `receivedimage` and `receivedanalysis` facts are *supposed* to be true by some implicit mechanism not fully captured by the provided PDDL, or that the problem is designed to be unsolvable under these strict constraints.
           
           Given the strict instruction: "Any action instance that is not in the given list is not allowed to be used in the plan. Any fact that is not explicitly stated in the initial state is *false*.", and the absence of any `receivedimage` or `receivedanalysis` predicates in the initial state, and the inability of `move` or `drop_rock` to achieve them, the goal is unreachable.
           
           The `new-axiom@0` definition is also confusing. It seems to be defining what it means for the axiom itself to be true, not a way to derive other facts. If `new-axiom@0()` were a derived predicate, its definition would describe how it becomes true based on other facts. Here it describes a conjunction of facts that are part of the goal. The problem is effectively asking us to reach a state where all these facts are true.
           
           Since the actions to generate images and analyses are not allowed, the only way for the goal to be true is if the `receivedimage` and `receivedanalysis` facts are already true. They are not. Therefore, the goal is unreachable.

