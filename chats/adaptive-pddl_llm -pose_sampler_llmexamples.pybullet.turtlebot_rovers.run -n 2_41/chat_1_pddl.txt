User:      Here is a list of objects present in this scene for this task: 
           
           ```
           #o0: object
           #o1: object
           #o2: object
           #o3: object
           #o4: object
           #o5: object
           v1: object
           v10: object
           v11: object
           v12: object
           v13: object
           v14: object
           v15: object
           v16: object
           v17: object
           v18: object
           v2: object
           v3: object
           v4: object
           v5: object
           v6: object
           v7: object
           v8: object
           v9: object
           ```
           
           The initial state is given by the following facts: 
           
           ```
           Atom type(v1, v2)
           Atom conf(v14, v15)
           Atom rock(v1)
           Atom type(v8, v6)
           Atom supports(v10, v11)
           Atom type(v5, v6)
           Atom atconf(v14, v15)
           Atom objective(v17)
           Atom free(v14, v16)
           Atom type(v3, v2)
           Atom rock(v3)
           Atom rock(v8)
           Atom onboard(v10, v14)
           Atom free(v12, v16)
           Atom conf(v12, v13)
           Atom type(v4, v2)
           Atom onboard(v10, v12)
           Atom type(v7, v6)
           Atom rover(v14)
           Atom rock(v7)
           Atom rock(v4)
           Atom store(v16)
           Atom camera(v10)
           Atom mode(v11)
           Atom lander(v9)
           Atom atconf(v12, v13)
           Atom objective(v18)
           Atom rock(v5)
           Atom rover(v12)
           Atom motion(v14, v15, #o2, v15)
           Atom above(v12, #o5, v5)
           Atom conf(v12, #o5)
           Atom imagevisible(v12, #o3, #o4, v18)
           Atom imagerange(v12, #o3, v18)
           Atom conf(v12, #o3)
           Atom ray(#o4)
           Atom comvisible(v12, #o0, #o1, v9)
           Atom comrange(v12, #o0, v9)
           Atom conf(v12, #o0)
           Atom ray(#o1)
           Atom above(v12, #o5, v8)
           Atom above(v12, #o5, v3)
           Atom above(v12, #o5, v4)
           Atom above(v12, #o5, v7)
           Atom above(v14, #o5, v4)
           Atom conf(v14, #o5)
           Atom comvisible(v14, #o0, #o1, v9)
           Atom comrange(v14, #o0, v9)
           Atom conf(v14, #o0)
           Atom above(v14, #o5, v3)
           Atom above(v14, #o5, v8)
           Atom imagevisible(v14, #o3, #o4, v18)
           Atom imagerange(v14, #o3, v18)
           Atom conf(v14, #o3)
           Atom above(v14, #o5, v7)
           Atom above(v14, #o5, v5)
           Atom above(v14, #o5, v1)
           Atom above(v12, #o5, v1)
           Atom imagevisible(v12, #o3, #o4, v17)
           Atom imagerange(v12, #o3, v17)
           Atom imagevisible(v14, #o3, #o4, v17)
           Atom imagerange(v14, #o3, v17)
           Atom motion(v12, v13, #o2, v13)
           Atom motion(v14, #o3, #o2, #o3)
           Atom motion(v14, v15, #o2, #o3)
           Atom motion(v14, #o3, #o2, v15)
           Atom motion(v14, #o3, #o2, #o0)
           Atom motion(v14, v15, #o2, #o0)
           Atom motion(v14, #o0, #o2, #o3)
           Atom motion(v14, #o0, #o2, v15)
           Atom motion(v14, #o0, #o2, #o0)
           Atom motion(v12, #o5, #o2, v13)
           Atom motion(v12, #o5, #o2, #o5)
           Atom motion(v12, v13, #o2, #o5)
           Atom motion(v12, #o3, #o2, v13)
           Atom motion(v12, #o3, #o2, #o3)
           Atom motion(v12, #o5, #o2, #o3)
           Atom motion(v12, #o3, #o2, #o5)
           Atom motion(v12, v13, #o2, #o3)
           Atom motion(v14, #o3, #o2, #o5)
           Atom motion(v14, #o5, #o2, #o0)
           Atom motion(v14, #o5, #o2, #o3)
           Atom motion(v14, v15, #o2, #o5)
           Atom motion(v14, #o0, #o2, #o5)
           Atom motion(v14, #o5, #o2, #o5)
           Atom motion(v14, #o5, #o2, v15)
           Atom motion(v12, #o0, #o2, #o3)
           Atom motion(v12, #o0, #o2, #o0)
           Atom motion(v12, #o3, #o2, #o0)
           Atom motion(v12, v13, #o2, #o0)
           Atom motion(v12, #o5, #o2, #o0)
           Atom motion(v12, #o0, #o2, #o5)
           Atom motion(v12, #o0, #o2, v13)
           ```
           
           The goal expression is `Atom new-axiom@0()`. Given these elements, the list of available action instances is:
           
           ```
           ((sample_rock v12 #o5 v1 v16))
           ((sample_rock v12 #o5 v3 v16))
           ((sample_rock v12 #o5 v4 v16))
           ((sample_rock v12 #o5 v5 v16))
           ((sample_rock v12 #o5 v7 v16))
           ((sample_rock v12 #o5 v8 v16))
           ((sample_rock v14 #o5 v1 v16))
           ((sample_rock v14 #o5 v3 v16))
           ((sample_rock v14 #o5 v4 v16))
           ((sample_rock v14 #o5 v5 v16))
           ((sample_rock v14 #o5 v7 v16))
           ((sample_rock v14 #o5 v8 v16))
           ((move v12 #o0 #o2 #o0))
           ((move v12 #o0 #o2 #o3))
           ((move v12 #o0 #o2 #o5))
           ((move v12 #o0 #o2 v13))
           ((move v12 #o3 #o2 #o0))
           ((move v12 #o3 #o2 #o3))
           ((move v12 #o3 #o2 #o5))
           ((move v12 #o3 #o2 v13))
           ((move v12 #o5 #o2 #o0))
           ((move v12 #o5 #o2 #o3))
           ((move v12 #o5 #o2 #o5))
           ((move v12 #o5 #o2 v13))
           ((move v12 v13 #o2 #o0))
           ((move v12 v13 #o2 #o3))
           ((move v12 v13 #o2 #o5))
           ((move v12 v13 #o2 v13))
           ((move v14 #o0 #o2 #o0))
           ((move v14 #o0 #o2 #o3))
           ((move v14 #o0 #o2 #o5))
           ((move v14 #o0 #o2 v15))
           ((move v14 #o3 #o2 #o0))
           ((move v14 #o3 #o2 #o3))
           ((move v14 #o3 #o2 #o5))
           ((move v14 #o3 #o2 v15))
           ((move v14 #o5 #o2 #o0))
           ((move v14 #o5 #o2 #o3))
           ((move v14 #o5 #o2 #o5))
           ((move v14 #o5 #o2 v15))
           ((move v14 v15 #o2 #o0))
           ((move v14 v15 #o2 #o3))
           ((move v14 v15 #o2 #o5))
           ((move v14 v15 #o2 v15))
           ((calibrate v12 #o3 #o4 v17 v10))
           ((calibrate v12 #o3 #o4 v18 v10))
           ((calibrate v14 #o3 #o4 v17 v10))
           ((calibrate v14 #o3 #o4 v18 v10))
           ((take_image v12 #o3 #o4 v17 v10 v11))
           ((take_image v12 #o3 #o4 v18 v10 v11))
           ((take_image v14 #o3 #o4 v17 v10 v11))
           ((take_image v14 #o3 #o4 v18 v10 v11))
           ((drop_rock v12 v16))
           ((send_analysis v12 #o0 #o1 v9 v1))
           ((send_analysis v12 #o0 #o1 v9 v3))
           ((send_analysis v12 #o0 #o1 v9 v4))
           ((send_analysis v12 #o0 #o1 v9 v5))
           ((send_analysis v12 #o0 #o1 v9 v7))
           ((send_analysis v12 #o0 #o1 v9 v8))
           ((drop_rock v14 v16))
           ((send_analysis v14 #o0 #o1 v9 v1))
           ((send_analysis v14 #o0 #o1 v9 v3))
           ((send_analysis v14 #o0 #o1 v9 v4))
           ((send_analysis v14 #o0 #o1 v9 v5))
           ((send_analysis v14 #o0 #o1 v9 v7))
           ((send_analysis v14 #o0 #o1 v9 v8))
           ((send_image v12 #o0 #o1 v9 v17 v11))
           ((send_image v12 #o0 #o1 v9 v18 v11))
           ((send_image v14 #o0 #o1 v9 v17 v11))
           ((send_image v14 #o0 #o1 v9 v18 v11))
           ```
           
           Please provide a plan that achieves the goal from the initial state.

Model:     The scene contains two rovers, v12 and v14, two cameras, v10, and multiple rocks and objectives. The goal is `new-axiom@0()`, which is an axiom stating that at least two rovers are at some configuration, both have a free store, two images for different objectives have been received, and two rocks of different types have been analyzed and received.
           
           Currently, both rovers `v12` and `v14` are at their respective `atconf` positions, `v12` at `v13` and `v14` at `v15`. Both rovers also have a `free` store `v16`. Therefore, the first three conditions of the axiom are met.
           
           To satisfy the remaining conditions:
           1. Two images for different objectives must be received.
           2. Two rocks of different types must be analyzed and the analysis received.
           
           Let's break this down:
           **For images:**
           * We have objectives `v17` and `v18`.
           * Rover `v12` can see both `v17` and `v18` from `#o3`.
           * Rover `v14` can also see both `v17` and `v18` from `#o3`.
           * We need to `calibrate` the camera `v10` for each rover and then `take_image` and `send_image`.
           
           **For rocks:**
           * We have rocks `v1, v3, v4` of type `v2` (stone).
           * We have rocks `v5, v7, v8` of type `v6` (soil).
           * We need to `sample_rock` two rocks of different types and then `send_analysis`.
           
           Let's create a plan using rover `v12` for sampling and image taking/sending.
           
           **Plan for images (using rover v12):**
           1. Calibrate camera `v10` for rover `v12` to observe objective `v17`.
           2. Take an image of objective `v17` using `v10` in mode `v11`.
           3. Send the image of `v17` to `lander v9`.
           4. Calibrate camera `v10` for rover `v12` to observe objective `v18`. (Note: Calibrating for v17 uncalibrates, so we need to recalibrate for v18).
           5. Take an image of objective `v18` using `v10` in mode `v11`.
           6. Send the image of `v18` to `lander v9`.
           This will fulfill `receivedimage(v17, v11)` and `receivedimage(v18, v11)`.
           
           **Plan for rocks (using rover v12):**
           1. Sample rock `v1` (type `v2` - stone) using store `v16`.
           2. Send analysis of rock `v1` to `lander v9`.
           3. Drop rock `v1` from store `v16` (to free up the store for the next sample).
           4. Sample rock `v5` (type `v6` - soil) using store `v16`.
           5. Send analysis of rock `v5` to `lander v9`.
           This will fulfill `receivedanalysis(v1)` and `receivedanalysis(v5)`.
           
           The existing `atconf` and `free` conditions for both rovers are already met.
           All necessary actions are available from the provided list.
           
           --Plan--:
           (calibrate v12 #o3 #o4 v17 v10)
           (take_image v12 #o3 #o4 v17 v10 v11)
           (send_image v12 #o0 #o1 v9 v17 v11)
           (calibrate v12 #o3 #o4 v18 v10)
           (take_image v12 #o3 #o4 v18 v10 v11)
           (send_image v12 #o0 #o1 v9 v18 v11)
           (sample_rock v12 #o5 v1 v16)
           (send_analysis v12 #o0 #o1 v9 v1)
           (drop_rock v12 v16)
           (sample_rock v12 #o5 v5 v16)
           (send_analysis v12 #o0 #o1 v9 v5)

User:      The plan you provided is not valid because: `Fact is not satisfied: Atom new-axiom@0()`. Recall that the action preconditions and the goal *must* be satisfied.
           
           Please provide a plan that achieves the goal from the initial state ensuring that action preconditions are satisfied and adhering to the response format.

Model:     The previous plan aimed to achieve the goal `new-axiom@0()` by performing actions with rover `v12`. I incorrectly assumed that satisfying the sub-goals would automatically fulfill the axiom. The issue with the previous plan was not that it failed to satisfy the preconditions of the individual actions, but rather that the overall goal `new-axiom@0()` was not achieved.
           
           Let's re-evaluate the axiom `new-axiom@0()`:
           It requires:
           1. `atconf(v12, v13)`: This is true initially.
           2. `atconf(v14, v15)`: This is true initially.
           3. `free(v12, v16)`: This is true initially.
           4. `free(v14, v16)`: This is true initially.
           5. `receivedimage(v17, v11)`: Needs to be achieved.
           6. `receivedimage(v18, v11)`: Needs to be achieved.
           7. `type(?stone, v2)`: `v1, v3, v4` are of type `v2`. This is implicitly true.
           8. `receivedanalysis(?stone)`: Needs to be achieved for one of the stone types (e.g., `v1`).
           9. `type(?soil, v6)`: `v5, v7, v8` are of type `v6`. This is implicitly true.
           10. `receivedanalysis(?soil)`: Needs to be achieved for one of the soil types (e.g., `v5`).
           
           The previous plan correctly targeted conditions 5, 6, 8, and 10. The plan executed these steps using rover `v12`. The problem might have been in the order or if any condition was inadvertently undone.
           Specifically, `drop_rock` makes `free(v12, v16)` true again, which is good.
           
           Let's trace the state changes with the previous plan to see if `new-axiom@0()` is satisfied at the end.
           Initial state:
           `atconf(v12, v13)`, `atconf(v14, v15)`, `free(v12, v16)`, `free(v14, v16)` (Conditions 1-4 are met).
           `receivedimage(v17, v11)`: False
           `receivedimage(v18, v11)`: False
           `receivedanalysis(v1)`: False
           `receivedanalysis(v5)`: False
           
           Plan execution:
           1. `(calibrate v12 #o3 #o4 v17 v10)`: `calibrated(v10, v12)` becomes true.
           2. `(take_image v12 #o3 #o4 v17 v10 v11)`: `haveimage(v12, v17, v11)` becomes true. `calibrated(v10, v12)` becomes false.
           3. `(send_image v12 #o0 #o1 v9 v17 v11)`: `receivedimage(v17, v11)` becomes true. `haveimage(v12, v17, v11)` becomes false.
           4. `(calibrate v12 #o3 #o4 v18 v10)`: `calibrated(v10, v12)` becomes true.
           5. `(take_image v12 #o3 #o4 v18 v10 v11)`: `haveimage(v12, v18, v11)` becomes true. `calibrated(v10, v12)` becomes false.
           6. `(send_image v12 #o0 #o1 v9 v18 v11)`: `receivedimage(v18, v11)` becomes true. `haveimage(v12, v18, v11)` becomes false.
              At this point, `receivedimage(v17, v11)` and `receivedimage(v18, v11)` are true (Conditions 5 & 6 met).
           
           7. `(sample_rock v12 #o5 v1 v16)`: `full(v12, v16)` becomes true. `analyzed(v12, v1)` becomes true. `free(v12, v16)` becomes false.
           8. `(send_analysis v12 #o0 #o1 v9 v1)`: `receivedanalysis(v1)` becomes true. `analyzed(v12, v1)` becomes false.
           9. `(drop_rock v12 v16)`: `free(v12, v16)` becomes true. `full(v12, v16)` becomes false.
              At this point, `receivedanalysis(v1)` is true (Condition 8 met). And `free(v12, v16)` is still true (Condition 3 is maintained).
           
           10. `(sample_rock v12 #o5 v5 v16)`: `full(v12, v16)` becomes true. `analyzed(v12, v5)` becomes true. `free(v12, v16)` becomes false.
           11. `(send_analysis v12 #o0 #o1 v9 v5)`: `receivedanalysis(v5)` becomes true. `analyzed(v12, v5)` becomes false.
              At this point, `receivedanalysis(v5)` is true (Condition 10 met).
           
           After the plan:
           `atconf(v12, v13)`: True
           `atconf(v14, v15)`: True
           `free(v12, v16)`: False (because of the last `sample_rock`)
           `free(v14, v16)`: True
           `receivedimage(v17, v11)`: True
           `receivedimage(v18, v11)`: True
           `receivedanalysis(v1)`: True
           `receivedanalysis(v5)`: True
           
           The issue is that `free(v12, v16)` is not true at the very end due to the last `sample_rock` action. To satisfy the axiom `free(v12, v16)`, we need to `drop_rock` after the last `sample_rock` if it's the final state.
           
           Let's correct the plan to ensure `free(v12, v16)` is true at the end.
           
           --Plan--:
           (calibrate v12 #o3 #o4 v17 v10)
           (take_image v12 #o3 #o4 v17 v10 v11)
           (send_image v12 #o0 #o1 v9 v17 v11)
           (calibrate v12 #o3 #o4 v18 v10)
           (take_image v12 #o3 #o4 v18 v10 v11)
           (send_image v12 #o0 #o1 v9 v18 v11)
           (sample_rock v12 #o5 v1 v16)
           (send_analysis v12 #o0 #o1 v9 v1)
           (drop_rock v12 v16)
           (sample_rock v12 #o5 v5 v16)
           (send_analysis v12 #o0 #o1 v9 v5)
           (drop_rock v12 v16)

User:      The plan you provided is not valid because: `Precondition fact ('atconf', v12, #o0) is not satisfied!`. Recall that the action preconditions and the goal *must* be satisfied.
           
           Please provide a plan that achieves the goal from the initial state ensuring that action preconditions are satisfied and adhering to the response format.

Model:     The previous plan failed because the precondition `atconf(v12, #o0)` was not met for the `send_image` and `send_analysis` actions. The rover `v12` was initially at `atconf(v12, v13)` and the `calibrate` and `take_image` actions were done from `atconf(v12, #o3)` or `atconf(v12, v13)`. The `send_image` and `send_analysis` actions require `atconf(v12, #o0)`. So, the rover needs to move to `#o0` before sending data.
           
           Let's re-examine the available moves for `v12`:
           `motion(v12, v13, #o2, v13)`
           `motion(v12, v13, #o2, #o0)`
           `motion(v12, v13, #o2, #o3)`
           `motion(v12, v13, #o2, #o5)`
           And similar motions from `#o0`, `#o3`, `#o5`.
           
           The initial configuration of rover `v12` is `atconf(v12, v13)`.
           The `imagevisible` predicates show that `v12` can see objectives from `#o3`.
           The `comvisible` predicates show that `v12` can communicate from `#o0`.
           The `above` predicates show that `v12` can sample rocks from `#o5`.
           
           So, the plan needs to involve moving the rover to the correct configurations for each task.
           
           Revised Plan Structure:
           1. **Move to image taking configuration:** `v12` is at `v13`. It needs to move to `#o3` for `take_image`.
           2. **Calibrate and take images:** For `v17` and `v18`.
           3. **Move to communication configuration:** From `#o3` to `#o0` to `send_image`.
           4. **Send images:** For `v17` and `v18`.
           5. **Move to rock sampling configuration:** From `#o0` to `#o5` to `sample_rock`.
           6. **Sample rocks:** `v1` (stone) and `v5` (soil).
           7. **Move to communication configuration:** From `#o5` to `#o0` to `send_analysis`.
           8. **Send analysis:** For `v1` and `v5`.
           9. **Ensure `free(v12, v16)` at the end:** Drop any sampled rocks.
           
           Let's construct the plan step-by-step:
           
           Initial state: `atconf(v12, v13)`, `free(v12, v16)`, `atconf(v14, v15)`, `free(v14, v16)`.
           
           --Plan--:
           (move v12 v13 #o2 #o3) ; Move to #o3 for image taking. Current: atconf(v12, #o3)
           (calibrate v12 #o3 #o4 v17 v10) ; Calibrate for v17
           (take_image v12 #o3 #o4 v17 v10 v11) ; Take image of v17
           (calibrate v12 #o3 #o4 v18 v10) ; Calibrate for v18 (uncalibrated after take_image)
           (take_image v12 #o3 #o4 v18 v10 v11) ; Take image of v18
           (move v12 #o3 #o2 #o0) ; Move to #o0 for communication. Current: atconf(v12, #o0)
           (send_image v12 #o0 #o1 v9 v17 v11) ; Send image of v17
           (send_image v12 #o0 #o1 v9 v18 v11) ; Send image of v18
           (move v12 #o0 #o2 #o5) ; Move to #o5 for rock sampling. Current: atconf(v12, #o5)
           (sample_rock v12 #o5 v1 v16) ; Sample rock v1 (stone)
           (drop_rock v12 v16) ; Drop rock to free store
           (sample_rock v12 #o5 v5 v16) ; Sample rock v5 (soil)
           (move v12 #o5 #o2 #o0) ; Move to #o0 for communication. Current: atconf(v12, #o0)
           (send_analysis v12 #o0 #o1 v9 v1) ; Send analysis of v1
           (send_analysis v12 #o0 #o1 v9 v5) ; Send analysis of v5
           (drop_rock v12 v16) ; Drop rock to ensure free(v12, v16) for the goal.

User:      The plan you provided is not valid because: `Fact is not satisfied: Atom new-axiom@0()`. Recall that the action preconditions and the goal *must* be satisfied.
           
           Please provide a plan that achieves the goal from the initial state ensuring that action preconditions are satisfied and adhering to the response format.

Model:     The previous plan's execution was carefully traced and the preconditions for each action seemed to be met. The problem statement indicates that `new-axiom@0()` was still not satisfied. Let's re-verify the full set of conditions for `new-axiom@0()`:
           
           `atconf(v12, v13)`
           `atconf(v14, v15)`
           `free(v12, v16)`
           `free(v14, v16)`
           `receivedimage(v17, v11)`
           `receivedimage(v18, v11)`
           `type(?stone, v2)` (implicit, e.g., v1 is type v2)
           `receivedanalysis(?stone)` (e.g., receivedanalysis(v1))
           `type(?soil, v6)` (implicit, e.g., v5 is type v6)
           `receivedanalysis(?soil)` (e.g., receivedanalysis(v5))
           
           Let's re-trace the previous plan's effects on these specific goal predicates:
           
           Initial State:
           `atconf(v12, v13)` (True)
           `atconf(v14, v15)` (True)
           `free(v12, v16)` (True)
           `free(v14, v16)` (True)
           `receivedimage(v17, v11)` (False)
           `receivedimage(v18, v11)` (False)
           `receivedanalysis(v1)` (False)
           `receivedanalysis(v5)` (False)
           
           Plan:
           1. `(move v12 v13 #o2 #o3)`: `atconf(v12, #o3)` True, `atconf(v12, v13)` False.
              *Problem*: This fails the first condition `atconf(v12, v13)`. The goal state requires both rovers to be at specific, *initial* configurations. This means that if a rover moves, it must return to its initial configuration or the goal will not be met for that part.
           
           This is a critical oversight. The `atconf` predicates in the `new-axiom@0()` must hold at the *end* of the plan. My interpretation of the axiom was that `v12` and `v14` are at *some* configuration, not necessarily *their initial* configurations. However, the use of `v13` and `v15` (which are the initial configurations for `v12` and `v14` respectively) explicitly points to those specific configurations.
           
           Therefore, rovers `v12` and `v14` must end up at `v13` and `v15` respectively. This means any rover that moves must return to its initial configuration.
           
           Let's revise the plan with this constraint:
           
           The plan will primarily use rover `v12` to perform all necessary tasks (image capture/send, rock sample/send) and then return `v12` to its original configuration `v13`. Rover `v14` doesn't need to move since its conditions are met initially and do not change.
           
           **Revised Plan Logic:**
           1. Rover `v12` starts at `v13`.
           2. Move `v12` to `#o3` (for imaging).
           3. Calibrate camera `v10` for `v17`.
           4. Take image of `v17`.
           5. Calibrate camera `v10` for `v18`.
           6. Take image of `v18`.
           7. Move `v12` to `#o0` (for communication).
           8. Send image of `v17`.
           9. Send image of `v18`.
           10. Move `v12` to `#o5` (for sampling).
           11. Sample rock `v1` (type `v2`).
           12. Drop rock `v1` (to free storage for `v5`).
           13. Sample rock `v5` (type `v6`).
           14. Move `v12` to `#o0` (for communication).
           15. Send analysis of `v1`.
           16. Send analysis of `v5`.
           17. Drop rock `v5` (to ensure `free(v12, v16)` at the end).
           18. Move `v12` back to `v13`.
           
           --Plan--:
           (move v12 v13 #o2 #o3)
           (calibrate v12 #o3 #o4 v17 v10)
           (take_image v12 #o3 #o4 v17 v10 v11)
           (calibrate v12 #o3 #o4 v18 v10)
           (take_image v12 #o3 #o4 v18 v10 v11)
           (move v12 #o3 #o2 #o0)
           (send_image v12 #o0 #o1 v9 v17 v11)
           (send_image v12 #o0 #o1 v9 v18 v11)
           (move v12 #o0 #o2 #o5)
           (sample_rock v12 #o5 v1 v16)
           (drop_rock v12 v16)
           (sample_rock v12 #o5 v5 v16)
           (move v12 #o5 #o2 #o0)
           (send_analysis v12 #o0 #o1 v9 v1)
           (send_analysis v12 #o0 #o1 v9 v5)
           (drop_rock v12 v16)
           (move v12 #o0 #o2 v13)

